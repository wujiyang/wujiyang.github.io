

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="wujiyang">
  <meta name="keywords" content="">
  
    <meta name="description" content="互斥锁是在并发程序中对共享资源进行访问控制的主要手段，对此 Go 语言提供了简单易用的 Mutex，它是一种用于并发编程中的同步机制，用于确保在同一时刻只有一个 goroutine 可以访问共享资源。">
<meta property="og:type" content="article">
<meta property="og:title" content="Golang 互斥锁 sync.Mutex">
<meta property="og:url" content="https://wujiyang.github.io/2024/11/08/Golang-Mutex%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="wujiyang">
<meta property="og:description" content="互斥锁是在并发程序中对共享资源进行访问控制的主要手段，对此 Go 语言提供了简单易用的 Mutex，它是一种用于并发编程中的同步机制，用于确保在同一时刻只有一个 goroutine 可以访问共享资源。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wujiyang.github.io/img/Golang-Mutex%E8%A7%A3%E6%9E%90/0.png">
<meta property="article:published_time" content="2024-11-08T06:26:35.000Z">
<meta property="article:modified_time" content="2024-12-08T06:50:10.107Z">
<meta property="article:author" content="wujiyang">
<meta property="article:tag" content="Golang">
<meta property="article:tag" content="Mutex">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://wujiyang.github.io/img/Golang-Mutex%E8%A7%A3%E6%9E%90/0.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>Golang 互斥锁 sync.Mutex - wujiyang</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"wujiyang.github.io","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":60,"cursorChar":"","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":4},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 50vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>wujiyang</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Golang 互斥锁 sync.Mutex"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          5k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          51 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Golang 互斥锁 sync.Mutex</h1>
            
            
              <div class="markdown-body">
                
                <p>互斥锁是在并发程序中对共享资源进行访问控制的主要手段，对此 Go 语言提供了简单易用的 Mutex，它是一种用于并发编程中的同步机制，用于确保在同一时刻只有一个 goroutine 可以访问共享资源。</p>
<span id="more"></span>  

<h2 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1. 背景介绍"></a>1. 背景介绍</h2><h3 id="1-1-基本信息"><a href="#1-1-基本信息" class="headerlink" title="1.1 基本信息"></a>1.1 基本信息</h3><p>互斥锁是在并发程序中对共享资源进行访问控制的主要手段，对此 Go 语言提供了简单易用的 Mutex，它是一种用于并发编程中的同步机制，用于确保在同一时刻只有一个 goroutine 可以访问共享资源。<br><strong>主要特点</strong>：</p>
<ul>
<li>互斥性：Mutex的核心特性是互斥性，即保证在任何时刻只有一个 goroutine 可以持有锁并访问被保护的共享资源。这有效地防止了多个 goroutine 同时对共享资源进行读写操作而导致的数据竞争和不一致问题。</li>
<li>原子性操作：在获取和释放锁的过程中，Mutex的操作是原子性的。这意味着在一个 goroutine 尝试获取锁时，其他 goroutine 不能同时进行获取锁的操作，直到当前持有锁的 goroutine 释放锁。</li>
<li>不可重入性：Go语言的Mutex只记录了加锁状态，没有记录锁的所有者，所以不支持可重入，自己加的锁别人也可以打开</li>
</ul>
<h3 id="1-2-为什么要使用Mutex"><a href="#1-2-为什么要使用Mutex" class="headerlink" title="1.2 为什么要使用Mutex"></a>1.2 为什么要使用Mutex</h3><p>我们看一个示例，启动 10000 个协程将变量 num 加1，因此肯定会存在并发；如果我们不控制并发，10000 个协程都执行完后，该变量的值很大概率不等于 10000。但是如果使用并发的话，总能得到正确的结果。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    num := <span class="hljs-number">0</span><br>    threadCount := <span class="hljs-number">10000</span><br><br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    wg.Add(threadCount)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; threadCount; i++ &#123;<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            <span class="hljs-keyword">defer</span> wg.Done()<br>            num++<br>        &#125;()<br>    &#125;<br><br>    wg.Wait()        <span class="hljs-comment">// 等待 10000 个协程都执行完</span><br>    fmt.Println(num) <span class="hljs-comment">// 9388(每次都可能不一样)</span><br><br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    num := <span class="hljs-number">0</span><br>    threadCount := <span class="hljs-number">10000</span><br><br>    <span class="hljs-keyword">var</span> mutex sync.Mutex <span class="hljs-comment">// 互斥锁</span><br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    wg.Add(threadCount)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; threadCount; i++ &#123;<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            <span class="hljs-keyword">defer</span> wg.Done()<br>            mutex.Lock()   <span class="hljs-comment">// 加锁</span><br>            num++          <span class="hljs-comment">// 临界区</span><br>            mutex.Unlock() <span class="hljs-comment">// 解锁</span><br>        &#125;()<br>    &#125;<br><br>    wg.Wait()        <span class="hljs-comment">// 等待 10000 个协程都执行完</span><br>    fmt.Println(num) <span class="hljs-comment">// 结果为10000</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>从上面可以看到，Mutex可以保证并发编程过程中的数据一致性和稳定性，实现并发安全编程。</p>
<h3 id="1-3-基本操作"><a href="#1-3-基本操作" class="headerlink" title="1.3 基本操作"></a>1.3 基本操作</h3><p>Mutex 是一个结构体，对外提供 Lock()和Unlock()两个方法，分别用来加锁和解锁。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// A Locker represents an object that can be locked and unlocked.</span><br><span class="hljs-keyword">type</span> Locker <span class="hljs-keyword">interface</span> &#123;<br>    Lock()<br>    Unlock()<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>加锁（Lock）：当一个 goroutine 需要访问被互斥锁保护的共享资源时，它首先需要调用互斥锁的Lock方法。这个方法会阻塞当前线程，直到互斥锁被释放，然后当前线程获得锁并可以继续执行对共享资源的访问操作。</li>
<li>解锁（Unlock）：当一个线程完成对共享资源的访问后，它应该调用互斥锁的Unlock方法来释放锁，以便其他等待的线程可以获得锁并访问共享资源。</li>
</ol>
<h2 id="2-核心原理"><a href="#2-核心原理" class="headerlink" title="2. 核心原理"></a>2. 核心原理</h2><h3 id="2-1-数据结构"><a href="#2-1-数据结构" class="headerlink" title="2.1 数据结构"></a>2.1 数据结构</h3><p>Go 语言的 sync.Mutex由两个字段 state 和 sema 组成。其中 state 表示当前互斥锁的状态，而 sema 是用于控制锁状态的信号量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Mutex <span class="hljs-keyword">struct</span> &#123;    <br>    state <span class="hljs-type">int32</span>  <span class="hljs-comment">// 复合字段，不仅能表示锁的状态，还能表示等待锁的协程个数 </span><br>    sema  <span class="hljs-type">uint32</span> <span class="hljs-comment">// 信号量，协程阻塞会等待该信号量，解锁的协程释放信号量从而唤醒等待信号量的协程</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>互斥锁的状态比较复杂，最低三位分别表示 mutexLocked、mutexWoken 和 mutexStarving，剩下的位置用来表示当前有多少个 Goroutine 在等待互斥锁的释放<br><img src="/img/Golang-Mutex%E8%A7%A3%E6%9E%90/1.png" srcset="/img/loading.gif" lazyload><br>int32 中的不同位分别表示了不同的状态，默认情况下：互斥锁的所有状态位都是 0，即默认为未锁定状态</p>
<ul>
<li>mutexLocked — 表示互斥锁的锁定状态；</li>
<li>mutexWoken — 表示是否有协程被唤醒；</li>
<li>mutexStarving — 当前的互斥锁进入饥饿状态；</li>
<li>waitersCount — 当前互斥锁上等待的 Goroutine 个数<br>相关常量定义：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// sync/mutex.go 36</span><br><span class="hljs-keyword">const</span> (<br>    mutexLocked = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-literal">iota</span> <span class="hljs-comment">// 1 0001 含义：用最后一位表示当前对象锁的状态，0-未锁住 1-已锁住</span><br>    mutexWoken <span class="hljs-comment">// 2 0010 含义：用倒数第二位表示是否已经有协程被唤醒 0-未唤醒 1-已有协程唤醒</span><br>    mutexStarving <span class="hljs-comment">// 4 0100 含义：用倒数第三位表示当前Mutex是否为饥饿模式，0为正常模式，1为饥饿模式。</span><br>    mutexWaiterShift = <span class="hljs-literal">iota</span> <span class="hljs-comment">// 3，从倒数第四位往前的bit位表示在排队等待的goroutine数</span><br>    <br>    starvationThresholdNs = <span class="hljs-number">1e6</span> <span class="hljs-comment">// 1ms 切换到饥饿模式的阈值</span><br>)<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-2-Lock"><a href="#2-2-Lock" class="headerlink" title="2.2 Lock"></a>2.2 Lock</h3><p>本小节主要介绍Mutex中加锁的基本逻辑及一些核心思想。</p>
<h4 id="2-2-1-常规"><a href="#2-2-1-常规" class="headerlink" title="2.2.1 常规"></a>2.2.1 常规</h4><p>Mutex的加锁操作是一个阻塞调用，如果在加锁时已经被使用，则当前协程会阻塞直至获取到锁。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> Lock() &#123;<br>    <span class="hljs-comment">// Fast path: grab unlocked mutex.</span><br>    <span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="hljs-number">0</span>, mutexLocked) &#123;<br>        <span class="hljs-keyword">if</span> race.Enabled &#123;<br>            race.Acquire(unsafe.Pointer(m))<br>        &#125;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-comment">// Slow path (outlined so that the fast path can be inlined)</span><br>    m.lockSlow()<br>&#125;<br></code></pre></td></tr></table></figure>
<p>由上面的逻辑可以看到，一个协程在加锁时，分为Fast path和Slow Path, 如果Fast Path能加锁成功，就直接返回了，否则要进入复杂的Slow Path中，这里不详细介绍每一步的源码，只分析核心的逻辑。</p>
<ul>
<li>Fast Path：<ul>
<li>如果m.state为0，说明当前锁处于未锁定状态，尝试使用CAS将其变为锁定状态并直接返回</li>
</ul>
</li>
<li>Slow Path：<ul>
<li>判断当前协程能否进入自旋</li>
<li>通过自旋等待互斥锁的释放</li>
<li>计算互斥锁的最新状态（处理完自旋特殊逻辑后，互斥锁会根据上下文计算当前互斥锁最新的状态）</li>
<li>更新互斥锁的状态并尝试获取锁<ul>
<li>如果获取到锁直接返回</li>
<li>如果没有获取到锁，会调用runtime_SemacquireMutex使协程陷入休眠并等待被唤醒</li>
<li>唤醒后如果处于正常模式，会设置唤醒和饥饿标记、重置迭代次数并重新执行获取锁的循环；</li>
<li>唤醒后如果处于饥饿模式，当前 Goroutine 会获得互斥锁，如果等待队列中只存在当前 Goroutine，互斥锁还会从饥饿模式中退出；119</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-2-2-自旋"><a href="#2-2-2-自旋" class="headerlink" title="2.2.2 自旋"></a>2.2.2 自旋</h4><p>自旋对应 CPU 的 PAUSE 指令，CPU 对该指令什么都不做，相当于空转。对程序而言相当于sleep了很小一段时间，大概 30个时钟周期。  </p>
<p><strong>自旋条件</strong><br>加锁时runtime 会自动判断是否可以自旋，无限制的自旋将给 CPU 带来巨大压力，自旋必须满足以下条件：</p>
<ul>
<li>互斥锁只有在普通模式才能进入自旋；</li>
<li>自旋次数要足够少，通常为 4，即自旋最多 4 次；</li>
<li>CPU 核数要大于 1，否则自旋没有意义，因为此时不可能有其他协程释放锁；</li>
<li>当前机器上至少存在一个正在运行的处理器 P 并且处理的运行队列为空；<br>可见自旋的条件是很苛刻的，简单说就是不忙的时候才会启用自旋。</li>
</ul>
<p><strong>自旋优势</strong><br>自旋的优势是更充分地利用 CPU，尽量避免协程切换。因为当前申请加锁的协程拥有 CPU，如果经过短时间的自旋可以获得锁，则当前写成可以继续运行，不必进入阻塞状态。  </p>
<p><strong>自旋劣势</strong><br>如果在自旋过程中获得锁，那么之前被阻塞的协程就无法获得。如果加锁的协程特别多，每次都通过自旋获取锁，则之前被阻塞的协程将很难获取锁。</p>
<h4 id="2-2-3-Mutex-模式"><a href="#2-2-3-Mutex-模式" class="headerlink" title="2.2.3 Mutex 模式"></a>2.2.3 Mutex 模式</h4><p>正常情况下，锁释放唤醒等待协程时，等待协程会和此时新到的协程以及处于自旋状态的协程一起竞争锁，因为需要进行上下文切换，新唤醒协程大概率争抢不过新协程以及自旋的协程，为了解决这种情况下阻塞队列中协程一直获取不到锁的问题，Mutex引入了模式的概念，分为正常模式和饥饿模式。  </p>
<p><strong>正常模式 Normal</strong>：<br>正常模式下，锁的等待者会按照先进先出的顺序获取锁。但是刚被唤起的协程与新创建的协程竞争时，大概率会获取不到锁，为了减少这种情况的出现，一旦 Goroutine 超过 1ms 没有获取到锁，它就会将当前互斥锁切换饥饿模式，防止部分 Goroutine 被饿死。 </p>
<blockquote>
<p>📌 引入饥饿模式的目的是保证互斥锁的公平性。  </p>
</blockquote>
<p><strong>饥饿模式 Starving</strong>：<br>饥饿模式中，互斥锁的所有权直接从解锁的Goroutine交给等待队列最前面的 Goroutine。新的 Goroutine 在该状态下不能获取锁、也不会进入自旋状态，它们只会在队列的末尾等待。如果一个 Goroutine 获得了互斥锁并且它在队列的末尾或者它等待的时间少于 1ms，那么当前的互斥锁就会切换回正常模式。<br>在Starving模式下，不会启动自旋过程，一旦有协程释放了锁，一定会唤醒协程，被唤醒的协程将成功获取锁，同时会把等待计数减 1。    </p>
<blockquote>
<p>📌  与饥饿模式相比，正常模式下的互斥锁能够提供更好地性能，饥饿模式的能避免 Goroutine 由于陷入等待无法获取锁而造成的长尾延时。 </p>
</blockquote>
<h4 id="2-2-4-Woken-状态"><a href="#2-2-4-Woken-状态" class="headerlink" title="2.2.4 Woken 状态"></a>2.2.4 Woken 状态</h4><p>Woken 状态用于加锁和解锁过程中的通信。比如，同一时刻，两个协程一个在加锁，一个在解锁，在加锁的协程可能在自旋过程中，此时把 Woken 标记为 1，用于通知解锁协程不必释放信号量，类似知会一下对方，不用释放了，我马上就拿到锁了。</p>
<h3 id="2-3-UnLock"><a href="#2-3-UnLock" class="headerlink" title="2.3 UnLock"></a>2.3 UnLock</h3><p>相比于加锁，解锁的逻辑简单许多，同样分为Fast path和Slow Path</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> Unlock() &#123;<br>    <span class="hljs-keyword">if</span> race.Enabled &#123;<br>        _ = m.state<br>        race.Release(unsafe.Pointer(m))<br>    &#125;<br><br>    <span class="hljs-comment">// Fast path: drop lock bit.</span><br>    <span class="hljs-built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">new</span> != <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-comment">// Outlined slow path to allow inlining the fast path.</span><br>        <span class="hljs-comment">// To hide unlockSlow during tracing we skip one extra frame when tracing GoUnblock.</span><br>        m.unlockSlow(<span class="hljs-built_in">new</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>Fast Path：<ul>
<li>使用原子操作直接将状态移除锁标记，如果新状态为0，就成功释放锁；当前操作下说明没有等待协程也没有被唤醒协程。否则就进入Slow Path</li>
</ul>
</li>
<li>Slow Path：<ul>
<li>校验锁的合法性，避免锁被重复解锁</li>
<li>正常模式：如果互斥锁不存在等待者或者互斥锁的 mutexLocked、mutexStarving、mutexWoken 状态不是全部为 0，那么当前方法可以直接返回，不需要唤醒其他等待者；如果互斥锁存在等待者，会通过runtime_Semrelease唤醒等待者并移交锁的所有权；</li>
<li>饥饿模式：直接释放信号量将锁交给下一个等待者</li>
</ul>
</li>
</ul>
<h2 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="3. 应用场景"></a>3. 应用场景</h2><h3 id="3-1-保护共享资源"><a href="#3-1-保护共享资源" class="headerlink" title="3.1 保护共享资源"></a>3.1 保护共享资源</h3><p>在并发编程中，多个 goroutine 可能同时访问和修改同一个共享资源。为了确保数据的一致性和正确性，需要使用互斥锁来保护共享资源。例如，Map 并发读写时会出现 panic，我们可以使用 Mutex 来保护 Map 防止出现 panic。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> SafeMap <span class="hljs-keyword">struct</span> &#123;<br>    m    <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span><br>    lock sync.Mutex<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *SafeMap)</span></span> Put(key <span class="hljs-type">string</span>, value <span class="hljs-type">int</span>) &#123;<br>    s.lock.Lock()<br>    s.m[key] = value<br>    s.lock.Unlock()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *SafeMap)</span></span> Get(key <span class="hljs-type">string</span>) (<span class="hljs-type">int</span>, <span class="hljs-type">bool</span>) &#123;<br>    s.lock.Lock()<br>    value, ok := s.m[key]<br>    s.lock.Unlock()<br>    <span class="hljs-keyword">return</span> value, ok<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="3-2-同步Goroutine"><a href="#3-2-同步Goroutine" class="headerlink" title="3.2 同步Goroutine"></a>3.2 同步Goroutine</h3><p>在某些情况下，需要确保多个 goroutine 按照特定的顺序执行。可以使用互斥锁来实现这种同步。例如，一个 goroutine 需要等待另一个 goroutine 完成某个任务后才能继续执行。可以使用互斥锁来确保两个 goroutine 之间的同步。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> mutex sync.Mutex<br><span class="hljs-keyword">var</span> done <span class="hljs-type">bool</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker1</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Worker 1 is working...&quot;</span>)<br>    mutex.Lock()<br>    done = <span class="hljs-literal">true</span><br>    mutex.Unlock()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker2</span><span class="hljs-params">()</span></span> &#123;<br>    mutex.Lock()<br>    <span class="hljs-keyword">for</span> !done &#123;<br>        mutex.Unlock()<br>        mutex.Lock()<br>    &#125;<br>    fmt.Println(<span class="hljs-string">&quot;Worker 2 can start working...&quot;</span>)<br>    mutex.Unlock()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">go</span> worker1()<br>    <span class="hljs-keyword">go</span> worker2()<br><br>    time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="3-3-避免数据竞争"><a href="#3-3-避免数据竞争" class="headerlink" title="3.3 避免数据竞争"></a>3.3 避免数据竞争</h3><p>在并发编程中，如果多个 goroutine 同时访问和修改同一个变量，可能会导致数据竞争。使用互斥锁可以避免这种数据竞争。例如，一个 goroutine 正在读取一个变量的值，而另一个 goroutine 正在修改这个变量的值。使用互斥锁可以确保在读取和修改操作之间不会被其他 goroutine 干扰。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> data <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> mutex sync.Mutex<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reader</span><span class="hljs-params">()</span></span> &#123;<br>    mutex.Lock()<br>    fmt.Println(<span class="hljs-string">&quot;Data:&quot;</span>, data)<br>    mutex.Unlock()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writer</span><span class="hljs-params">()</span></span> &#123;<br>    mutex.Lock()<br>    data++<br>    mutex.Unlock()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>        wg.Add(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            <span class="hljs-keyword">defer</span> wg.Done()<br>            reader()<br>        &#125;()<br>        wg.Add(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            <span class="hljs-keyword">defer</span> wg.Done()<br>            writer()<br>        &#125;()<br>    &#125;<br>    wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a>4. 注意事项</h2><p>mutex使用过程简单，只有基本的加锁和解锁操作，但还是有一些点需要注意：</p>
<ol>
<li>Mutex 是可以在 goroutine A 中加锁，在 goroutine B 中解锁的，但是在实际使用中，尽量保证在同一个 goroutine 中加解锁。多次加锁而未解锁可能导致程序“卡死”（也被称为死锁）。尝试解锁一个未加锁的互斥锁可能引发程序崩溃（panic）。</li>
<li>Mutex 的加锁解锁基本都是成对出现，为了解决忘记解锁，可以使用 defer 语句，在加锁后直接 defer mutex.Unlock()；但是如果处理完临界区资源后还有很多耗时操作，为了尽早释放锁，不建议使用 defer，而是在处理完临界区资源后就调用 mutex.Unlock() 尽早释放锁。</li>
<li>Mutex 不能复制使用；Mutex 是有状态的，比如我们对一个 Mutex 加锁后，再进行复制操作，会把当前的加锁状态也给复制过去，基于加锁的 Mutex 再加锁肯定不会成功。进行复制操作可能听起来是一个比较低级的错误，但是无意间可能就会犯这种错误。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Counter <span class="hljs-keyword">struct</span> &#123;<br>    mutex sync.Mutex<br>    num   <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AddFunc</span><span class="hljs-params">(c Counter)</span></span> &#123;<br>    c.mutex.Lock()<br>    <span class="hljs-keyword">defer</span> c.mutex.Unlock()<br>    c.num++<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> counter Counter<br>    counter.mutex.Lock()<br>    <span class="hljs-keyword">defer</span> counter.mutex.Unlock()<br><br>    counter.num++<br>    <span class="hljs-comment">// Go是值传递，这里复制了 counter</span><br>    <span class="hljs-comment">// 此时 counter.mutex 是加锁状态，在 SomeFunc 无法再次加锁，就会死锁</span><br>    AddFunc(counter)<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>注意锁的粒度：锁的粒度指的就是临界区的大小，临界区的代码都是串行执行的。如果锁的粒度太大，可能会导致并发度降低；如果锁的粒度太小，可能会增加锁的管理开销。在设计并发程序时，应该根据实际情况选择合适的锁粒度。</li>
<li>避免死锁：在使用互斥锁时，要注意避免死锁的发生。死锁是指两个或多个 goroutine 相互等待对方释放锁，导致程序无法继续执行的情况。为了避免死锁，可以按照固定的顺序获取多个锁，或者使用超时机制来避免无限期地等待锁。</li>
</ol>
<h2 id="5-源码分析"><a href="#5-源码分析" class="headerlink" title="5. 源码分析"></a>5. 源码分析</h2><h3 id="5-1-Lock"><a href="#5-1-Lock" class="headerlink" title="5.1 Lock"></a>5.1 Lock</h3><p>Lock()加锁方法分为两部分：</p>
<ol>
<li>第一部分是 fast path，可以理解为快捷通道，如果当前锁没被占用，直接获得锁返回；否则需要进入 slow path。</li>
<li>slow path 判断各种条件去竞争锁，主要逻辑都在此处。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> lockSlow() &#123;<br>    <span class="hljs-keyword">var</span> waitStartTime <span class="hljs-type">int64</span><br>    starving := <span class="hljs-literal">false</span><br>    awoke := <span class="hljs-literal">false</span><br>    iter := <span class="hljs-number">0</span><br>    old := m.state<br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-comment">// 当锁被占用且不处于饥饿状态且可以执行自旋时，进入自旋逻辑</span><br>        <span class="hljs-keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;<br>            <span class="hljs-comment">// 如果当前awoker标志位为false，且等待者不等于0，把自己标记为唤醒的协程</span><br>            <span class="hljs-comment">// 该标记可以告诉Unclock操作不用再唤醒其他协程了(我已经在等锁了，你们不用醒了)</span><br>            <span class="hljs-keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="hljs-number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="hljs-number">0</span> &amp;&amp;<br>                atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;<br>                awoke = <span class="hljs-literal">true</span><br>            &#125;<br>            runtime_doSpin()<br>            iter++<br>            old = m.state<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-comment">// 走到这里说明退出了自旋，当前锁可能 没被占用 或者 锁处于饥饿状态 或者 自旋太多了</span><br>        <span class="hljs-comment">// new 代表当前goroutine基于当前状态接下来要设置的新状态</span><br>        <span class="hljs-built_in">new</span> := old<br>        <span class="hljs-comment">// 只要不是饥饿状态，就试图获取锁（如果是饥饿状态就乖乖去排队）</span><br>        <span class="hljs-keyword">if</span> old&amp;mutexStarving == <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-built_in">new</span> |= mutexLocked<br>        &#125;<br>        <span class="hljs-comment">// 锁被占用 或者 处于饥饿状态下，新增一个等待者</span><br>        <span class="hljs-keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-built_in">new</span> += <span class="hljs-number">1</span> &lt;&lt; mutexWaiterShift<br>        &#125;<br>        <br>        <span class="hljs-comment">// 当前goroutine已经进行饥饿状态了，且锁还没释放，需要把Mutex的状态改为饥饿</span><br>        <span class="hljs-keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-built_in">new</span> |= mutexStarving<br>        &#125;<br>        <span class="hljs-comment">// 如果是被唤醒的，把唤醒标志置0，表示外面没有被唤醒的goroutine了</span><br>        <span class="hljs-comment">// 这段的操作是为了下面的抢锁做准备，抢到就获取锁，抢不到就休眠，把唤醒标志设置为0</span><br>        <span class="hljs-keyword">if</span> awoke &#123;<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">new</span>&amp;mutexWoken == <span class="hljs-number">0</span> &#123;<br>                throw(<span class="hljs-string">&quot;sync: inconsistent mutex state&quot;</span>)<br>            &#125;<br>            <span class="hljs-built_in">new</span> &amp;^= mutexWoken<br>        &#125;<br>        <span class="hljs-comment">// 利用CAS尝试将锁的状态切切换成新的，就是上面的一坨操作</span><br>        <span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="hljs-built_in">new</span>) &#123;<br>            <span class="hljs-comment">// 状态切换成功，且在改状态前 锁未被占用 且 处于正常模式，那么就相当于获取到锁了</span><br>            <span class="hljs-keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="hljs-number">0</span> &#123;<br>                <span class="hljs-keyword">break</span> <span class="hljs-comment">// locked the mutex with CAS</span><br>            &#125;<br>            <br>            <span class="hljs-comment">// 走到这里说明锁没正常获取到</span><br>            <span class="hljs-comment">// 判断之前是否等待过，之前等待过的，再次排队要放在队首</span><br>            queueLifo := waitStartTime != <span class="hljs-number">0</span><br>            <span class="hljs-keyword">if</span> waitStartTime == <span class="hljs-number">0</span> &#123;<br>                waitStartTime = runtime_nanotime()<br>            &#125;<br>            <span class="hljs-comment">// 休眠等待信号量：之前排过队的老人，放到等待队列队首；新人放到队尾</span><br>            runtime_SemacquireMutex(&amp;m.sema, queueLifo, <span class="hljs-number">1</span>)<br>            <br>            <span class="hljs-comment">// 走到这里说明锁被释放，当前协程获取到信号量被唤醒</span><br>            <span class="hljs-comment">// 重新计算当前goroutine的饥饿状态</span><br>            starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs<br>            old = m.state<br>            <br>            <span class="hljs-comment">// 如果 state 饥饿标记为1，说明当前在饥饿模式，饥饿模式下被唤醒，已经获取到锁了；</span><br>            <span class="hljs-comment">// 饥饿状态下，释放锁没有更新等待者数量和饥饿标记，需要获得锁的goroutine去更新状态</span><br>            <span class="hljs-keyword">if</span> old&amp;mutexStarving != <span class="hljs-number">0</span> &#123;<br>                <span class="hljs-keyword">if</span> old&amp;(mutexLocked|mutexWoken) != <span class="hljs-number">0</span> || old&gt;&gt;mutexWaiterShift == <span class="hljs-number">0</span> &#123;<br>                    throw(<span class="hljs-string">&quot;sync: inconsistent mutex state&quot;</span>)<br>                &#125;<br>                <span class="hljs-comment">// 加锁，减去一个等待者</span><br>                delta := <span class="hljs-type">int32</span>(mutexLocked - <span class="hljs-number">1</span>&lt;&lt;mutexWaiterShift)<br>                <span class="hljs-keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="hljs-number">1</span> &#123;<br>                    <span class="hljs-comment">// 如果当前的 goroutine 非饥饿，或者等待者只有一个（也就是只有当前goroutine，等待队列空了），</span><br>                    <span class="hljs-comment">// 可以取消饥饿状态，进入正常状态</span><br>                    delta -= mutexStarving<br>                &#125;<br>                atomic.AddInt32(&amp;m.state, delta)<br>                <span class="hljs-keyword">break</span><br>            &#125;<br>            <span class="hljs-comment">// 非饥饿状态被唤醒，标记为awoke，重置自旋迭代次数，继续去进行下一轮的抢锁</span><br>            awoke = <span class="hljs-literal">true</span><br>            iter = <span class="hljs-number">0</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            old = m.state<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> race.Enabled &#123;<br>        race.Acquire(unsafe.Pointer(m))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
Mutex本身是多个go协程的共享变量，不同的go协程同时执行该函数，函数内临时变量是go协程自己的状态。每次执行因为状态不同处在函数执行的不同阶段，直到mutex状态改变。</li>
</ol>
<h3 id="5-2-UnLock"><a href="#5-2-UnLock" class="headerlink" title="5.2 UnLock"></a>5.2 UnLock</h3><p>Unlock()解锁方法也分为两部分：</p>
<ol>
<li>第一部分是 fast path，可以理解为快捷通道，直接把锁状态位清除，如果此时系统状态恢复到初始状态，说明没有 goroutine 在抢锁等锁，直接返回，否则进入 slow path；</li>
<li>slow path 会根据是否为饥饿状态，做出不一样的反应：<ol>
<li>正常状态：唤醒一个 goroutine 去抢锁，等待者数量减一，并将唤醒状态置为 1；</li>
<li>饥饿状态：直接唤醒等待队列队首的 goroutine，锁的所有权直接移交（修改等待者数量、是否取消饥饿标记，由唤醒的 goroutine 去处理）。</li>
</ol>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> unlockSlow(<span class="hljs-built_in">new</span> <span class="hljs-type">int32</span>) &#123;<br>    <span class="hljs-comment">// 校验是否对已解锁的mutex再次解锁</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="hljs-number">0</span> &#123;<br>        fatal(<span class="hljs-string">&quot;sync: unlock of unlocked mutex&quot;</span>)<br>    &#125;<br>    <br>    <span class="hljs-comment">// 正常模式，非饥饿</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">new</span>&amp;mutexStarving == <span class="hljs-number">0</span> &#123;<br>        old := <span class="hljs-built_in">new</span><br>        <span class="hljs-keyword">for</span> &#123;<br>            <span class="hljs-comment">// 如果没有等待者，或者已经存在被唤醒的协程，或者已经有协程获得了锁，无需唤醒协程，直接交接返回即可</span><br>            <span class="hljs-keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="hljs-number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="hljs-number">0</span> &#123;<br>                <span class="hljs-keyword">return</span><br>            &#125;<br>            <span class="hljs-comment">// 减去一个等待者，并且将 唤醒标记 置为 1</span><br>            <span class="hljs-built_in">new</span> = (old - <span class="hljs-number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken<br>            <span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="hljs-built_in">new</span>) &#123;<br>                runtime_Semrelease(&amp;m.sema, <span class="hljs-literal">false</span>, <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span><br>            &#125;<br>            old = m.state<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 饥饿模式下，直接释放信号量，将锁的所有权，交给等待队列的第一个等待者</span><br>        runtime_Semrelease(&amp;m.sema, <span class="hljs-literal">true</span>, <span class="hljs-number">1</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="6-参考资料"><a href="#6-参考资料" class="headerlink" title="6. 参考资料"></a>6. 参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7146236976399089700">初见 Go Mutex</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7086756462059323429">Golang Mutex 原理解析</a></li>
<li><a target="_blank" rel="noopener" href="https://www.lixueduan.com/posts/go/sync-mutex/">Go语言之sync.Mutex 源码分析</a></li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Golang/" class="category-chain-item">Golang</a>
  
  
    <span>></span>
    
  <a href="/categories/Golang/%E4%BA%92%E6%96%A5%E9%94%81%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/" class="category-chain-item">互斥锁与原子操作</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Golang/" class="print-no-link">#Golang</a>
      
        <a href="/tags/Mutex/" class="print-no-link">#Mutex</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Golang 互斥锁 sync.Mutex</div>
      <div>https://wujiyang.github.io/2024/11/08/Golang-Mutex解析/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>wujiyang</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年11月8日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/11/23/Goalng%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C-Atomic/" title="Golang原子操作-Atomic">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Golang原子操作-Atomic</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/09/21/golang%E5%B9%B6%E5%8F%91%E8%B5%8B%E5%80%BC%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/" title="Golang并发赋值的安全性分析">
                        <span class="hidden-mobile">Golang并发赋值的安全性分析</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
