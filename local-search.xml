<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MySQL 深分页问题</title>
    <link href="/2025/02/16/MySQL%E6%B7%B1%E5%88%86%E9%A1%B5/"/>
    <url>/2025/02/16/MySQL%E6%B7%B1%E5%88%86%E9%A1%B5/</url>
    
    <content type="html"><![CDATA[<blockquote><p>分页是一个很普通的功能，基本有数据展示的地方就会有分页，那为什么要分页呢？分页可能会存在哪些问题呢？</p></blockquote><span id="more"></span>  <h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>分页是一个很普通的功能，基本有数据展示的地方就会有分页，那为什么要分页呢？</p><ul><li>从业务上来讲，即使系统返回所有数据，用户绝大多数情况下是不会看后面的数据的。</li><li>技术上，因为要考虑取数据的成本，目标服务器磁盘、内存、网络带宽，以及请求发起方自身是否能承受大批量数据。<br>日常做分页需求时，一般会用limit实现，但是当偏移量特别大的时候，查询效率就变得低下。本文将介绍一下百万级数据构建和查询分析的深分页问题，同时讨论一些优化方案来解决MySQL的深分页问题。</li></ul><h2 id="2-数据构造"><a href="#2-数据构造" class="headerlink" title="2. 数据构造"></a>2. 数据构造</h2><h3 id="2-1-MySQL搭建"><a href="#2-1-MySQL搭建" class="headerlink" title="2.1 MySQL搭建"></a>2.1 MySQL搭建</h3><ul><li>Docker镜像拉取、启动MySQL容器、连接到MySQL登录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull mysql<br><span class="hljs-comment"># --name指定容器名称，-p指定端口映射 -e 设置环境变量</span><br>docker run --name mysql -p 3307:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql<br><span class="hljs-comment"># 输入密码即可登录到常规的数据库环境中</span><br>docker <span class="hljs-built_in">exec</span> -it mysql mysql -u root -p<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-2-数据插入"><a href="#2-2-数据插入" class="headerlink" title="2.2 数据插入"></a>2.2 数据插入</h3><ul><li><p>创建数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> database demo;<br>use demo<br></code></pre></td></tr></table></figure></li><li><p>创建数据表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> account (  <br>    id <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;主键Id&#x27;</span>,  <br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;账户名&#x27;</span>,  <br>    balance <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;余额&#x27;</span>,  <br>    create_time datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;创建时间&#x27;</span>,  <br>    update_time datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;更新时间&#x27;</span>,  <br>    <span class="hljs-keyword">PRIMARY</span> KEY (id),  <br>    KEY idx_name (name),  <br>    KEY idx_update_time (update_time)<br> ) ENGINE<span class="hljs-operator">=</span>InnoDB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">1570068</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 ROW_FORMAT<span class="hljs-operator">=</span>REDUNDANT COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;账户表&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>插入数据</p><ul><li>首先初始化插入一条数据，后面自动生成的数据会以这条数据为基础进行生成  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> account <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>, &quot;name_1&quot;, <span class="hljs-number">1000</span>, &quot;2025-02-08 00:00:00&quot;, &quot;2025-02-08 00:01:00&quot;)<br><span class="hljs-keyword">set</span> <span class="hljs-variable">@i</span><span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure></li><li>重复拷贝一下逻辑执行十多次，即可生成符合预期的数据量级；  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> account(name, balance, create_time, update_time) <span class="hljs-keyword">select</span><br>    concat(<span class="hljs-string">&#x27;user_&#x27;</span>,<span class="hljs-variable">@i</span>:<span class="hljs-operator">=</span><span class="hljs-variable">@i</span><span class="hljs-operator">+</span><span class="hljs-number">1</span>),           <br>    <span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">20</span><span class="hljs-operator">+</span>RAND() <span class="hljs-operator">*</span>(<span class="hljs-number">5000000</span> <span class="hljs-operator">-</span> <span class="hljs-number">20</span> <span class="hljs-operator">+</span> <span class="hljs-number">1</span>)) <span class="hljs-keyword">as</span> balance,  <br>    date_add(create_time,<span class="hljs-type">interval</span> <span class="hljs-operator">+</span><span class="hljs-variable">@i</span><span class="hljs-operator">*</span><span class="hljs-built_in">cast</span>(rand()<span class="hljs-operator">*</span><span class="hljs-number">1000</span> <span class="hljs-keyword">as</span> signed) <span class="hljs-keyword">SECOND</span>), <br>    date_add(date_add(create_time,<span class="hljs-type">interval</span> <span class="hljs-operator">+</span><span class="hljs-variable">@i</span><span class="hljs-operator">*</span><span class="hljs-built_in">cast</span>(rand()<span class="hljs-operator">*</span><span class="hljs-number">100</span> <span class="hljs-keyword">as</span> signed) <span class="hljs-keyword">SECOND</span>), <span class="hljs-type">interval</span> <span class="hljs-operator">+</span> <span class="hljs-built_in">cast</span>(rand()<span class="hljs-operator">*</span><span class="hljs-number">1000000</span> <span class="hljs-keyword">as</span> signed) <span class="hljs-keyword">SECOND</span>) #生成有时间大顺序的随机的更新时间<br><span class="hljs-keyword">from</span> account;<br><br>方案参考：https:<span class="hljs-operator">/</span><span class="hljs-operator">/</span>blog.csdn.net<span class="hljs-operator">/</span>mysqltop<span class="hljs-operator">/</span>article<span class="hljs-operator">/</span>details<span class="hljs-operator">/</span><span class="hljs-number">105230327</span><br></code></pre></td></tr></table></figure>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> account;<br><span class="hljs-operator">+</span><span class="hljs-comment">----------+</span><br><span class="hljs-operator">|</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">4194304</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.50</span> sec)<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 已经生成<span class="hljs-number">419</span>w条数据<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="3-查询场景分析"><a href="#3-查询场景分析" class="headerlink" title="3. 查询场景分析"></a>3. 查询场景分析</h2><p>针对以上构建的数据表，进行一些数据查询的场景进行分析。</p><h3 id="3-1-没有查询条件，是否有排序"><a href="#3-1-没有查询条件，是否有排序" class="headerlink" title="3.1 没有查询条件，是否有排序"></a>3.1 没有查询条件，是否有排序</h3><p>查询200W条以后得数据，耗时分别如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> id, name, balance <span class="hljs-keyword">from</span> account limit <span class="hljs-number">2000000</span>, <span class="hljs-number">10</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">---------+--------------+---------+</span><br><span class="hljs-operator">|</span> id      <span class="hljs-operator">|</span> name         <span class="hljs-operator">|</span> balance <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------+--------------+---------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">3897711</span> <span class="hljs-operator">|</span> user_1999998 <span class="hljs-operator">|</span> <span class="hljs-number">3565249</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">3897712</span> <span class="hljs-operator">|</span> user_1999999 <span class="hljs-operator">|</span> <span class="hljs-number">3063459</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">3897713</span> <span class="hljs-operator">|</span> user_2000000 <span class="hljs-operator">|</span> <span class="hljs-number">1978909</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">3897714</span> <span class="hljs-operator">|</span> user_2000001 <span class="hljs-operator">|</span>  <span class="hljs-number">622278</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">3897715</span> <span class="hljs-operator">|</span> user_2000002 <span class="hljs-operator">|</span> <span class="hljs-number">3144910</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">3897716</span> <span class="hljs-operator">|</span> user_2000003 <span class="hljs-operator">|</span> <span class="hljs-number">3298460</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">3897717</span> <span class="hljs-operator">|</span> user_2000004 <span class="hljs-operator">|</span> <span class="hljs-number">1632420</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">3897718</span> <span class="hljs-operator">|</span> user_2000005 <span class="hljs-operator">|</span> <span class="hljs-number">2740997</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">3897719</span> <span class="hljs-operator">|</span> user_2000006 <span class="hljs-operator">|</span> <span class="hljs-number">2933984</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">3897720</span> <span class="hljs-operator">|</span> user_2000007 <span class="hljs-operator">|</span> <span class="hljs-number">4333621</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------+--------------+---------+</span><br><span class="hljs-number">10</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.37</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> id, name, balance <span class="hljs-keyword">from</span> account <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">2000000</span>, <span class="hljs-number">10</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">---------+--------------+---------+</span><br><span class="hljs-operator">|</span> id      <span class="hljs-operator">|</span> name         <span class="hljs-operator">|</span> balance <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------+--------------+---------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">3897711</span> <span class="hljs-operator">|</span> user_1999998 <span class="hljs-operator">|</span> <span class="hljs-number">3565249</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">3897712</span> <span class="hljs-operator">|</span> user_1999999 <span class="hljs-operator">|</span> <span class="hljs-number">3063459</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">3897713</span> <span class="hljs-operator">|</span> user_2000000 <span class="hljs-operator">|</span> <span class="hljs-number">1978909</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">3897714</span> <span class="hljs-operator">|</span> user_2000001 <span class="hljs-operator">|</span>  <span class="hljs-number">622278</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">3897715</span> <span class="hljs-operator">|</span> user_2000002 <span class="hljs-operator">|</span> <span class="hljs-number">3144910</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">3897716</span> <span class="hljs-operator">|</span> user_2000003 <span class="hljs-operator">|</span> <span class="hljs-number">3298460</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">3897717</span> <span class="hljs-operator">|</span> user_2000004 <span class="hljs-operator">|</span> <span class="hljs-number">1632420</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">3897718</span> <span class="hljs-operator">|</span> user_2000005 <span class="hljs-operator">|</span> <span class="hljs-number">2740997</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">3897719</span> <span class="hljs-operator">|</span> user_2000006 <span class="hljs-operator">|</span> <span class="hljs-number">2933984</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">3897720</span> <span class="hljs-operator">|</span> user_2000007 <span class="hljs-operator">|</span> <span class="hljs-number">4333621</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------+--------------+---------+</span><br><span class="hljs-number">10</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.25</span> sec)<br></code></pre></td></tr></table></figure><p>可以看到，带上id排序进行检索时，耗时略少一些，可以通过执行计划发现：一个走了全表扫描，一个走了索引扫描。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> id, name, balance <span class="hljs-keyword">from</span> account limit <span class="hljs-number">2000000</span>, <span class="hljs-number">10</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+---------+------------+------+---------------+------+---------+------+---------+----------+-------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span>   <span class="hljs-operator">|</span> partitions <span class="hljs-operator">|</span> type <span class="hljs-operator">|</span> possible_keys <span class="hljs-operator">|</span> key  <span class="hljs-operator">|</span> key_len <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>  <span class="hljs-operator">|</span> <span class="hljs-keyword">rows</span>    <span class="hljs-operator">|</span> filtered <span class="hljs-operator">|</span> Extra <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+---------+------------+------+---------------+------+---------+------+---------+----------+-------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> account <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>       <span class="hljs-operator">|</span> <span class="hljs-keyword">ALL</span>  <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>          <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>    <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-number">4184857</span> <span class="hljs-operator">|</span>   <span class="hljs-number">100.00</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>  <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+---------+------------+------+---------------+------+---------+------+---------+----------+-------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> id, name, balance <span class="hljs-keyword">from</span> account <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">2000000</span>, <span class="hljs-number">10</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+---------+------------+-------+---------------+---------+---------+------+---------+----------+-------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span>   <span class="hljs-operator">|</span> partitions <span class="hljs-operator">|</span> type  <span class="hljs-operator">|</span> possible_keys <span class="hljs-operator">|</span> key     <span class="hljs-operator">|</span> key_len <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>  <span class="hljs-operator">|</span> <span class="hljs-keyword">rows</span>    <span class="hljs-operator">|</span> filtered <span class="hljs-operator">|</span> Extra <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+---------+------------+-------+---------------+---------+---------+------+---------+----------+-------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> account <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>       <span class="hljs-operator">|</span> index <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>          <span class="hljs-operator">|</span> <span class="hljs-keyword">PRIMARY</span> <span class="hljs-operator">|</span> <span class="hljs-number">4</span>       <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-number">2000010</span> <span class="hljs-operator">|</span>   <span class="hljs-number">100.00</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>  <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+---------+------------+-------+---------------+---------+---------+------+---------+----------+-------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><p><strong>结论：即使业务看起来没有任何查询条件且不需要排序，一般也可以加上主键排序，方便走索引检索</strong></p><h3 id="3-2-查询有排序，但排序字段有无索引"><a href="#3-2-查询有排序，但排序字段有无索引" class="headerlink" title="3.2 查询有排序，但排序字段有无索引"></a>3.2 查询有排序，但排序字段有无索引</h3><p>由于表中update_time有索引，create_time无索引，所以分别用这两个字段做测试（理论上应该使用同样的数据和字段，分别建立一个有索引和无索引的表进行测试，这里偷懒一下）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> id, name, balance <span class="hljs-keyword">from</span> account <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> update_time <span class="hljs-keyword">desc</span> limit <span class="hljs-number">10000</span>, <span class="hljs-number">10</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">---------+--------------+---------+</span><br><span class="hljs-operator">|</span> id      <span class="hljs-operator">|</span> name         <span class="hljs-operator">|</span> balance <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------+--------------+---------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">6118096</span> <span class="hljs-operator">|</span> user_4154864 <span class="hljs-operator">|</span> <span class="hljs-number">1558264</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">6064556</span> <span class="hljs-operator">|</span> user_4101324 <span class="hljs-operator">|</span> <span class="hljs-number">2858272</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">6018951</span> <span class="hljs-operator">|</span> user_4055719 <span class="hljs-operator">|</span> <span class="hljs-number">4890846</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">5989855</span> <span class="hljs-operator">|</span> user_4026623 <span class="hljs-operator">|</span>  <span class="hljs-number">947321</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">6124844</span> <span class="hljs-operator">|</span> user_4161612 <span class="hljs-operator">|</span> <span class="hljs-number">4356195</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">6015649</span> <span class="hljs-operator">|</span> user_4052417 <span class="hljs-operator">|</span> <span class="hljs-number">3902340</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">6002851</span> <span class="hljs-operator">|</span> user_4039619 <span class="hljs-operator">|</span> <span class="hljs-number">4286561</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">6086813</span> <span class="hljs-operator">|</span> user_4123581 <span class="hljs-operator">|</span>  <span class="hljs-number">173212</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">5932870</span> <span class="hljs-operator">|</span> user_3969638 <span class="hljs-operator">|</span> <span class="hljs-number">2756974</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">6065088</span> <span class="hljs-operator">|</span> user_4101856 <span class="hljs-operator">|</span> <span class="hljs-number">2274823</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------+--------------+---------+</span><br><span class="hljs-number">10</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.04</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> id, name, balance <span class="hljs-keyword">from</span> account <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> create_time <span class="hljs-keyword">desc</span> limit <span class="hljs-number">10000</span>, <span class="hljs-number">10</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">---------+--------------+---------+</span><br><span class="hljs-operator">|</span> id      <span class="hljs-operator">|</span> name         <span class="hljs-operator">|</span> balance <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------+--------------+---------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">5990523</span> <span class="hljs-operator">|</span> user_4027291 <span class="hljs-operator">|</span> <span class="hljs-number">3324558</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">6080659</span> <span class="hljs-operator">|</span> user_4117427 <span class="hljs-operator">|</span> <span class="hljs-number">3808889</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">5889120</span> <span class="hljs-operator">|</span> user_3925888 <span class="hljs-operator">|</span>  <span class="hljs-number">751634</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">6131558</span> <span class="hljs-operator">|</span> user_4168326 <span class="hljs-operator">|</span> <span class="hljs-number">3903289</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">6006085</span> <span class="hljs-operator">|</span> user_4042853 <span class="hljs-operator">|</span> <span class="hljs-number">2574610</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">5915585</span> <span class="hljs-operator">|</span> user_3952353 <span class="hljs-operator">|</span> <span class="hljs-number">2687494</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">5820701</span> <span class="hljs-operator">|</span> user_3857469 <span class="hljs-operator">|</span> <span class="hljs-number">2927750</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">6048517</span> <span class="hljs-operator">|</span> user_4085285 <span class="hljs-operator">|</span> <span class="hljs-number">2268068</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">6139663</span> <span class="hljs-operator">|</span> user_4176431 <span class="hljs-operator">|</span> <span class="hljs-number">4055927</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">6123279</span> <span class="hljs-operator">|</span> user_4160047 <span class="hljs-operator">|</span> <span class="hljs-number">2835164</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------+--------------+---------+</span><br><span class="hljs-number">10</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">1.21</span> sec)<br></code></pre></td></tr></table></figure><p>可以看到，使用索引字段进行排序时，耗时略少一些，可以通过执行计划发现：一个走了全表扫描，一个走了索引扫描。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> id, name, balance <span class="hljs-keyword">from</span> account <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> create_time <span class="hljs-keyword">desc</span> limit <span class="hljs-number">10000</span>, <span class="hljs-number">10</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+---------+------------+------+---------------+------+---------+------+---------+----------+----------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span>   <span class="hljs-operator">|</span> partitions <span class="hljs-operator">|</span> type <span class="hljs-operator">|</span> possible_keys <span class="hljs-operator">|</span> key  <span class="hljs-operator">|</span> key_len <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>  <span class="hljs-operator">|</span> <span class="hljs-keyword">rows</span>    <span class="hljs-operator">|</span> filtered <span class="hljs-operator">|</span> Extra          <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+---------+------------+------+---------------+------+---------+------+---------+----------+----------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> account <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>       <span class="hljs-operator">|</span> <span class="hljs-keyword">ALL</span>  <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>          <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>    <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-number">4184857</span> <span class="hljs-operator">|</span>   <span class="hljs-number">100.00</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">Using</span> filesort <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+---------+------------+------+---------------+------+---------+------+---------+----------+----------------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> id, name, balance <span class="hljs-keyword">from</span> account <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> update_time <span class="hljs-keyword">desc</span> limit <span class="hljs-number">10000</span>, <span class="hljs-number">10</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+---------+------------+-------+---------------+-----------------+---------+------+-------+----------+---------------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span>   <span class="hljs-operator">|</span> partitions <span class="hljs-operator">|</span> type  <span class="hljs-operator">|</span> possible_keys <span class="hljs-operator">|</span> key             <span class="hljs-operator">|</span> key_len <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>  <span class="hljs-operator">|</span> <span class="hljs-keyword">rows</span>  <span class="hljs-operator">|</span> filtered <span class="hljs-operator">|</span> Extra               <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+---------+------------+-------+---------------+-----------------+---------+------+-------+----------+---------------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> account <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>       <span class="hljs-operator">|</span> index <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>          <span class="hljs-operator">|</span> idx_update_time <span class="hljs-operator">|</span> <span class="hljs-number">5</span>       <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-number">10010</span> <span class="hljs-operator">|</span>   <span class="hljs-number">100.00</span> <span class="hljs-operator">|</span> Backward index scan <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+---------+------------+-------+---------------+-----------------+---------+------+-------+----------+---------------------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><p><strong>结论：给常用字段加索引，包括排序字段。</strong></p><h3 id="3-3-排序字段有索引，但是深分页"><a href="#3-3-排序字段有索引，但是深分页" class="headerlink" title="3.3 排序字段有索引，但是深分页"></a>3.3 排序字段有索引，但是深分页</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> id, name, balance <span class="hljs-keyword">from</span> account <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> update_time <span class="hljs-keyword">desc</span> limit <span class="hljs-number">100000</span>, <span class="hljs-number">10</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+---------+------------+------+---------------+------+---------+------+---------+----------+----------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span>   <span class="hljs-operator">|</span> partitions <span class="hljs-operator">|</span> type <span class="hljs-operator">|</span> possible_keys <span class="hljs-operator">|</span> key  <span class="hljs-operator">|</span> key_len <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>  <span class="hljs-operator">|</span> <span class="hljs-keyword">rows</span>    <span class="hljs-operator">|</span> filtered <span class="hljs-operator">|</span> Extra          <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+---------+------------+------+---------------+------+---------+------+---------+----------+----------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> account <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>       <span class="hljs-operator">|</span> <span class="hljs-keyword">ALL</span>  <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>          <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>    <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-number">4184857</span> <span class="hljs-operator">|</span>   <span class="hljs-number">100.00</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">Using</span> filesort <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+---------+------------+------+---------------+------+---------+------+---------+----------+----------------+</span><br></code></pre></td></tr></table></figure><p>当选择深分页时，即使有索引，执行计划也走的是全表扫描。因为mysql在处理时会自动优化分析，当sql查询条数超过一定比例时就会直接选择全表扫描读取。</p><h3 id="3-4-带有查询条件，深分页耗时明显"><a href="#3-4-带有查询条件，深分页耗时明显" class="headerlink" title="3.4 带有查询条件，深分页耗时明显"></a>3.4 带有查询条件，深分页耗时明显</h3><p>当把sql查询语句中增加where查询条件时，发现深分页耗时明显增加</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> id, name, balance <span class="hljs-keyword">from</span> account <span class="hljs-keyword">where</span> update_time <span class="hljs-operator">&gt;</span> &quot;2028-01-01&quot; <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> update_time limit <span class="hljs-number">10000</span>, <span class="hljs-number">10</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">---------+-------------+---------+</span><br><span class="hljs-operator">|</span> id      <span class="hljs-operator">|</span> name        <span class="hljs-operator">|</span> balance <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------+-------------+---------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">2116762</span> <span class="hljs-operator">|</span> user_350107 <span class="hljs-operator">|</span> <span class="hljs-number">1399540</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------+-------------+---------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.05</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> id, name, balance <span class="hljs-keyword">from</span> account <span class="hljs-keyword">where</span> update_time <span class="hljs-operator">&gt;</span> &quot;2028-01-01&quot; <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> update_time limit <span class="hljs-number">100000</span>, <span class="hljs-number">10</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">---------+-------------+---------+</span><br><span class="hljs-operator">|</span> id      <span class="hljs-operator">|</span> name        <span class="hljs-operator">|</span> balance <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------+-------------+---------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">2720074</span> <span class="hljs-operator">|</span> user_887888 <span class="hljs-operator">|</span>  <span class="hljs-number">341752</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------+-------------+---------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.23</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> id, name, balance <span class="hljs-keyword">from</span> account <span class="hljs-keyword">where</span> update_time <span class="hljs-operator">&gt;</span> &quot;2028-01-01&quot; <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> update_time limit <span class="hljs-number">1000000</span>, <span class="hljs-number">10</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">---------+--------------+---------+</span><br><span class="hljs-operator">|</span> id      <span class="hljs-operator">|</span> name         <span class="hljs-operator">|</span> balance <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------+--------------+---------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">2871404</span> <span class="hljs-operator">|</span> user_1039218 <span class="hljs-operator">|</span> <span class="hljs-number">2366353</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------+--------------+---------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">2.99</span> sec)<br></code></pre></td></tr></table></figure><h3 id="3-5-深分页为什么变慢？"><a href="#3-5-深分页为什么变慢？" class="headerlink" title="3.5 深分页为什么变慢？"></a>3.5 深分页为什么变慢？</h3><p>我们考虑如上的查询条件，分析执行计划如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> id, name, balance <span class="hljs-keyword">from</span> account <span class="hljs-keyword">where</span> update_time <span class="hljs-operator">&gt;</span> &quot;2028-01-01&quot; <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> update_time limit <span class="hljs-number">1000000</span>, <span class="hljs-number">10</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+---------+------------+------+-----------------+------+---------+------+---------+----------+-----------------------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span>   <span class="hljs-operator">|</span> partitions <span class="hljs-operator">|</span> type <span class="hljs-operator">|</span> possible_keys   <span class="hljs-operator">|</span> key  <span class="hljs-operator">|</span> key_len <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>  <span class="hljs-operator">|</span> <span class="hljs-keyword">rows</span>    <span class="hljs-operator">|</span> filtered <span class="hljs-operator">|</span> Extra                       <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+---------+------------+------+-----------------+------+---------+------+---------+----------+-----------------------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> account <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>       <span class="hljs-operator">|</span> <span class="hljs-keyword">ALL</span>  <span class="hljs-operator">|</span> idx_update_time <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>    <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-number">4184857</span> <span class="hljs-operator">|</span>    <span class="hljs-number">50.00</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">Using</span> <span class="hljs-keyword">where</span>; <span class="hljs-keyword">Using</span> filesort <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+---------+------------+------+-----------------+------+---------+------+---------+----------+-----------------------------+</span><br></code></pre></td></tr></table></figure><p>这个SQL的执行流程：</p><ol><li>通过普通二级索引树idx_update_time，过滤update_time条件，找到满足条件的记录ID。</li><li>通过ID，回到主键索引树，找到满足记录的行，然后取出展示的列（回表）</li><li>扫描满足条件的100010行，然后扔掉前100000行，返回。<br><img src="/img/MySQL%E6%B7%B1%E5%88%86%E9%A1%B5/1.png"><br>所以SQL变慢的原因主要有两个：</li><li>limit语句会先扫描offset+n行，然后再丢弃掉前offset行，返回后n行数据。也就是说limit 100000,10，就会扫描100010行，而limit 0,10，只扫描10行。</li><li>limit 100000,10 扫描更多的行数，也意味着回表更多的次数。</li></ol><h2 id="4-优化方案"><a href="#4-优化方案" class="headerlink" title="4. 优化方案"></a>4. 优化方案</h2><p>以上的SQL，回表了100010次，实际上，我们只需要10条数据，也就是我们只需要10次回表其实就够了。因此，我们可以通过减少回表次数来优化。<br>那么，如何减少回表次数呢？我们先来复习下B+树索引结构哈~<br>InnoDB中，索引分主键索引（聚簇索引）和二级索引</p><ul><li>主键索引，叶子节点存放的是整行数据</li><li>二级索引，叶子节点存放的是主键的值。<br><img src="/img/MySQL%E6%B7%B1%E5%88%86%E9%A1%B5/2.png"><br>如果我们能把查询条件，转移回到主键索引树，那就可以减少回表次数了。转移到主键索引树查询的话，查询条件得改为主键id了，所以优化思路需要往这个方面靠近。</li></ul><h3 id="4-1-子查询优化"><a href="#4-1-子查询优化" class="headerlink" title="4.1 子查询优化"></a>4.1 子查询优化</h3><p>原始查询SQL中的查询条件是update_time这个如何转换成些主键id呢？抽到子查询即可。<br>因为二级索引叶子节点是有主键ID的，所以我们直接根据update_time来查主键ID即可，同时我们把 limit 100000的条件，也转移到子查询中，具体SQL语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id,name,balance <span class="hljs-keyword">FROM</span> account <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">select</span> a.id <span class="hljs-keyword">from</span> account a <span class="hljs-keyword">where</span> a.update_time <span class="hljs-operator">&gt;=</span> <span class="hljs-string">&#x27;2028-01-01&#x27;</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> update_time limit <span class="hljs-number">100000</span>, <span class="hljs-number">1</span>) LIMIT <span class="hljs-number">10</span><br>;<br></code></pre></td></tr></table></figure><p>思想是对的，但是结果是错的，因为id的顺序和update_time的顺序没有关系，应该使用id in xxx才行<br>但是用id in xxx的时候，部分mysql版本的子查询不能有limit，需要升级mysql</p><h3 id="4-2-延迟关联-INNER-JOIN"><a href="#4-2-延迟关联-INNER-JOIN" class="headerlink" title="4.2 延迟关联 INNER JOIN"></a>4.2 延迟关联 INNER JOIN</h3><p>延迟关联的优化思路，跟子查询的优化思路其实是一样的：都是把条件转移到主键索引树，然后减少回表。不同点是，延迟关联使用了inner join代替子查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>  ac1.id, ac1.name, ac1.balance <span class="hljs-keyword">FROM</span> account ac1 <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> (<span class="hljs-keyword">SELECT</span> a.id <span class="hljs-keyword">FROM</span> account a <span class="hljs-keyword">WHERE</span> a.update_time <span class="hljs-operator">&gt;=</span> <span class="hljs-string">&#x27;2028-01-01&#x27;</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> a.update_time LIMIT <span class="hljs-number">1000000</span>, <span class="hljs-number">10</span>) <span class="hljs-keyword">AS</span>  ac2 <span class="hljs-keyword">on</span> ac1.id<span class="hljs-operator">=</span> ac2.id;<br></code></pre></td></tr></table></figure><p>通过执行SQL语句，可以发现耗时对比明显，且结果集一致</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> id, name, balance <span class="hljs-keyword">from</span> account <span class="hljs-keyword">where</span> update_time <span class="hljs-operator">&gt;</span> &quot;2028-01-01&quot; <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> update_time limit <span class="hljs-number">1000000</span>, <span class="hljs-number">1</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">---------+--------------+---------+</span><br><span class="hljs-operator">|</span> id      <span class="hljs-operator">|</span> name         <span class="hljs-operator">|</span> balance <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------+--------------+---------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">4666601</span> <span class="hljs-operator">|</span> user_2703369 <span class="hljs-operator">|</span>  <span class="hljs-number">518744</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------+--------------+---------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">1.57</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span>  ac1.id, ac1.name, ac1.balance <span class="hljs-keyword">FROM</span> account ac1 <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> (<span class="hljs-keyword">SELECT</span> a.id <span class="hljs-keyword">FROM</span> account a <span class="hljs-keyword">WHERE</span> a.update_time <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;2028-01-01&#x27;</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> a.update_time LIMIT <span class="hljs-number">1000000</span>, <span class="hljs-number">1</span>) <span class="hljs-keyword">AS</span>  ac2 <span class="hljs-keyword">on</span> ac1.id<span class="hljs-operator">=</span> ac2.id;<br><span class="hljs-operator">+</span><span class="hljs-comment">---------+--------------+---------+</span><br><span class="hljs-operator">|</span> id      <span class="hljs-operator">|</span> name         <span class="hljs-operator">|</span> balance <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------+--------------+---------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">4666601</span> <span class="hljs-operator">|</span> user_2703369 <span class="hljs-operator">|</span>  <span class="hljs-number">518744</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------+--------------+---------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.14</span> sec)<br></code></pre></td></tr></table></figure><h3 id="4-3-标签记录法"><a href="#4-3-标签记录法" class="headerlink" title="4.3 标签记录法"></a>4.3 标签记录法</h3><p>limit 深分页问题的本质原因就是：偏移量（offset）越大，mysql就会扫描越多的行，然后再抛弃掉。这样就导致查询性能的下降。<br>其实我们可以采用标签记录法，就是标记一下上次查询到哪一条了，下次再来查的时候，从该条开始往下扫描。就好像看书一样，上次看到哪里了，你就折叠一下或者夹个书签，下次来看的时候，直接就翻到啦。<br>假设上一次记录到100000，则SQL可以修改为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span>  id,name,balance <span class="hljs-keyword">FROM</span> account <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">100000</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>这样的话，后面无论翻多少页，性能都会不错的，因为命中了id索引。但是你，这种方式有局限性：需要一种类似连续自增的字段。</p><h3 id="4-4-使用-Between…and…"><a href="#4-4-使用-Between…and…" class="headerlink" title="4.4 使用 Between…and…"></a>4.4 使用 Between…and…</h3><p>很多时候，可以将limit查询转换为已知位置的查询，这样MySQL通过范围扫描between…and，就能获得到对应的结果。<br>如果知道边界值为100000，100010后，就可以这样优化：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span>  id,name,balance <span class="hljs-keyword">FROM</span> account <span class="hljs-keyword">where</span> id <span class="hljs-keyword">between</span> <span class="hljs-number">100000</span> <span class="hljs-keyword">and</span> <span class="hljs-number">100010</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id <span class="hljs-keyword">desc</span>;<br></code></pre></td></tr></table></figure><h2 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5. 参考资料"></a>5. 参考资料</h2><ul><li>实战！聊聊如何解决MySQL深分页问题 <a href="https://juejin.cn/post/7012016858379321358">https://juejin.cn/post/7012016858379321358</a></li><li>【得物技术】MySQL深分页优化 <a href="https://juejin.cn/post/6985478936683610149">https://juejin.cn/post/6985478936683610149</a></li></ul><h2 id="6-附录"><a href="#6-附录" class="headerlink" title="6. 附录"></a>6. 附录</h2><p>以下是 MySQL 中常见的 type 类型及其含义：</p><ol><li>system：这是最高级别的访问类型，表示 MySQL 只有一行数据，这行数据是从系统表中读取的。</li><li>const：这个类型表示 MySQL 在查询时使用了常量，通常是通过索引访问单个行时使用。</li><li>eq_ref：这个类型表示 MySQL 在查询时使用了唯一索引，通常是在连接操作中使用。</li><li>ref：这个类型表示 MySQL 在查询时使用了非唯一索引，通常是在连接操作中使用。</li><li>range：这个类型表示 MySQL 在查询时使用了索引范围查找，通常是在使用 BETWEEN、IN 或者 &lt;、&gt; 等操作符时使用。</li><li>index：这个类型表示 MySQL 在查询时使用了全索引扫描，通常是在查询结果集非常小的情况下使用。</li><li>all：这个类型表示 MySQL 在查询时进行了全表扫描，通常是在查询结果集非常大的情况下使用。</li></ol>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>深分页</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读扩散与写扩散</title>
    <link href="/2025/02/07/%E8%AF%BB%E6%89%A9%E6%95%A3%E4%B8%8E%E5%86%99%E6%89%A9%E6%95%A3/"/>
    <url>/2025/02/07/%E8%AF%BB%E6%89%A9%E6%95%A3%E4%B8%8E%E5%86%99%E6%89%A9%E6%95%A3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>📌 本文转载自：<a href="https://mp.weixin.qq.com/s/yyem2O90k49IgG89r7beaA">读扩散，写扩散，终于终于讲清楚了！</a></p></blockquote><span id="more"></span>  <h2 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1. 背景介绍"></a>1. 背景介绍</h2><p>feed是将用户主动订阅的若干消息源组合在一起形成内容聚合器，帮助用户持续地获取最新的订阅源内容。feed流即持续更新并呈现给用户内容的信息流。  </p><p>微博、微信朋友圈等场景，是典型的feed流业务，系统中的每一条消息都可以理解为一个feed</p><h2 id="2-Feed流特点"><a href="#2-Feed流特点" class="headerlink" title="2. Feed流特点"></a>2. Feed流特点</h2><ul><li>业务特点<ul><li>有好友关系，例如关注、粉丝</li><li>个人主页一般由关注用户发布的feed组成</li></ul></li><li>业务核心动作<ul><li>关注、取关</li><li>发布feed</li><li>拉取自己主页的feed流</li></ul></li><li>业务核心元数据<ul><li>关系数据</li><li>feed数据</li></ul></li><li>feed的推拉含义<ul><li>feed流业务的最大特点是”我们的主页由别人发布的feed组成“，获取朋友圈消息的feed流集合</li><li>从技术上来说，主要有：拉取（读扩散）、推送（写扩散）</li></ul></li></ul><h2 id="3-拉模式-读扩散"><a href="#3-拉模式-读扩散" class="headerlink" title="3. 拉模式-读扩散"></a>3. 拉模式-读扩散</h2><p>读扩散，又称数据拉取模式。例如某Feed系统有ABCD四个用户，其中：</p><ul><li><p>A关注了BC，D关注了B。其关系存储包含关注关系和粉丝关系，“A关注了BC，D关注了B”的潜台词是“B有两个粉丝AD、C有一个粉丝A”<br><img src="/img/%E8%AF%BB%E6%89%A9%E6%95%A3%E4%B8%8E%E5%86%99%E6%89%A9%E6%95%A3/1.png"></p></li><li><p>B发布过四条feed：msg1、msg3、msg5、msg10；C发布过两条feed：msg2、msg8；每一个用户都有一个feed队列，记录自己曾经发布的所有feed数据。<br><img src="/img/%E8%AF%BB%E6%89%A9%E6%95%A3%E4%B8%8E%E5%86%99%E6%89%A9%E6%95%A3/2.png"></p></li></ul><h3 id="3-1-读扩散如何实现feed发布"><a href="#3-1-读扩散如何实现feed发布" class="headerlink" title="3.1 读扩散如何实现feed发布"></a>3.1 读扩散如何实现feed发布</h3><p>在拉取模式中，发布一条feed的流程非常简单，例如用户C发布了一条msg12，此时只需往C的feed队列中加入一条feed即可。<br><img src="/img/%E8%AF%BB%E6%89%A9%E6%95%A3%E4%B8%8E%E5%86%99%E6%89%A9%E6%95%A3/3.png"> </p><h3 id="3-2-读扩散如何实现关注-取关"><a href="#3-2-读扩散如何实现关注-取关" class="headerlink" title="3.2 读扩散如何实现关注&#x2F;取关"></a>3.2 读扩散如何实现关注&#x2F;取关</h3><p>在拉取模式中，取消关注的流程也比较简单。比如A取消关注C：此时只需在A的关注列表中删除C，并且在C的粉丝列表中删除A即可。<br><img src="/img/%E8%AF%BB%E6%89%A9%E6%95%A3%E4%B8%8E%E5%86%99%E6%89%A9%E6%95%A3/4.png"> </p><h3 id="3-3-读扩散如何实现主页feed流"><a href="#3-3-读扩散如何实现主页feed流" class="headerlink" title="3.3 读扩散如何实现主页feed流"></a>3.3 读扩散如何实现主页feed流</h3><p>在拉取模式中，用户A获取“由别人发布的feed组成的主页”的过程比较复杂，此时需要：</p><ul><li>获取A的关注列表；</li><li>获取所关注列表中，所有用户发布的feed；</li><li>对消息进行rank排序（假设按照发布时间排序），分页去除对应一页的feeds；</li></ul><h3 id="3-4-读扩散优缺点"><a href="#3-4-读扩散优缺点" class="headerlink" title="3.4 读扩散优缺点"></a>3.4 读扩散优缺点</h3><ul><li>优点<ul><li>存储结构简单、数据存储量较小，关系数据和feed数据都只存储一份；</li><li>关注、取关、feed发布的业务流程都比较简单；</li><li>存储结构、业务流程都比较容易理解，适合项目早期用户量、数据量、并发量不大时的快速实现。</li></ul></li><li>缺点<ul><li>拉取朋友圈feed流列表的业务流程非常复杂</li><li>有多次数据访问，并且要进行大量的内存计算和网络传输，性能较低</li></ul></li></ul><h2 id="4-推模式-写扩散"><a href="#4-推模式-写扩散" class="headerlink" title="4. 推模式-写扩散"></a>4. 推模式-写扩散</h2><p>写扩散，又称数据提送模式。</p><ul><li><p>关系存储和读扩散一样，既有关注关系，也有粉丝关系<br><img src="/img/%E8%AF%BB%E6%89%A9%E6%95%A3%E4%B8%8E%E5%86%99%E6%89%A9%E6%95%A3/5.png">  </p></li><li><p>feed数据也是每个用户都存储自己发布的feed数据，比如B发布了1、3、5、10，C发布了2、8<br><img src="/img/%E8%AF%BB%E6%89%A9%E6%95%A3%E4%B8%8E%E5%86%99%E6%89%A9%E6%95%A3/6.png"> </p></li><li><p>feed数据存储，与读扩散不同的是，每个用户还要存储自己关注的用户的feed流，比如A关注了BC，所以A的接收队列是1、2、3、5、8、10，D关注了B，所以D的接收队列是1、3、5、10<br><img src="/img/%E8%AF%BB%E6%89%A9%E6%95%A3%E4%B8%8E%E5%86%99%E6%89%A9%E6%95%A3/7.png"></p></li></ul><h3 id="4-1-写扩散如何实现主页feed流"><a href="#4-1-写扩散如何实现主页feed流" class="headerlink" title="4.1 写扩散如何实现主页feed流"></a>4.1 写扩散如何实现主页feed流</h3><p>在推模式（写扩散）中，获取“由别人发布的feed组成的主页”会变得异常简单，假设一页消息为3条feed，A如果要看自己朋友圈的第二页消息，直接返回1，2，3即可。画外音：第一页朋友圈是最新的消息，即5，8，10。</p><h3 id="4-2-写扩散如何实现feed发布"><a href="#4-2-写扩散如何实现feed发布" class="headerlink" title="4.2 写扩散如何实现feed发布"></a>4.2 写扩散如何实现feed发布</h3><p>写扩散模式中，发布一条feed的流程会更复杂一些。<br>例如B新发布了一个msg12：</p><ul><li>在B的发布存储中加入消息12</li><li>查询B的全部粉丝AD；</li><li>在粉丝AD的接收feed存储中也加入消息12<br><img src="/img/%E8%AF%BB%E6%89%A9%E6%95%A3%E4%B8%8E%E5%86%99%E6%89%A9%E6%95%A3/8.png"></li></ul><p>之所以该方案被称为推模式，就是因为用户发布feed的时候：</p><ul><li>直接将feed推到了粉丝的接收列表里，故称为“推模式”；</li><li>不止写发布feed存储，而且要写多个粉丝的接收feed存储，故称为“写扩散”；</li></ul><h3 id="4-3-写扩散如何实现关注-取关"><a href="#4-3-写扩散如何实现关注-取关" class="headerlink" title="4.3 写扩散如何实现关注&#x2F;取关"></a>4.3 写扩散如何实现关注&#x2F;取关</h3><p>写扩散中，添加关注的流程也会变得稍微复杂，比如D新增关注C：</p><ul><li>在D的关注存储中添加C</li><li>在C的粉丝存储中增加D</li><li>在D的接收feed存储中加入C发布的feed（有些产品关注后才能看到feed，这样的话就无需第三步，旧feed无需插入）<br><img src="/img/%E8%AF%BB%E6%89%A9%E6%95%A3%E4%B8%8E%E5%86%99%E6%89%A9%E6%95%A3/9.png"></li></ul><p>同样地，写扩散中取消关注的流程也会变得更加复杂，例如A取消关注C：</p><ul><li>在A的关注存储中删除C</li><li>在C的粉丝存储中删除A</li><li>在A的接收feed存储里删除C发布的feed<br><img src="/img/%E8%AF%BB%E6%89%A9%E6%95%A3%E4%B8%8E%E5%86%99%E6%89%A9%E6%95%A3/10.png"></li></ul><h3 id="5-写扩散优缺点"><a href="#5-写扩散优缺点" class="headerlink" title="5. 写扩散优缺点"></a>5. 写扩散优缺点</h3><ul><li>优点<ul><li>消除了拉模式（读扩散）的IO集中点，每个用户都读自己的数据，高并发下锁竞争小（读扩散中，用户发布的feed存储容易成为IO瓶颈）</li><li>拉取朋友圈feed流列表的业务流程异常简单，速度很快</li><li>拉取朋友圈feed流列表，无需进行大量的内存计算和网络传输，性能很高<br>feed业务是典型的读多写少业务场景，读写比甚至高于100：1，即平均发布1条消息，有至少100次阅读。</li></ul></li><li>缺点<ul><li>极大极大消耗存储资源，feed数据会存储很多份，例如5KW粉丝，每次一发博文，消息会冗余5KW份；</li><li>新增关注，取消关注，发布feed的业务流程会更复杂</li></ul></li></ul><h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a>6. 小结</h2><p>feed流业务的推拉模式：</p><ul><li>拉取模式，读扩散，feed存一份，存储小，用户集中访问数据，性能差；</li><li>推送模式，写扩散，feed存多份，用冗余存储换锁冲突，性能高；</li></ul><h2 id="7-参考资料"><a href="#7-参考资料" class="headerlink" title="7. 参考资料"></a>7. 参考资料</h2><ul><li>基础知识讲解：什么是feed流？<a href="https://www.woshipm.com/marketing/1023818.html">https://www.woshipm.com/marketing/1023818.html</a></li><li>读扩散，写扩散，终于终于讲清楚了！ <a href="https://mp.weixin.qq.com/s/yyem2O90k49IgG89r7beaA">https://mp.weixin.qq.com/s/yyem2O90k49IgG89r7beaA</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>系统设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读扩散</tag>
      
      <tag>写扩散</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang条件变量-sync.Cond</title>
    <link href="/2024/12/19/Golang%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F-sync-Cond/"/>
    <url>/2024/12/19/Golang%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F-sync-Cond/</url>
    
    <content type="html"><![CDATA[<p>sync.Cond 条件变量用来协调想要访问共享资源的多个 goroutine，当共享资源的状态发生变化的时候，它可以用来通知被互斥锁阻塞的 goroutine。</p><span id="more"></span>  <h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><p>sync.Cond是Go语言标准库中的一个类型，代表条件变量。它是一种同步机制，用来协调多个goroutine之间的数据同步，当共享资源的状态发生变化时，可以通过条件变量来通知或者等待goroutine，以便他们可以在特定的条件下等待或继续执行。  </p><h3 id="1-1-适用场景"><a href="#1-1-适用场景" class="headerlink" title="1.1 适用场景"></a>1.1 适用场景</h3><p>条件变量的主要作用是在多线程或多进程环境中，实现线程或进程之间的协作和同步，避免不必要的忙碌等待和资源浪费。它可以用于解决生产者 - 消费者问题、线程间的任务分配等多种同步场景。  </p><p>比如，有一种典型的生产者消费者场景。我们有一个生产者 goroutine 来生产数据， 但是这个数据生产的流程比较耗时，如果消费者不断的轮询数据是否生产完成会导致忙碌等待和资源浪费。这时不如消费者先阻塞，使用条件变量来实现生产者和消费者之间的同步， 当数据准备好之后，就可以通过条件变量来通知所有等待的消费者 goroutine 去读取数据。  </p><h3 id="1-2-类型对比"><a href="#1-2-类型对比" class="headerlink" title="1.2 类型对比"></a>1.2 类型对比</h3><ul><li>条件变量 VS 互斥锁</li></ul><p>条件变量通常与互斥锁（Mutex）结合使用，用于解决线程或进程之间的等待和通知问题。但它们的作用和使用方式又有所不同。  </p><p>互斥锁（Mutex）主要用于保护共享资源，确保在同一时刻只有一个线程或进程能够访问该资源。互斥锁通过加锁和解锁来实现对共享资源的独占访问，防止多个线程或进程同时修改共享资源导致的数据不一致或竞态条件。  </p><p>条件变量（Condition Variable）则用于线程或进程之间的等待和通知。当一个线程或进程需要等待某个条件满足时，它可以使用条件变量进行等待。其他线程或进程可以在条件满足时通过条件变量通知等待的线程或进程。条件变量通常与互斥锁结合使用，在等待条件变量之前需要先获取互斥锁，以保护条件的判断和修改。  </p><p>具体来说，互斥锁用于解决资源竞争问题，而条件变量用于解决线程或进程之间的协作问题。互斥锁关注的是对资源的访问控制，而条件变量关注的是线程或进程之间的状态变化和通知机制。<br>例如，在生产者 - 消费者问题中，互斥锁用于保护共享的缓冲区，确保生产者和消费者在访问缓冲区时不会发生冲突。而条件变量用于实现生产者和消费者之间的同步，当缓冲区为空时，消费者等待生产者生产数据并通知；当缓冲区已满时，生产者等待消费者取出数据并通知。总的来说，互斥锁和条件变量相互配合，共同实现多线程或多进程的同步和协作。  </p><ul><li>条件变量 vs 信号量</li></ul><p>信号量也和条件变量类似，用于多线程或多进程同步和通信的机制，但它们有一些区别：  </p><p>条件变量主要用于线程或进程之间的等待和通知。当一个线程或进程需要等待某个条件满足时，它可以使用条件变量进行等待，其他线程或进程可以在条件满足时通过条件变量通知等待的线程或进程。条件变量通常与互斥锁结合使用，以保护条件的判断和修改。  </p><p>信号量主要用于控制对共享资源的访问数量。它是一个整数计数器，表示可用资源的数量。线程或进程可以通过对信号量进行 P 操作（减 1）来申请资源，如果信号量的值小于等于 0，则线程或进程会被阻塞；通过 V 操作（加 1）来释放资源，唤醒一个或多个等待的线程或进程。  </p><p>条件变量适用于需要线程或进程之间进行等待和通知的场景，例如生产者 - 消费者问题、线程间的任务分配等。信号量适用于控制同时访问某个共享资源的线程或进程数量，例如限制同时访问数据库连接的数量、控制并发任务的执行数量等。  </p><p>总的来说，条件变量更侧重于线程或进程之间的协作和状态同步，而信号量更侧重于资源的访问控制和并发数量的限制。在实际应用中，根据具体的需求选择合适的同步机制。</p><ul><li>互斥锁用于解决资源竞争问题</li><li>条件变量侧重于线程和进程之间的协作和状态同步</li><li>信号量更侧重于资源的访问控制和并发数量的限制</li></ul><h2 id="2-简易操作"><a href="#2-简易操作" class="headerlink" title="2.简易操作"></a>2.简易操作</h2><p>sync.Cond 的基本用法非常简单，我们只需要通过 sync.NewCond 方法来创建一个 Cond 实例， 然后通过 Wait 方法来等待条件满足，通过 Signal 或者 Broadcast 方法来通知所有等待的 goroutine 去重新获取共享资源。举例如下：一个单生产者多消费者的场景。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> mutex = sync.Mutex&#123;&#125;<br><span class="hljs-keyword">var</span> cond = sync.NewCond(&amp;mutex)<br><br><span class="hljs-keyword">var</span> queue []<span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">producer</span><span class="hljs-params">()</span></span> &#123;<br>    i := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        mutex.Lock()<br>        i++<br>        queue = <span class="hljs-built_in">append</span>(queue, i)<br>        mutex.Unlock()<br><br>        cond.Signal()<br>        time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">consumer</span><span class="hljs-params">(consumerName <span class="hljs-type">string</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        mutex.Lock()<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) == <span class="hljs-number">0</span> &#123;<br>            cond.Wait()<br>        &#125;<br><br>        fmt.Println(consumerName, queue[<span class="hljs-number">0</span>])<br>        queue = queue[<span class="hljs-number">1</span>:]<br>        mutex.Unlock()<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 开启一个 producer</span><br>    <span class="hljs-keyword">go</span> producer()<br><br>    <span class="hljs-comment">// 开启两个 consumer</span><br>    <span class="hljs-keyword">go</span> consumer(<span class="hljs-string">&quot;consumer-1&quot;</span>)<br>    <span class="hljs-keyword">go</span> consumer(<span class="hljs-string">&quot;consumer-2&quot;</span>)<br><br>    <span class="hljs-keyword">for</span> &#123;<br>        time.Sleep(<span class="hljs-number">1</span> * time.Minute)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在以上代码中，有一个 producer 的 goroutine 将数据写入到 queue 中，有两个 consumer 的 goroutine 负责从队列中消费数据。而 producer 和 consumer 对 queue 的读写操作都由sync.Mutex进行并发安全的保护。其中 consumer 需要等待 queue 不为空时才能进行消费，因此 consumer 对于 queue 不为空这一条件的等待和唤醒，就可以用到 sync.Cond。<br>回过头来重新看下 sync.Cond 接口的用法:</p><ol><li>sync.NewCond(l Locker): 新建一个 sync.Cond 变量。该函数需要一个 Locker 作为必填参数，这是因为在 cond.Wait() 中底层会涉及到 Locker 的锁操作。</li><li>cond.Wait(): 等待被唤醒。唤醒期间会解锁并切走 goroutine。</li><li>cond.Signal(): 只唤醒一个最先等待的 goroutine。</li><li>cond.Broadcast()：唤醒全部等待的 goroutine。</li></ol><h2 id="3-实现原理"><a href="#3-实现原理" class="headerlink" title="3. 实现原理"></a>3. 实现原理</h2><h3 id="3-1-数据结构"><a href="#3-1-数据结构" class="headerlink" title="3.1 数据结构"></a>3.1 数据结构</h3><p>sync.Cond的定义如下，提供了Wait ,Singal,Broadcast以及NewCond方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Cond <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-comment">// noCopy 是一个特殊的字段，用于在静态代码分析工具（如 go vet）中检查不安全的复制   </span><br>    noCopy noCopy   <br>    <span class="hljs-comment">// L 是一个检查条件或者处理过程中需要持有的锁  </span><br>    L Locker   <br>    <br>    <span class="hljs-comment">// 通知队列</span><br>    notify  notifyList<br>    <span class="hljs-comment">// 检查器，校验Cond是否被复制 </span><br>    checker copyChecker<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewCond</span><span class="hljs-params">(l Locker)</span></span> *Cond &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cond)</span></span> Wait() &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cond)</span></span> Signal() &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cond)</span></span> Broadcast() &#123;&#125;<br></code></pre></td></tr></table></figure><p>当前结构体的核心内容是一个通知队列notifyList，他是一个链表，保存了所有处于等待状态的协程。通知队列定义如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> notifyList <span class="hljs-keyword">struct</span> &#123;<br>    wait   <span class="hljs-type">uint32</span>   <br>    notify <span class="hljs-type">uint32</span>   <br>    lock   <span class="hljs-type">uintptr</span> <span class="hljs-comment">// key field of the mutex   </span><br>    head   unsafe.Pointer   <br>    tail   unsafe.Pointer<br>&#125;<br></code></pre></td></tr></table></figure><p>notifyList包含三类属性：</p><ul><li>wait和notify：他们都是数字，分别代表着写一个等待者的编号和下一个通知者的编号。</li><li>lock：底层是一个mutex类型的指针，用来保护notifyList。</li><li>head和tail：底层是一个sudog类型的指针，用来记录阻塞的goroutine链表的头结点和尾节点。<br>notifyList 提供了一系列函数，来实现notifyList 读写操作，sync.Cond 也是调用这些方法来实现goroutine的阻塞与唤醒：</li><li>notifyListAdd 将 waiter 的编号加 1。</li><li>notifyListWait 将当前的 goroutine 加入到 notifyList 中。（也就是将当前协程挂起）</li><li>notifyListNotifyOne 将 notifyList 中的第一个 goroutine 唤醒。</li><li>notifyListNotifyAll 将 notifyList 中的所有 goroutine 唤醒。</li><li>notifyListCheck 方法检查 notifyList 的大小是否正确。</li></ul><h3 id="3-2-Wait-方法实现"><a href="#3-2-Wait-方法实现" class="headerlink" title="3.2 Wait 方法实现"></a>3.2 Wait 方法实现</h3><p>Wait方法首先调用runtime_notifyListAd方法，将自己加入到等待队列中，然后释放锁，等待其他协程的唤醒。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cond)</span></span> Wait() &#123;<br>    <span class="hljs-comment">// 检查是否被复制</span><br>    c.checker.check()   <br>    <span class="hljs-comment">// 将自己放到等待队列中</span><br>    <span class="hljs-comment">// 更新notifyList中需要等待的waiter的数量，返回当前需要插入notifyList的编号</span><br>    t := runtime_notifyListAdd(&amp;c.notify)   <br>    <span class="hljs-comment">// 释放锁   </span><br>    c.L.Unlock()   <br>    <span class="hljs-comment">// 挂起当前g，等待被唤醒   </span><br>    runtime_notifyListWait(&amp;c.notify, t)   <br>    <span class="hljs-comment">// 重新获取锁   </span><br>    c.L.Lock()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-Signal-方法实现"><a href="#3-3-Signal-方法实现" class="headerlink" title="3.3 Signal 方法实现"></a>3.3 Signal 方法实现</h3><p>Singal方法调用runtime_notifyListNotifyOne唤醒等待队列中的一个协程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cond)</span></span> Signal() &#123;<br>    <span class="hljs-comment">// 检查 sync.Cond是否被复制</span><br>    c.checker.check()<br>   <span class="hljs-comment">// 唤醒等待队列中的一个协程</span><br>   runtime_notifyListNotifyOne(&amp;c.notify)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/Golang%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F-Cond/2.png" alt="图片"> </p><h3 id="3-4-Broadcast-方法实现"><a href="#3-4-Broadcast-方法实现" class="headerlink" title="3.4 Broadcast 方法实现"></a>3.4 Broadcast 方法实现</h3><p>Broadcast方法调用runtime_notifyListNotifyAll唤醒所有处于等待状态的协程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cond)</span></span> Broadcast() &#123;<br>    <span class="hljs-comment">// 检查 sync.Cond是否被复制</span><br>    c.checker.check()<br>   <span class="hljs-comment">// 唤醒等待队列中所有的协程</span><br>   runtime_notifyListNotifyAll(&amp;c.notify)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-5-copyChecker-方法实现"><a href="#3-5-copyChecker-方法实现" class="headerlink" title="3.5 copyChecker 方法实现"></a>3.5 copyChecker 方法实现</h3><p>在调用 Wait、Signal、Broadcast 方法的时候都会先调用 copyChecker.check 方法，目的是检查 Cond 实例有没有被复制。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// copyChecker holds back pointer to itself to detect object copying.</span><br><span class="hljs-keyword">type</span> copyChecker <span class="hljs-type">uintptr</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *copyChecker)</span></span> check() &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-type">uintptr</span>(*c) != <span class="hljs-type">uintptr</span>(unsafe.Pointer(c)) &amp;&amp;<br>        !atomic.CompareAndSwapUintptr((*<span class="hljs-type">uintptr</span>)(c), <span class="hljs-number">0</span>, <span class="hljs-type">uintptr</span>(unsafe.Pointer(c))) &amp;&amp;<br>        <span class="hljs-type">uintptr</span>(*c) != <span class="hljs-type">uintptr</span>(unsafe.Pointer(c)) &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;sync.Cond is copied&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体这段逻辑未理解，只知道这个是用来校验sync.Cond是否被复制</p><h2 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4. 应用场景"></a>4. 应用场景</h2><h3 id="4-1-生产者与消费者"><a href="#4-1-生产者与消费者" class="headerlink" title="4.1 生产者与消费者"></a>4.1 生产者与消费者</h3><p>假设有一个生产者协程不断生产产品并放入缓冲区，有多个消费者协程从缓冲区中取出产品进行消费。可以使用sync.Cond来协调生产者和消费者，当缓冲区为空时，消费者协程等待；当缓冲区已满时，生产者协程等待。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Buffer <span class="hljs-keyword">struct</span> &#123;<br>    data []<span class="hljs-type">int</span><br>    size <span class="hljs-type">int</span><br>    mutex *sync.Mutex<br>    notEmpty sync.Cond<br>    notFull  sync.Cond<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewBuffer</span><span class="hljs-params">(size <span class="hljs-type">int</span>)</span></span> *Buffer &#123;<br>    mutex := sync.Mutex&#123;&#125;<br>    <span class="hljs-keyword">return</span> &amp;Buffer&#123;<br>        size: size,<br>        mutex: &amp;mutex,<br>        notEmpty: *sync.NewCond(&amp;mutex),<br>        notFull:  *sync.NewCond(&amp;mutex),<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Buffer)</span></span> Put(item <span class="hljs-type">int</span>) &#123;<br>    b.mutex.Lock()<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(b.data) == b.size &#123;<br>        b.notFull.Wait()<br>    &#125;<br>    b.data = <span class="hljs-built_in">append</span>(b.data, item)<br>    b.notEmpty.Signal()<br>    b.mutex.Unlock()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Buffer)</span></span> Get() <span class="hljs-type">int</span> &#123;<br>    b.mutex.Lock()<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(b.data) == <span class="hljs-number">0</span> &#123;<br>        b.notEmpty.Wait()<br>    &#125;<br>    item := b.data[<span class="hljs-number">0</span>]<br>    b.data = b.data[<span class="hljs-number">1</span>:]<br>    b.notFull.Signal()<br>    b.mutex.Unlock()<br>    <span class="hljs-keyword">return</span> item<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">producer</span><span class="hljs-params">(buffer *Buffer)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; ; i++ &#123;<br>        buffer.Put(i)<br>        fmt.Println(<span class="hljs-string">&quot;Produced:&quot;</span>, i)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">consumer</span><span class="hljs-params">(buffer *Buffer)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        item := buffer.Get()<br>        fmt.Println(<span class="hljs-string">&quot;Consumed:&quot;</span>, item)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    buffer := NewBuffer(<span class="hljs-number">5</span>)<br>    <span class="hljs-keyword">go</span> producer(buffer)<br>    <span class="hljs-keyword">go</span> consumer(buffer)<br>    <span class="hljs-keyword">go</span> consumer(buffer)<br>    <span class="hljs-keyword">select</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-任务队列管理"><a href="#4-2-任务队列管理" class="headerlink" title="4.2 任务队列管理"></a>4.2 任务队列管理</h3><p>有一个任务队列，多个工作协程从队列中获取任务进行处理，当队列为空时等待新任务的加入。管理者协程负责向队列中添加任务，并在添加任务后通知等待的工作协程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> TaskQueue <span class="hljs-keyword">struct</span> &#123;<br>    queue    []<span class="hljs-keyword">interface</span>&#123;&#125;<br>    mutex    *sync.Mutex<br>    notEmpty sync.Cond<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewTaskQueue</span><span class="hljs-params">()</span></span> *TaskQueue &#123;<br>    mutex := &amp;sync.Mutex&#123;&#125;<br>    <span class="hljs-keyword">return</span> &amp;TaskQueue&#123;<br>       mutex:    mutex,<br>       notEmpty: *sync.NewCond(mutex),<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tq *TaskQueue)</span></span> AddTask(task <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    tq.mutex.Lock()<br>    tq.queue = <span class="hljs-built_in">append</span>(tq.queue, task)<br>    tq.notEmpty.Signal()<br>    tq.mutex.Unlock()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tq *TaskQueue)</span></span> GetTask() <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    tq.mutex.Lock()<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(tq.queue) == <span class="hljs-number">0</span> &#123;<br>       tq.notEmpty.Wait()<br>    &#125;<br>    task := tq.queue[<span class="hljs-number">0</span>]<br>    tq.queue = tq.queue[<span class="hljs-number">1</span>:]<br>    tq.mutex.Unlock()<br>    <span class="hljs-keyword">return</span> task<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span><span class="hljs-params">(tq *TaskQueue)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>       task := tq.GetTask()<br>       fmt.Println(<span class="hljs-string">&quot;Processing task:&quot;</span>, task)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    taskQueue := NewTaskQueue()<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;<br>       <span class="hljs-keyword">go</span> worker(taskQueue)<br>    &#125;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++ &#123;<br>       taskQueue.AddTask(j)<br>    &#125;<br><br>    time.Sleep(<span class="hljs-number">3</span> * time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5. 注意事项"></a>5. 注意事项</h2><h3 id="5-1-调用Wait要加锁"><a href="#5-1-调用Wait要加锁" class="headerlink" title="5.1 调用Wait要加锁"></a>5.1 调用Wait要加锁</h3><p>sync.Cond必须与互斥锁一起使用，以确保对条件变量的访问是线程安全的。</p><ul><li>从源码的角度看，在 Wait 方法内部会先解锁然后再进行阻塞，如果调用 Wait 方法前没有进行加锁会出现panic。</li><li>从应用场景来说，通常 Wait 等待的共享资源是并发访问的，加锁的目的是为了保证共享资源的并发安全。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 官方文档里的一个示例</span><br>c.L.Lock()<br><span class="hljs-keyword">for</span> !condition() &#123;<br>    c.Wait()<br>&#125;<br>... <span class="hljs-built_in">make</span> use of condition ...<br>c.L.Unlock()<br></code></pre></td></tr></table></figure></li></ul><h3 id="5-2-Wait条件循环判断"><a href="#5-2-Wait条件循环判断" class="headerlink" title="5.2 Wait条件循环判断"></a>5.2 Wait条件循环判断</h3><p>在使用cond.Wait时，可能会出现虚假唤醒的情况，即协程在没有收到信号的情况下被唤醒。因此，在等待条件满足的循环中，应该始终检查条件是否真正满足。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// bad case</span><br>c.L.Lock()<br><span class="hljs-keyword">if</span> !condition() &#123;<br>    c.Wait()<br>&#125;<br>... <span class="hljs-built_in">make</span> use of condition ...<br>c.L.Unlock()<br><br><span class="hljs-comment">// good case </span><br>c.L.Lock()<br><span class="hljs-keyword">for</span> !condition() &#123;<br>    c.Wait()<br>&#125;<br>... <span class="hljs-built_in">make</span> use of condition ...<br>c.L.Unlock()<br></code></pre></td></tr></table></figure><h3 id="5-3-不要复制sync-Cond"><a href="#5-3-不要复制sync-Cond" class="headerlink" title="5.3 不要复制sync.Cond"></a>5.3 不要复制sync.Cond</h3><p>sync.Cond类型包含了一个互斥锁(mutex)和一个notifyList</p><ol><li>如果对其进行复制，此时已经处于使用状态的sync.Mutex会在另一个地方在不知情的情况下使用，这会导致不可预料的情况出现。</li><li>其次是notifyList也会被拷贝，notifyList保存了等待通知的goroutine列表。如果拷贝了sync.Cond类型的值，此时新的值和原始值都将指向同一个等待通知的goroutine列表。对新的值调用Singal和Broadcast方法将会影响到原始sync.Cond中的等待通知的goroutine,这样子可能会导致重复唤醒问题的出现。<br>于是，sync.Cond从实现上就禁止了sync.Cond的复制，在编译期就对其进行验证，一旦试图复制时，编译器会直接报错。</li></ol><h3 id="5-4-Signal和Boardcast操作不需要加锁"><a href="#5-4-Signal和Boardcast操作不需要加锁" class="headerlink" title="5.4 Signal和Boardcast操作不需要加锁"></a>5.4 Signal和Boardcast操作不需要加锁</h3><h2 id="6-参考资料"><a href="#6-参考资料" class="headerlink" title="6. 参考资料"></a>6. 参考资料</h2><ul><li>深入理解go语言中的sync.Cond： <a href="https://juejin.cn/post/7212270321621483578">https://juejin.cn/post/7212270321621483578</a></li><li>探索go sync.Cond的实现与应用：<a href="https://mp.weixin.qq.com/s/zoe-WIGnC7QCTJhBUigZeg">https://mp.weixin.qq.com/s/zoe-WIGnC7QCTJhBUigZeg</a></li><li>深入理解go sync.Cond <a href="https://juejin.cn/post/7194704072136966181">https://juejin.cn/post/7194704072136966181</a></li><li>Golang sync.Cond 条件变量源码分析：<a href="https://www.cyhone.com/articles/golang-sync-cond/">https://www.cyhone.com/articles/golang-sync-cond/</a></li><li>Go sync.Cond 条件变量的学习：<a href="https://iswxw.blog.csdn.net/article/details/127723413">https://iswxw.blog.csdn.net/article/details/127723413</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
      <category>互斥锁与原子操作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>Cond</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang原子操作-Atomic</title>
    <link href="/2024/11/23/Goalng%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C-Atomic/"/>
    <url>/2024/11/23/Goalng%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C-Atomic/</url>
    
    <content type="html"><![CDATA[<p>一个或者多个操作在 CPU 执行的过程中不被中断的特性，称为原子性（atomicity） 。这些操作对外表现成一个不可分割的整体，他们要么都执行，要么都不执行，外界不会看到他们只执行到一半的状态。</p><span id="more"></span>  <h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>一个或者多个操作在 CPU 执行的过程中不被中断的特性，称为原子性（atomicity） 。这些操作对外表现成一个不可分割的整体，他们要么都执行，要么都不执行，外界不会看到他们只执行到一半的状态。  </p><blockquote><p>📌 CPU执行一系列操作时不可能不发生中断，但如果我们在执行多个操作时，能让他们的中间状态对外不可见，那我们就可以宣称他们拥有了”不可分割”的原子性。 </p></blockquote><h2 id="2-基本介绍"><a href="#2-基本介绍" class="headerlink" title="2. 基本介绍"></a>2. 基本介绍</h2><h3 id="2-1-互斥锁与原子操作"><a href="#2-1-互斥锁与原子操作" class="headerlink" title="2.1 互斥锁与原子操作"></a>2.1 互斥锁与原子操作</h3><p>原子操作和互斥锁均可用于在并发环境中保护共享资源，不过它们在应用场景、实现机制、性能等方面存在一定的差异：<br><img src="/img/Golang%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C-Atomic/1.png"><br>对一个变量更新的保护，原子操作通常更有效率，并且能利用计算机多核的优势</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mutexAdd</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a <span class="hljs-type">int32</span> = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    <span class="hljs-keyword">var</span> mu sync.Mutex<br>    start := time.Now()<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000000</span>; i++ &#123;<br>        wg.Add(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            <span class="hljs-keyword">defer</span> wg.Done()<br>            mu.Lock()<br>            a += <span class="hljs-number">1</span><br>            mu.Unlock()<br>        &#125;()<br>    &#125;<br>    wg.Wait()<br>    timeSpends := time.Since(start).Nanoseconds()<br>    fmt.Printf(<span class="hljs-string">&quot;use mutex a is %d, spend time: %v\n&quot;</span>, a, timeSpends)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AtomicAdd</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a <span class="hljs-type">int32</span> = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    <br>    start := time.Now()<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000000</span>; i++ &#123;<br>        wg.Add(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            <span class="hljs-keyword">defer</span> wg.Done()<br>            atomic.AddInt32(&amp;a, <span class="hljs-number">1</span>)<br>        &#125;()<br>    &#125;<br>    <br>    <br>    wg.Wait()<br>    timeSpends := time.Since(start).Nanoseconds()<br>    fmt.Printf(<span class="hljs-string">&quot;use atomic a is %d, spend time: %v\n&quot;</span>, atomic.LoadInt32(&amp;a), timeSpends)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-原子能力介绍"><a href="#2-2-原子能力介绍" class="headerlink" title="2.2 原子能力介绍"></a>2.2 原子能力介绍</h3><p>Go语言通过内置包sync&#x2F;atomic提供了对原子操作的支持，其提供的原子操作有以下5类，其中每种类别支持的数据类型有6种：Int32、Int64、Uint32、Uint64、Uintptr、Pointer  他们可以随意组合：</p><ul><li>增加 (Add)：atomic.AddInt32(addr *int32, delta int32)</li><li>加载（Load）：atomic.LoadInt32(addr *int32)</li><li>存储（Store）：atomic.LoadInt32(addr *int32)</li><li>交换（Swap）：atomic.SwapInt32(addr *int32, new int32)</li><li>比较并交换（CompareAndSwap）: atomic.CompareAndSwapInt32(addr *int32, old int32, new int32)</li></ul><blockquote><p>📌 注意：</p><ul><li>所有原子操作方法的被操作数形参必须是指针类型，通过指针变量可以获取被操作数在内存中的地址，从而施加特殊的CPU指令，确保同一时间只有一个goroutine能够进行操作</li></ul></blockquote><p>详细支持的原子操作有：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// TSL Test-and-Set-Lock，对某个存储器位置写值并返回旧值</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// old = *addr</span><br><span class="hljs-comment">// *addr = new</span><br><span class="hljs-comment">// return old</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SwapInt32</span><span class="hljs-params">(addr *<span class="hljs-type">int32</span>, <span class="hljs-built_in">new</span> <span class="hljs-type">int32</span>)</span></span> (old <span class="hljs-type">int32</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SwapInt64</span><span class="hljs-params">(addr *<span class="hljs-type">int64</span>, <span class="hljs-built_in">new</span> <span class="hljs-type">int64</span>)</span></span> (old <span class="hljs-type">int64</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SwapUint32</span><span class="hljs-params">(addr *<span class="hljs-type">uint32</span>, <span class="hljs-built_in">new</span> <span class="hljs-type">uint32</span>)</span></span> (old <span class="hljs-type">uint32</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SwapUint64</span><span class="hljs-params">(addr *<span class="hljs-type">uint64</span>, <span class="hljs-built_in">new</span> <span class="hljs-type">uint64</span>)</span></span> (old <span class="hljs-type">uint64</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SwapUintptr</span><span class="hljs-params">(addr *<span class="hljs-type">uintptr</span>, <span class="hljs-built_in">new</span> <span class="hljs-type">uintptr</span>)</span></span> (old <span class="hljs-type">uintptr</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SwapPointer</span><span class="hljs-params">(addr *unsafe.Pointer, <span class="hljs-built_in">new</span> unsafe.Pointer)</span></span> (old unsafe.Pointer)<br><br><span class="hljs-comment">// FAA Fetch-and- Add，对某个存储器位置加值并返回新值</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// *addr += delta</span><br><span class="hljs-comment">// return *addr</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AddInt32</span><span class="hljs-params">(addr *<span class="hljs-type">int32</span>, delta <span class="hljs-type">int32</span>)</span></span> (<span class="hljs-built_in">new</span> <span class="hljs-type">int32</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AddUint32</span><span class="hljs-params">(addr *<span class="hljs-type">uint32</span>, delta <span class="hljs-type">uint32</span>)</span></span> (<span class="hljs-built_in">new</span> <span class="hljs-type">uint32</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AddInt64</span><span class="hljs-params">(addr *<span class="hljs-type">int64</span>, delta <span class="hljs-type">int64</span>)</span></span> (<span class="hljs-built_in">new</span> <span class="hljs-type">int64</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AddUint64</span><span class="hljs-params">(addr *<span class="hljs-type">uint64</span>, delta <span class="hljs-type">uint64</span>)</span></span> (<span class="hljs-built_in">new</span> <span class="hljs-type">uint64</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AddUintptr</span><span class="hljs-params">(addr *<span class="hljs-type">uintptr</span>, delta <span class="hljs-type">uintptr</span>)</span></span> (<span class="hljs-built_in">new</span> <span class="hljs-type">uintptr</span>)<br><br><span class="hljs-comment">// CAS Compare-and-Swap，判断某个存储器位置的值是否与指定值相等，如果相等则替换为新的值</span><br><span class="hljs-comment">// CAS操作修改共享变量时候不需要对共享变量加锁，而是通过类似乐观锁的方式进行检查，</span><br><span class="hljs-comment">// 本质还是不断的占用CPU 资源换取加锁带来的开销（比如上下文切换开销）。</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//  if *addr == old &#123;</span><br><span class="hljs-comment">//      *addr = new</span><br><span class="hljs-comment">//      return true</span><br><span class="hljs-comment">//  &#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// return false</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CompareAndSwapInt32</span><span class="hljs-params">(addr *<span class="hljs-type">int32</span>, old, <span class="hljs-built_in">new</span> <span class="hljs-type">int32</span>)</span></span> (swapped <span class="hljs-type">bool</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CompareAndSwapInt64</span><span class="hljs-params">(addr *<span class="hljs-type">int64</span>, old, <span class="hljs-built_in">new</span> <span class="hljs-type">int64</span>)</span></span> (swapped <span class="hljs-type">bool</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CompareAndSwapUint32</span><span class="hljs-params">(addr *<span class="hljs-type">uint32</span>, old, <span class="hljs-built_in">new</span> <span class="hljs-type">uint32</span>)</span></span> (swapped <span class="hljs-type">bool</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CompareAndSwapUint64</span><span class="hljs-params">(addr *<span class="hljs-type">uint64</span>, old, <span class="hljs-built_in">new</span> <span class="hljs-type">uint64</span>)</span></span> (swapped <span class="hljs-type">bool</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CompareAndSwapUintptr</span><span class="hljs-params">(addr *<span class="hljs-type">uintptr</span>, old, <span class="hljs-built_in">new</span> <span class="hljs-type">uintptr</span>)</span></span> (swapped <span class="hljs-type">bool</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CompareAndSwapPointer</span><span class="hljs-params">(addr *unsafe.Pointer, old, <span class="hljs-built_in">new</span> unsafe.Pointer)</span></span> (swapped <span class="hljs-type">bool</span>)<br><br><span class="hljs-comment">// Read</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LoadInt32</span><span class="hljs-params">(addr *<span class="hljs-type">int32</span>)</span></span> (val <span class="hljs-type">int32</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LoadInt64</span><span class="hljs-params">(addr *<span class="hljs-type">int64</span>)</span></span> (val <span class="hljs-type">int64</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LoadUint32</span><span class="hljs-params">(addr *<span class="hljs-type">uint32</span>)</span></span> (val <span class="hljs-type">uint32</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LoadUint64</span><span class="hljs-params">(addr *<span class="hljs-type">uint64</span>)</span></span> (val <span class="hljs-type">uint64</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LoadUintptr</span><span class="hljs-params">(addr *<span class="hljs-type">uintptr</span>)</span></span> (val <span class="hljs-type">uintptr</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LoadPointer</span><span class="hljs-params">(addr *unsafe.Pointer)</span></span> (val unsafe.Pointer)<br><br><span class="hljs-comment">// Write</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StoreInt32</span><span class="hljs-params">(addr *<span class="hljs-type">int32</span>, val <span class="hljs-type">int32</span>)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StoreInt64</span><span class="hljs-params">(addr *<span class="hljs-type">int64</span>, val <span class="hljs-type">int64</span>)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StoreUint32</span><span class="hljs-params">(addr *<span class="hljs-type">uint32</span>, val <span class="hljs-type">uint32</span>)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StoreUint64</span><span class="hljs-params">(addr *<span class="hljs-type">uint64</span>, val <span class="hljs-type">uint64</span>)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StoreUintptr</span><span class="hljs-params">(addr *<span class="hljs-type">uintptr</span>, val <span class="hljs-type">uintptr</span>)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StorePointer</span><span class="hljs-params">(addr *unsafe.Pointer, val unsafe.Pointer)</span></span><br></code></pre></td></tr></table></figure><h3 id="2-3-Atomic-Value"><a href="#2-3-Atomic-Value" class="headerlink" title="2.3 Atomic.Value"></a>2.3 Atomic.Value</h3><p>sync&#x2F;atomic 的原子读写只提供了 int32、int64、uint32、uint64、uintptr 和 unsafe.Pointer 这几个数据类型。如果是其它数据类型的话就需要使用 atomic.Value 来实现原子读写了</p><h4 id="2-3-1-简介"><a href="#2-3-1-简介" class="headerlink" title="2.3.1 简介"></a>2.3.1 简介</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> pair <span class="hljs-keyword">struct</span> &#123;<br>    x, y <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    p := pair&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>    <span class="hljs-keyword">var</span> v atomic.Value<br><br>    v.Store(p)<br>    fmt.Println(v.Load().(pair).x)<br>    fmt.Println(v.Load().(pair).y)<br>&#125;<br></code></pre></td></tr></table></figure><p>atomic.Value在底层的实现中是一个interface，且是一个efaceWords类型的interface。从注释中可以看到，Value的零值是nil，且使用后不允许被拷贝。<br>Value写入值后，typ存储数据类型，data存储数据值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// A Value provides an atomic load and store of a consistently typed value.</span><br><span class="hljs-comment">// The zero value for a Value returns nil from Load.</span><br><span class="hljs-comment">// Once Store has been called, a Value must not be copied.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// A Value must not be copied after first use.</span><br><span class="hljs-keyword">type</span> Value <span class="hljs-keyword">struct</span> &#123;<br>    v any<br>&#125;<br><br><span class="hljs-comment">// efaceWords is interface&#123;&#125; internal representation.</span><br><span class="hljs-keyword">type</span> efaceWords <span class="hljs-keyword">struct</span> &#123;<br>    typ  unsafe.Pointer<br>    data unsafe.Pointer<br>&#125;<br></code></pre></td></tr></table></figure><p>Value的核心逻辑是Store和Load，分别介绍如下</p><h4 id="2-3-2-Store"><a href="#2-3-2-Store" class="headerlink" title="2.3.2 Store"></a>2.3.2 Store</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Store 将v的值设置为val，同一个Value只能存储一个类型，而且不能存储nil，否则会panic</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v *Value)</span></span> Store(val any) &#123;<br>    <span class="hljs-comment">// 数据校验，存储的值不能为nil</span><br>    <span class="hljs-keyword">if</span> val == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;sync/atomic: store of nil value into Value&quot;</span>)<br>    &#125;<br>    <span class="hljs-comment">// 获取v和val的指针</span><br>    vp := (*efaceWords)(unsafe.Pointer(v))<br>    vlp := (*efaceWords)(unsafe.Pointer(&amp;val))<br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-comment">// 判断是否是首次存储</span><br>        typ := LoadPointer(&amp;vp.typ)<br>        <span class="hljs-keyword">if</span> typ == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-comment">// 首次store时会调用runtime_procPin禁止当前P被抢占，保证一次Store的完整性</span><br>            runtime_procPin()<br>            <span class="hljs-comment">// 使用CAS抢占乐观锁，将typ修改为中间值，表示正在进行首次存储，如果抢锁失败，直接跳出并进行下一轮操作</span><br>            <span class="hljs-keyword">if</span> !CompareAndSwapPointer(&amp;vp.typ, <span class="hljs-literal">nil</span>, unsafe.Pointer(&amp;firstStoreInProgress)) &#123;<br>                runtime_procUnpin()<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            <span class="hljs-comment">// 抢锁成功后，存储data和typ</span><br>            StorePointer(&amp;vp.data, vlp.data)<br>            StorePointer(&amp;vp.typ, vlp.typ)<br>            runtime_procUnpin()<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-comment">// 如果不是首次存储，需要看下首次存储是不是还在进行中，如果在进行中，就到等待首次存储结束</span><br>        <span class="hljs-keyword">if</span> typ == unsafe.Pointer(&amp;firstStoreInProgress) &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-comment">// 如果首次存储已经结束，校验新存储的数据和第一次的类型是否一致。</span><br>        <span class="hljs-comment">// 如果不一致直接报错，如果一致则完成数据存储</span><br>        <span class="hljs-keyword">if</span> typ != vlp.typ &#123;<br>            <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;sync/atomic: store of inconsistently typed value into Value&quot;</span>)<br>        &#125;<br>        StorePointer(&amp;vp.data, vlp.data)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>梳理下流程：<br>1、首先判断类型如果为nil直接panic；<br>2、然后通过有个for循环来连续判断是否可以进行值的写入；<br>3、如果是typ &#x3D;&#x3D; nil表示是第一次写入,然后给type设置一个标识位，来表示有goroutine正在写入；<br>4、然后写入值，退出；<br>5、如果type不为nil，但是等于标识位，表示有正在写入的goroutine，然后继续循环；<br>6、最后type不为nil，并且不等于标识位，并且和value里面的type类型一样，写入内容，然后退出。<br>注意：其中使用了runtime_procPin()方法，它可以将一个goroutine死死占用当前使用的P(P-M-G中的processor)，不允许其它goroutine&#x2F;M抢占,这样就能保证存储顺利完成，不必担心竞争的问题。释放pin的方法是runtime_procUnpin。<br><img src="/img/Golang%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C-Atomic/2.png">    </p><h4 id="2-3-3-Load"><a href="#2-3-3-Load" class="headerlink" title="2.3.3 Load"></a>2.3.3 Load</h4><p>理解了Store的逻辑后，Load的逻辑就比较简单了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Load 返回最近一次设置的值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v *Value)</span></span> Load() (val any) &#123;<br>    <span class="hljs-comment">// 首先获取v的指标和类型</span><br>    vp := (*efaceWords)(unsafe.Pointer(v))<br>    typ := LoadPointer(&amp;vp.typ)<br>    <span class="hljs-comment">// 如果类型为空或者正在进行首次存储，说明没有存储数据，返回nil</span><br>    <span class="hljs-keyword">if</span> typ == <span class="hljs-literal">nil</span> || typ == unsafe.Pointer(&amp;firstStoreInProgress) &#123;<br>        <span class="hljs-comment">// First store not yet completed.</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-comment">// 获取data，并保存</span><br>    data := LoadPointer(&amp;vp.data)<br>    vlp := (*efaceWords)(unsafe.Pointer(&amp;val))<br>    vlp.typ = typ<br>    vlp.data = data<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>📌 使用Value类型时需要注意以下事项：</p><ul><li>Value不能用来存储nil值，否则会panic</li><li>一个Value变量不能存储不同类型的值，存储的类型只能是第一个存储值的类型。否则会panic</li><li>尽量不要使用Value存储引用类型的值。修改引用类型的值也会同步修改Value中存储的值</li></ul></blockquote><h2 id="3-简易应用"><a href="#3-简易应用" class="headerlink" title="3 简易应用"></a>3 简易应用</h2><h3 id="3-1-原子性增加值"><a href="#3-1-原子性增加值" class="headerlink" title="3.1 原子性增加值"></a>3.1 原子性增加值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> count <span class="hljs-type">int32</span><br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>        wg.Add(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            atomic.AddInt32(&amp;count, <span class="hljs-number">1</span>)            <span class="hljs-comment">// 原子性增加值</span><br>            fmt.Println(atomic.LoadInt32(&amp;count)) <span class="hljs-comment">// 原子性加载</span><br><br>            wg.Done()<br>        &#125;()<br>    &#125;<br>    wg.Wait()<br>    fmt.Println(<span class="hljs-string">&quot;count: &quot;</span>, count)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-简易自旋锁"><a href="#3-2-简易自旋锁" class="headerlink" title="3.2 简易自旋锁"></a>3.2 简易自旋锁</h3><p>存满10000后全部取出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>    balance <span class="hljs-type">int32</span> = <span class="hljs-number">1000</span><br>    wg      sync.WaitGroup<br>)<br><br><span class="hljs-comment">// 存钱</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deposit</span><span class="hljs-params">(value <span class="hljs-type">int32</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br><br>        fmt.Printf(<span class="hljs-string">&quot;余额: %d\n&quot;</span>, balance)<br>        atomic.AddInt32(&amp;balance, value)<br>        fmt.Printf(<span class="hljs-string">&quot;存 %d 后的余额: %d\n&quot;</span>, value, balance)<br>        <span class="hljs-keyword">if</span> balance == <span class="hljs-number">10000</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>        time.Sleep(time.Millisecond * <span class="hljs-number">500</span>)<br>    &#125;<br>    wg.Done()<br>&#125;<br><br><span class="hljs-comment">// 取钱</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">withdrawAll</span><span class="hljs-params">(value <span class="hljs-type">int32</span>)</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> wg.Done()<br><br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32(&amp;balance, value, <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>        time.Sleep(time.Millisecond * <span class="hljs-number">500</span>)<br>    &#125;<br>    fmt.Printf(<span class="hljs-string">&quot;余额: %d\n&quot;</span>, value)<br>    fmt.Printf(<span class="hljs-string">&quot;取 %d 后的余额: %d\n&quot;</span>, value, balance)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    wg.Add(<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">go</span> deposit(<span class="hljs-number">1000</span>) <span class="hljs-comment">// 每次存1000</span><br>    <span class="hljs-keyword">go</span> withdrawAll(<span class="hljs-number">10000</span>)<br>    wg.Wait()<br><br>    fmt.Printf(<span class="hljs-string">&quot;当前余额: %d\n&quot;</span>, balance)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-无符号整数减法操作"><a href="#3-3-无符号整数减法操作" class="headerlink" title="3.3 无符号整数减法操作"></a>3.3 无符号整数减法操作</h3><p>对于uint32和uint64类型，Add方法第二个参数只能接受相应的无符号整数，atomic包没有提供减法SubstractT操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AddUint32</span><span class="hljs-params">(addr *<span class="hljs-type">uint32</span>, delta <span class="hljs-type">uint32</span>)</span></span> (<span class="hljs-built_in">new</span> <span class="hljs-type">uint32</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AddUint64</span><span class="hljs-params">(addr *<span class="hljs-type">uint64</span>, delta <span class="hljs-type">uint64</span>)</span></span> (<span class="hljs-built_in">new</span> <span class="hljs-type">uint64</span>)<br></code></pre></td></tr></table></figure><p>对于无符号整数V，我们可以传递-V给AddT方法第二个参数就可以实现减法操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> i <span class="hljs-type">uint64</span> = <span class="hljs-number">100</span><br>    <span class="hljs-keyword">var</span> j <span class="hljs-type">uint64</span> = <span class="hljs-number">10</span><br><br>    <span class="hljs-keyword">var</span> k = <span class="hljs-number">5</span><br>    atomic.AddUint64(&amp;i, -j)<br>    <span class="hljs-built_in">println</span>(i)<br><br>    atomic.AddUint64(&amp;i, -<span class="hljs-type">uint64</span>(k))<br>    <span class="hljs-built_in">println</span>(i)<br><br>    <span class="hljs-comment">// 下面这种操作是不可以的，会报错：constant -5 overflows uint64</span><br>    <span class="hljs-comment">// atomic.AddUint64(&amp;i, -uint64(5))</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4. 参考资料"></a>4. 参考资料</h2><ul><li><a href="https://juejin.cn/post/7010590496204521485">https://juejin.cn/post/7010590496204521485</a> </li><li><a href="https://golang-notes.readthedocs.io/en/latest/golang/golang-concurrent-synchronization-for-atomic-operation.html">https://golang-notes.readthedocs.io/en/latest/golang/golang-concurrent-synchronization-for-atomic-operation.html</a></li><li><a href="https://juejin.cn/post/6907091130039894023">https://juejin.cn/post/6907091130039894023</a></li><li><a href="https://boilingfrog.github.io/2021/03/04/go%E4%B8%AD%E7%9A%84atomic/">https://boilingfrog.github.io/2021/03/04/go%E4%B8%AD%E7%9A%84atomic/</a></li><li><a href="https://iswxw.blog.csdn.net/article/details/127827602">https://iswxw.blog.csdn.net/article/details/127827602</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
      <category>互斥锁与原子操作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>Mutex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 互斥锁 sync.Mutex</title>
    <link href="/2024/11/08/Golang-Mutex%E8%A7%A3%E6%9E%90/"/>
    <url>/2024/11/08/Golang-Mutex%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>互斥锁是在并发程序中对共享资源进行访问控制的主要手段，对此 Go 语言提供了简单易用的 Mutex，它是一种用于并发编程中的同步机制，用于确保在同一时刻只有一个 goroutine 可以访问共享资源。</p><span id="more"></span>  <h2 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1. 背景介绍"></a>1. 背景介绍</h2><h3 id="1-1-基本信息"><a href="#1-1-基本信息" class="headerlink" title="1.1 基本信息"></a>1.1 基本信息</h3><p>互斥锁是在并发程序中对共享资源进行访问控制的主要手段，对此 Go 语言提供了简单易用的 Mutex，它是一种用于并发编程中的同步机制，用于确保在同一时刻只有一个 goroutine 可以访问共享资源。<br><strong>主要特点</strong>：</p><ul><li>互斥性：Mutex的核心特性是互斥性，即保证在任何时刻只有一个 goroutine 可以持有锁并访问被保护的共享资源。这有效地防止了多个 goroutine 同时对共享资源进行读写操作而导致的数据竞争和不一致问题。</li><li>原子性操作：在获取和释放锁的过程中，Mutex的操作是原子性的。这意味着在一个 goroutine 尝试获取锁时，其他 goroutine 不能同时进行获取锁的操作，直到当前持有锁的 goroutine 释放锁。</li><li>不可重入性：Go语言的Mutex只记录了加锁状态，没有记录锁的所有者，所以不支持可重入，自己加的锁别人也可以打开</li></ul><h3 id="1-2-为什么要使用Mutex"><a href="#1-2-为什么要使用Mutex" class="headerlink" title="1.2 为什么要使用Mutex"></a>1.2 为什么要使用Mutex</h3><p>我们看一个示例，启动 10000 个协程将变量 num 加1，因此肯定会存在并发；如果我们不控制并发，10000 个协程都执行完后，该变量的值很大概率不等于 10000。但是如果使用并发的话，总能得到正确的结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    num := <span class="hljs-number">0</span><br>    threadCount := <span class="hljs-number">10000</span><br><br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    wg.Add(threadCount)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; threadCount; i++ &#123;<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            <span class="hljs-keyword">defer</span> wg.Done()<br>            num++<br>        &#125;()<br>    &#125;<br><br>    wg.Wait()        <span class="hljs-comment">// 等待 10000 个协程都执行完</span><br>    fmt.Println(num) <span class="hljs-comment">// 9388(每次都可能不一样)</span><br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    num := <span class="hljs-number">0</span><br>    threadCount := <span class="hljs-number">10000</span><br><br>    <span class="hljs-keyword">var</span> mutex sync.Mutex <span class="hljs-comment">// 互斥锁</span><br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    wg.Add(threadCount)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; threadCount; i++ &#123;<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            <span class="hljs-keyword">defer</span> wg.Done()<br>            mutex.Lock()   <span class="hljs-comment">// 加锁</span><br>            num++          <span class="hljs-comment">// 临界区</span><br>            mutex.Unlock() <span class="hljs-comment">// 解锁</span><br>        &#125;()<br>    &#125;<br><br>    wg.Wait()        <span class="hljs-comment">// 等待 10000 个协程都执行完</span><br>    fmt.Println(num) <span class="hljs-comment">// 结果为10000</span><br>&#125;<br></code></pre></td></tr></table></figure><p>从上面可以看到，Mutex可以保证并发编程过程中的数据一致性和稳定性，实现并发安全编程。</p><h3 id="1-3-基本操作"><a href="#1-3-基本操作" class="headerlink" title="1.3 基本操作"></a>1.3 基本操作</h3><p>Mutex 是一个结构体，对外提供 Lock()和Unlock()两个方法，分别用来加锁和解锁。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// A Locker represents an object that can be locked and unlocked.</span><br><span class="hljs-keyword">type</span> Locker <span class="hljs-keyword">interface</span> &#123;<br>    Lock()<br>    Unlock()<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>加锁（Lock）：当一个 goroutine 需要访问被互斥锁保护的共享资源时，它首先需要调用互斥锁的Lock方法。这个方法会阻塞当前线程，直到互斥锁被释放，然后当前线程获得锁并可以继续执行对共享资源的访问操作。</li><li>解锁（Unlock）：当一个线程完成对共享资源的访问后，它应该调用互斥锁的Unlock方法来释放锁，以便其他等待的线程可以获得锁并访问共享资源。</li></ol><h2 id="2-核心原理"><a href="#2-核心原理" class="headerlink" title="2. 核心原理"></a>2. 核心原理</h2><h3 id="2-1-数据结构"><a href="#2-1-数据结构" class="headerlink" title="2.1 数据结构"></a>2.1 数据结构</h3><p>Go 语言的 sync.Mutex由两个字段 state 和 sema 组成。其中 state 表示当前互斥锁的状态，而 sema 是用于控制锁状态的信号量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Mutex <span class="hljs-keyword">struct</span> &#123;    <br>    state <span class="hljs-type">int32</span>  <span class="hljs-comment">// 复合字段，不仅能表示锁的状态，还能表示等待锁的协程个数 </span><br>    sema  <span class="hljs-type">uint32</span> <span class="hljs-comment">// 信号量，协程阻塞会等待该信号量，解锁的协程释放信号量从而唤醒等待信号量的协程</span><br>&#125;<br></code></pre></td></tr></table></figure><p>互斥锁的状态比较复杂，最低三位分别表示 mutexLocked、mutexWoken 和 mutexStarving，剩下的位置用来表示当前有多少个 Goroutine 在等待互斥锁的释放<br><img src="/img/Golang-Mutex%E8%A7%A3%E6%9E%90/1.png"><br>int32 中的不同位分别表示了不同的状态，默认情况下：互斥锁的所有状态位都是 0，即默认为未锁定状态</p><ul><li>mutexLocked — 表示互斥锁的锁定状态；</li><li>mutexWoken — 表示是否有协程被唤醒；</li><li>mutexStarving — 当前的互斥锁进入饥饿状态；</li><li>waitersCount — 当前互斥锁上等待的 Goroutine 个数<br>相关常量定义：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// sync/mutex.go 36</span><br><span class="hljs-keyword">const</span> (<br>    mutexLocked = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-literal">iota</span> <span class="hljs-comment">// 1 0001 含义：用最后一位表示当前对象锁的状态，0-未锁住 1-已锁住</span><br>    mutexWoken <span class="hljs-comment">// 2 0010 含义：用倒数第二位表示是否已经有协程被唤醒 0-未唤醒 1-已有协程唤醒</span><br>    mutexStarving <span class="hljs-comment">// 4 0100 含义：用倒数第三位表示当前Mutex是否为饥饿模式，0为正常模式，1为饥饿模式。</span><br>    mutexWaiterShift = <span class="hljs-literal">iota</span> <span class="hljs-comment">// 3，从倒数第四位往前的bit位表示在排队等待的goroutine数</span><br>    <br>    starvationThresholdNs = <span class="hljs-number">1e6</span> <span class="hljs-comment">// 1ms 切换到饥饿模式的阈值</span><br>)<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-2-Lock"><a href="#2-2-Lock" class="headerlink" title="2.2 Lock"></a>2.2 Lock</h3><p>本小节主要介绍Mutex中加锁的基本逻辑及一些核心思想。</p><h4 id="2-2-1-常规"><a href="#2-2-1-常规" class="headerlink" title="2.2.1 常规"></a>2.2.1 常规</h4><p>Mutex的加锁操作是一个阻塞调用，如果在加锁时已经被使用，则当前协程会阻塞直至获取到锁。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> Lock() &#123;<br>    <span class="hljs-comment">// Fast path: grab unlocked mutex.</span><br>    <span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="hljs-number">0</span>, mutexLocked) &#123;<br>        <span class="hljs-keyword">if</span> race.Enabled &#123;<br>            race.Acquire(unsafe.Pointer(m))<br>        &#125;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-comment">// Slow path (outlined so that the fast path can be inlined)</span><br>    m.lockSlow()<br>&#125;<br></code></pre></td></tr></table></figure><p>由上面的逻辑可以看到，一个协程在加锁时，分为Fast path和Slow Path, 如果Fast Path能加锁成功，就直接返回了，否则要进入复杂的Slow Path中，这里不详细介绍每一步的源码，只分析核心的逻辑。</p><ul><li>Fast Path：<ul><li>如果m.state为0，说明当前锁处于未锁定状态，尝试使用CAS将其变为锁定状态并直接返回</li></ul></li><li>Slow Path：<ul><li>判断当前协程能否进入自旋</li><li>通过自旋等待互斥锁的释放</li><li>计算互斥锁的最新状态（处理完自旋特殊逻辑后，互斥锁会根据上下文计算当前互斥锁最新的状态）</li><li>更新互斥锁的状态并尝试获取锁<ul><li>如果获取到锁直接返回</li><li>如果没有获取到锁，会调用runtime_SemacquireMutex使协程陷入休眠并等待被唤醒</li><li>唤醒后如果处于正常模式，会设置唤醒和饥饿标记、重置迭代次数并重新执行获取锁的循环；</li><li>唤醒后如果处于饥饿模式，当前 Goroutine 会获得互斥锁，如果等待队列中只存在当前 Goroutine，互斥锁还会从饥饿模式中退出；119</li></ul></li></ul></li></ul><h4 id="2-2-2-自旋"><a href="#2-2-2-自旋" class="headerlink" title="2.2.2 自旋"></a>2.2.2 自旋</h4><p>自旋对应 CPU 的 PAUSE 指令，CPU 对该指令什么都不做，相当于空转。对程序而言相当于sleep了很小一段时间，大概 30个时钟周期。  </p><p><strong>自旋条件</strong><br>加锁时runtime 会自动判断是否可以自旋，无限制的自旋将给 CPU 带来巨大压力，自旋必须满足以下条件：</p><ul><li>互斥锁只有在普通模式才能进入自旋；</li><li>自旋次数要足够少，通常为 4，即自旋最多 4 次；</li><li>CPU 核数要大于 1，否则自旋没有意义，因为此时不可能有其他协程释放锁；</li><li>当前机器上至少存在一个正在运行的处理器 P 并且处理的运行队列为空；<br>可见自旋的条件是很苛刻的，简单说就是不忙的时候才会启用自旋。</li></ul><p><strong>自旋优势</strong><br>自旋的优势是更充分地利用 CPU，尽量避免协程切换。因为当前申请加锁的协程拥有 CPU，如果经过短时间的自旋可以获得锁，则当前写成可以继续运行，不必进入阻塞状态。  </p><p><strong>自旋劣势</strong><br>如果在自旋过程中获得锁，那么之前被阻塞的协程就无法获得。如果加锁的协程特别多，每次都通过自旋获取锁，则之前被阻塞的协程将很难获取锁。</p><h4 id="2-2-3-Mutex-模式"><a href="#2-2-3-Mutex-模式" class="headerlink" title="2.2.3 Mutex 模式"></a>2.2.3 Mutex 模式</h4><p>正常情况下，锁释放唤醒等待协程时，等待协程会和此时新到的协程以及处于自旋状态的协程一起竞争锁，因为需要进行上下文切换，新唤醒协程大概率争抢不过新协程以及自旋的协程，为了解决这种情况下阻塞队列中协程一直获取不到锁的问题，Mutex引入了模式的概念，分为正常模式和饥饿模式。  </p><p><strong>正常模式 Normal</strong>：<br>正常模式下，锁的等待者会按照先进先出的顺序获取锁。但是刚被唤起的协程与新创建的协程竞争时，大概率会获取不到锁，为了减少这种情况的出现，一旦 Goroutine 超过 1ms 没有获取到锁，它就会将当前互斥锁切换饥饿模式，防止部分 Goroutine 被饿死。 </p><blockquote><p>📌 引入饥饿模式的目的是保证互斥锁的公平性。  </p></blockquote><p><strong>饥饿模式 Starving</strong>：<br>饥饿模式中，互斥锁的所有权直接从解锁的Goroutine交给等待队列最前面的 Goroutine。新的 Goroutine 在该状态下不能获取锁、也不会进入自旋状态，它们只会在队列的末尾等待。如果一个 Goroutine 获得了互斥锁并且它在队列的末尾或者它等待的时间少于 1ms，那么当前的互斥锁就会切换回正常模式。<br>在Starving模式下，不会启动自旋过程，一旦有协程释放了锁，一定会唤醒协程，被唤醒的协程将成功获取锁，同时会把等待计数减 1。    </p><blockquote><p>📌  与饥饿模式相比，正常模式下的互斥锁能够提供更好地性能，饥饿模式的能避免 Goroutine 由于陷入等待无法获取锁而造成的长尾延时。 </p></blockquote><h4 id="2-2-4-Woken-状态"><a href="#2-2-4-Woken-状态" class="headerlink" title="2.2.4 Woken 状态"></a>2.2.4 Woken 状态</h4><p>Woken 状态用于加锁和解锁过程中的通信。比如，同一时刻，两个协程一个在加锁，一个在解锁，在加锁的协程可能在自旋过程中，此时把 Woken 标记为 1，用于通知解锁协程不必释放信号量，类似知会一下对方，不用释放了，我马上就拿到锁了。</p><h3 id="2-3-UnLock"><a href="#2-3-UnLock" class="headerlink" title="2.3 UnLock"></a>2.3 UnLock</h3><p>相比于加锁，解锁的逻辑简单许多，同样分为Fast path和Slow Path</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> Unlock() &#123;<br>    <span class="hljs-keyword">if</span> race.Enabled &#123;<br>        _ = m.state<br>        race.Release(unsafe.Pointer(m))<br>    &#125;<br><br>    <span class="hljs-comment">// Fast path: drop lock bit.</span><br>    <span class="hljs-built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">new</span> != <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-comment">// Outlined slow path to allow inlining the fast path.</span><br>        <span class="hljs-comment">// To hide unlockSlow during tracing we skip one extra frame when tracing GoUnblock.</span><br>        m.unlockSlow(<span class="hljs-built_in">new</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Fast Path：<ul><li>使用原子操作直接将状态移除锁标记，如果新状态为0，就成功释放锁；当前操作下说明没有等待协程也没有被唤醒协程。否则就进入Slow Path</li></ul></li><li>Slow Path：<ul><li>校验锁的合法性，避免锁被重复解锁</li><li>正常模式：如果互斥锁不存在等待者或者互斥锁的 mutexLocked、mutexStarving、mutexWoken 状态不是全部为 0，那么当前方法可以直接返回，不需要唤醒其他等待者；如果互斥锁存在等待者，会通过runtime_Semrelease唤醒等待者并移交锁的所有权；</li><li>饥饿模式：直接释放信号量将锁交给下一个等待者</li></ul></li></ul><h2 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="3. 应用场景"></a>3. 应用场景</h2><h3 id="3-1-保护共享资源"><a href="#3-1-保护共享资源" class="headerlink" title="3.1 保护共享资源"></a>3.1 保护共享资源</h3><p>在并发编程中，多个 goroutine 可能同时访问和修改同一个共享资源。为了确保数据的一致性和正确性，需要使用互斥锁来保护共享资源。例如，Map 并发读写时会出现 panic，我们可以使用 Mutex 来保护 Map 防止出现 panic。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> SafeMap <span class="hljs-keyword">struct</span> &#123;<br>    m    <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span><br>    lock sync.Mutex<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *SafeMap)</span></span> Put(key <span class="hljs-type">string</span>, value <span class="hljs-type">int</span>) &#123;<br>    s.lock.Lock()<br>    s.m[key] = value<br>    s.lock.Unlock()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *SafeMap)</span></span> Get(key <span class="hljs-type">string</span>) (<span class="hljs-type">int</span>, <span class="hljs-type">bool</span>) &#123;<br>    s.lock.Lock()<br>    value, ok := s.m[key]<br>    s.lock.Unlock()<br>    <span class="hljs-keyword">return</span> value, ok<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-同步Goroutine"><a href="#3-2-同步Goroutine" class="headerlink" title="3.2 同步Goroutine"></a>3.2 同步Goroutine</h3><p>在某些情况下，需要确保多个 goroutine 按照特定的顺序执行。可以使用互斥锁来实现这种同步。例如，一个 goroutine 需要等待另一个 goroutine 完成某个任务后才能继续执行。可以使用互斥锁来确保两个 goroutine 之间的同步。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> mutex sync.Mutex<br><span class="hljs-keyword">var</span> done <span class="hljs-type">bool</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker1</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Worker 1 is working...&quot;</span>)<br>    mutex.Lock()<br>    done = <span class="hljs-literal">true</span><br>    mutex.Unlock()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker2</span><span class="hljs-params">()</span></span> &#123;<br>    mutex.Lock()<br>    <span class="hljs-keyword">for</span> !done &#123;<br>        mutex.Unlock()<br>        mutex.Lock()<br>    &#125;<br>    fmt.Println(<span class="hljs-string">&quot;Worker 2 can start working...&quot;</span>)<br>    mutex.Unlock()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">go</span> worker1()<br>    <span class="hljs-keyword">go</span> worker2()<br><br>    time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-避免数据竞争"><a href="#3-3-避免数据竞争" class="headerlink" title="3.3 避免数据竞争"></a>3.3 避免数据竞争</h3><p>在并发编程中，如果多个 goroutine 同时访问和修改同一个变量，可能会导致数据竞争。使用互斥锁可以避免这种数据竞争。例如，一个 goroutine 正在读取一个变量的值，而另一个 goroutine 正在修改这个变量的值。使用互斥锁可以确保在读取和修改操作之间不会被其他 goroutine 干扰。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> data <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> mutex sync.Mutex<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reader</span><span class="hljs-params">()</span></span> &#123;<br>    mutex.Lock()<br>    fmt.Println(<span class="hljs-string">&quot;Data:&quot;</span>, data)<br>    mutex.Unlock()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writer</span><span class="hljs-params">()</span></span> &#123;<br>    mutex.Lock()<br>    data++<br>    mutex.Unlock()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>        wg.Add(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            <span class="hljs-keyword">defer</span> wg.Done()<br>            reader()<br>        &#125;()<br>        wg.Add(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            <span class="hljs-keyword">defer</span> wg.Done()<br>            writer()<br>        &#125;()<br>    &#125;<br>    wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a>4. 注意事项</h2><p>mutex使用过程简单，只有基本的加锁和解锁操作，但还是有一些点需要注意：</p><ol><li>Mutex 是可以在 goroutine A 中加锁，在 goroutine B 中解锁的，但是在实际使用中，尽量保证在同一个 goroutine 中加解锁。多次加锁而未解锁可能导致程序“卡死”（也被称为死锁）。尝试解锁一个未加锁的互斥锁可能引发程序崩溃（panic）。</li><li>Mutex 的加锁解锁基本都是成对出现，为了解决忘记解锁，可以使用 defer 语句，在加锁后直接 defer mutex.Unlock()；但是如果处理完临界区资源后还有很多耗时操作，为了尽早释放锁，不建议使用 defer，而是在处理完临界区资源后就调用 mutex.Unlock() 尽早释放锁。</li><li>Mutex 不能复制使用；Mutex 是有状态的，比如我们对一个 Mutex 加锁后，再进行复制操作，会把当前的加锁状态也给复制过去，基于加锁的 Mutex 再加锁肯定不会成功。进行复制操作可能听起来是一个比较低级的错误，但是无意间可能就会犯这种错误。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Counter <span class="hljs-keyword">struct</span> &#123;<br>    mutex sync.Mutex<br>    num   <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AddFunc</span><span class="hljs-params">(c Counter)</span></span> &#123;<br>    c.mutex.Lock()<br>    <span class="hljs-keyword">defer</span> c.mutex.Unlock()<br>    c.num++<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> counter Counter<br>    counter.mutex.Lock()<br>    <span class="hljs-keyword">defer</span> counter.mutex.Unlock()<br><br>    counter.num++<br>    <span class="hljs-comment">// Go是值传递，这里复制了 counter</span><br>    <span class="hljs-comment">// 此时 counter.mutex 是加锁状态，在 SomeFunc 无法再次加锁，就会死锁</span><br>    AddFunc(counter)<br>&#125;<br></code></pre></td></tr></table></figure></li><li>注意锁的粒度：锁的粒度指的就是临界区的大小，临界区的代码都是串行执行的。如果锁的粒度太大，可能会导致并发度降低；如果锁的粒度太小，可能会增加锁的管理开销。在设计并发程序时，应该根据实际情况选择合适的锁粒度。</li><li>避免死锁：在使用互斥锁时，要注意避免死锁的发生。死锁是指两个或多个 goroutine 相互等待对方释放锁，导致程序无法继续执行的情况。为了避免死锁，可以按照固定的顺序获取多个锁，或者使用超时机制来避免无限期地等待锁。</li></ol><h2 id="5-源码分析"><a href="#5-源码分析" class="headerlink" title="5. 源码分析"></a>5. 源码分析</h2><h3 id="5-1-Lock"><a href="#5-1-Lock" class="headerlink" title="5.1 Lock"></a>5.1 Lock</h3><p>Lock()加锁方法分为两部分：</p><ol><li>第一部分是 fast path，可以理解为快捷通道，如果当前锁没被占用，直接获得锁返回；否则需要进入 slow path。</li><li>slow path 判断各种条件去竞争锁，主要逻辑都在此处。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> lockSlow() &#123;<br>    <span class="hljs-keyword">var</span> waitStartTime <span class="hljs-type">int64</span><br>    starving := <span class="hljs-literal">false</span><br>    awoke := <span class="hljs-literal">false</span><br>    iter := <span class="hljs-number">0</span><br>    old := m.state<br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-comment">// 当锁被占用且不处于饥饿状态且可以执行自旋时，进入自旋逻辑</span><br>        <span class="hljs-keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;<br>            <span class="hljs-comment">// 如果当前awoker标志位为false，且等待者不等于0，把自己标记为唤醒的协程</span><br>            <span class="hljs-comment">// 该标记可以告诉Unclock操作不用再唤醒其他协程了(我已经在等锁了，你们不用醒了)</span><br>            <span class="hljs-keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="hljs-number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="hljs-number">0</span> &amp;&amp;<br>                atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;<br>                awoke = <span class="hljs-literal">true</span><br>            &#125;<br>            runtime_doSpin()<br>            iter++<br>            old = m.state<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-comment">// 走到这里说明退出了自旋，当前锁可能 没被占用 或者 锁处于饥饿状态 或者 自旋太多了</span><br>        <span class="hljs-comment">// new 代表当前goroutine基于当前状态接下来要设置的新状态</span><br>        <span class="hljs-built_in">new</span> := old<br>        <span class="hljs-comment">// 只要不是饥饿状态，就试图获取锁（如果是饥饿状态就乖乖去排队）</span><br>        <span class="hljs-keyword">if</span> old&amp;mutexStarving == <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-built_in">new</span> |= mutexLocked<br>        &#125;<br>        <span class="hljs-comment">// 锁被占用 或者 处于饥饿状态下，新增一个等待者</span><br>        <span class="hljs-keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-built_in">new</span> += <span class="hljs-number">1</span> &lt;&lt; mutexWaiterShift<br>        &#125;<br>        <br>        <span class="hljs-comment">// 当前goroutine已经进行饥饿状态了，且锁还没释放，需要把Mutex的状态改为饥饿</span><br>        <span class="hljs-keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-built_in">new</span> |= mutexStarving<br>        &#125;<br>        <span class="hljs-comment">// 如果是被唤醒的，把唤醒标志置0，表示外面没有被唤醒的goroutine了</span><br>        <span class="hljs-comment">// 这段的操作是为了下面的抢锁做准备，抢到就获取锁，抢不到就休眠，把唤醒标志设置为0</span><br>        <span class="hljs-keyword">if</span> awoke &#123;<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">new</span>&amp;mutexWoken == <span class="hljs-number">0</span> &#123;<br>                throw(<span class="hljs-string">&quot;sync: inconsistent mutex state&quot;</span>)<br>            &#125;<br>            <span class="hljs-built_in">new</span> &amp;^= mutexWoken<br>        &#125;<br>        <span class="hljs-comment">// 利用CAS尝试将锁的状态切切换成新的，就是上面的一坨操作</span><br>        <span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="hljs-built_in">new</span>) &#123;<br>            <span class="hljs-comment">// 状态切换成功，且在改状态前 锁未被占用 且 处于正常模式，那么就相当于获取到锁了</span><br>            <span class="hljs-keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="hljs-number">0</span> &#123;<br>                <span class="hljs-keyword">break</span> <span class="hljs-comment">// locked the mutex with CAS</span><br>            &#125;<br>            <br>            <span class="hljs-comment">// 走到这里说明锁没正常获取到</span><br>            <span class="hljs-comment">// 判断之前是否等待过，之前等待过的，再次排队要放在队首</span><br>            queueLifo := waitStartTime != <span class="hljs-number">0</span><br>            <span class="hljs-keyword">if</span> waitStartTime == <span class="hljs-number">0</span> &#123;<br>                waitStartTime = runtime_nanotime()<br>            &#125;<br>            <span class="hljs-comment">// 休眠等待信号量：之前排过队的老人，放到等待队列队首；新人放到队尾</span><br>            runtime_SemacquireMutex(&amp;m.sema, queueLifo, <span class="hljs-number">1</span>)<br>            <br>            <span class="hljs-comment">// 走到这里说明锁被释放，当前协程获取到信号量被唤醒</span><br>            <span class="hljs-comment">// 重新计算当前goroutine的饥饿状态</span><br>            starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs<br>            old = m.state<br>            <br>            <span class="hljs-comment">// 如果 state 饥饿标记为1，说明当前在饥饿模式，饥饿模式下被唤醒，已经获取到锁了；</span><br>            <span class="hljs-comment">// 饥饿状态下，释放锁没有更新等待者数量和饥饿标记，需要获得锁的goroutine去更新状态</span><br>            <span class="hljs-keyword">if</span> old&amp;mutexStarving != <span class="hljs-number">0</span> &#123;<br>                <span class="hljs-keyword">if</span> old&amp;(mutexLocked|mutexWoken) != <span class="hljs-number">0</span> || old&gt;&gt;mutexWaiterShift == <span class="hljs-number">0</span> &#123;<br>                    throw(<span class="hljs-string">&quot;sync: inconsistent mutex state&quot;</span>)<br>                &#125;<br>                <span class="hljs-comment">// 加锁，减去一个等待者</span><br>                delta := <span class="hljs-type">int32</span>(mutexLocked - <span class="hljs-number">1</span>&lt;&lt;mutexWaiterShift)<br>                <span class="hljs-keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="hljs-number">1</span> &#123;<br>                    <span class="hljs-comment">// 如果当前的 goroutine 非饥饿，或者等待者只有一个（也就是只有当前goroutine，等待队列空了），</span><br>                    <span class="hljs-comment">// 可以取消饥饿状态，进入正常状态</span><br>                    delta -= mutexStarving<br>                &#125;<br>                atomic.AddInt32(&amp;m.state, delta)<br>                <span class="hljs-keyword">break</span><br>            &#125;<br>            <span class="hljs-comment">// 非饥饿状态被唤醒，标记为awoke，重置自旋迭代次数，继续去进行下一轮的抢锁</span><br>            awoke = <span class="hljs-literal">true</span><br>            iter = <span class="hljs-number">0</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            old = m.state<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> race.Enabled &#123;<br>        race.Acquire(unsafe.Pointer(m))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>Mutex本身是多个go协程的共享变量，不同的go协程同时执行该函数，函数内临时变量是go协程自己的状态。每次执行因为状态不同处在函数执行的不同阶段，直到mutex状态改变。</li></ol><h3 id="5-2-UnLock"><a href="#5-2-UnLock" class="headerlink" title="5.2 UnLock"></a>5.2 UnLock</h3><p>Unlock()解锁方法也分为两部分：</p><ol><li>第一部分是 fast path，可以理解为快捷通道，直接把锁状态位清除，如果此时系统状态恢复到初始状态，说明没有 goroutine 在抢锁等锁，直接返回，否则进入 slow path；</li><li>slow path 会根据是否为饥饿状态，做出不一样的反应：<ol><li>正常状态：唤醒一个 goroutine 去抢锁，等待者数量减一，并将唤醒状态置为 1；</li><li>饥饿状态：直接唤醒等待队列队首的 goroutine，锁的所有权直接移交（修改等待者数量、是否取消饥饿标记，由唤醒的 goroutine 去处理）。</li></ol></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> unlockSlow(<span class="hljs-built_in">new</span> <span class="hljs-type">int32</span>) &#123;<br>    <span class="hljs-comment">// 校验是否对已解锁的mutex再次解锁</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="hljs-number">0</span> &#123;<br>        fatal(<span class="hljs-string">&quot;sync: unlock of unlocked mutex&quot;</span>)<br>    &#125;<br>    <br>    <span class="hljs-comment">// 正常模式，非饥饿</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">new</span>&amp;mutexStarving == <span class="hljs-number">0</span> &#123;<br>        old := <span class="hljs-built_in">new</span><br>        <span class="hljs-keyword">for</span> &#123;<br>            <span class="hljs-comment">// 如果没有等待者，或者已经存在被唤醒的协程，或者已经有协程获得了锁，无需唤醒协程，直接交接返回即可</span><br>            <span class="hljs-keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="hljs-number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="hljs-number">0</span> &#123;<br>                <span class="hljs-keyword">return</span><br>            &#125;<br>            <span class="hljs-comment">// 减去一个等待者，并且将 唤醒标记 置为 1</span><br>            <span class="hljs-built_in">new</span> = (old - <span class="hljs-number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken<br>            <span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="hljs-built_in">new</span>) &#123;<br>                runtime_Semrelease(&amp;m.sema, <span class="hljs-literal">false</span>, <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span><br>            &#125;<br>            old = m.state<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 饥饿模式下，直接释放信号量，将锁的所有权，交给等待队列的第一个等待者</span><br>        runtime_Semrelease(&amp;m.sema, <span class="hljs-literal">true</span>, <span class="hljs-number">1</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-参考资料"><a href="#6-参考资料" class="headerlink" title="6. 参考资料"></a>6. 参考资料</h2><ul><li><a href="https://juejin.cn/post/7146236976399089700">初见 Go Mutex</a></li><li><a href="https://juejin.cn/post/7086756462059323429">Golang Mutex 原理解析</a></li><li><a href="https://www.lixueduan.com/posts/go/sync-mutex/">Go语言之sync.Mutex 源码分析</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
      <category>互斥锁与原子操作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>Mutex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang并发赋值的安全性分析</title>
    <link href="/2024/09/21/golang%E5%B9%B6%E5%8F%91%E8%B5%8B%E5%80%BC%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/"/>
    <url>/2024/09/21/golang%E5%B9%B6%E5%8F%91%E8%B5%8B%E5%80%BC%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<blockquote><p>声明：本文非原创，主要参考恋喵大鲤鱼的博客：<a href="https://blog.csdn.net/K346K346/article/details/115099353">https://blog.csdn.net/K346K346/article/details/115099353</a> ，稍微做些修改。</p></blockquote><span id="more"></span>  <h2 id="1-什么是并发安全"><a href="#1-什么是并发安全" class="headerlink" title="1. 什么是并发安全"></a>1. 什么是并发安全</h2><p>并发安全就是程序在并发情况下执行的结果是正确的。<br>比如对一个变量简单的自增操作count++，在非并发下很好理解，而在并发情况下却容易出现预期之外的结果，这样的代码就是非并发安全的。<br>因为count++其实是分成两步执行的，当分成了两步执行，那么在并发时多协程就可以趁着这个时间间隙作怪。<br>比如a、b两个协程同时执行执行count++，正常情况下应该返回3，但实际返回了2</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">count:= <span class="hljs-number">1</span><br>a &gt; 读取count : <span class="hljs-number">1</span><br>b &gt; 读取count : <span class="hljs-number">1</span><br>a &gt; 计算count+<span class="hljs-number">1</span> : <span class="hljs-number">2</span><br>b &gt; 计算count+<span class="hljs-number">1</span> : <span class="hljs-number">2</span><br>a &gt; 赋值count : <span class="hljs-number">2</span><br>b &gt; 赋值count : <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="2-Struct并发安全吗"><a href="#2-Struct并发安全吗" class="headerlink" title="2. Struct并发安全吗"></a>2. Struct并发安全吗</h2><p>💡 结论：  </p><p><strong>多字段结构体并发赋值不安全，但是单字段结构体并发赋值是安全的。</strong></p><h3 id="2-1-现象"><a href="#2-1-现象" class="headerlink" title="2.1 现象"></a>2.1 现象</h3><p>对简单的一个变量进行自增都会出现并发问题，那对一个结构体赋值会不会出现问题呢。基于此，设计一个两个字段的结构体，高频的进行并发赋值并观察结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Test <span class="hljs-keyword">struct</span> &#123;<br>X <span class="hljs-type">int</span><br>Y <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> g Test<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++ &#123;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><span class="hljs-comment">// 协程 1</span><br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>g = Test&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>&#125;()<br><br><span class="hljs-comment">// 协程 2</span><br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>g = Test&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br>&#125;()<br>wg.Wait()<br><br><span class="hljs-comment">// 赋值异常判断</span><br><span class="hljs-keyword">if</span> !((g.X == <span class="hljs-number">1</span> &amp;&amp; g.Y == <span class="hljs-number">2</span>) || (g.X == <span class="hljs-number">3</span> &amp;&amp; g.Y == <span class="hljs-number">4</span>)) &#123;<br>fmt.Printf(<span class="hljs-string">&quot;concurrent assignment error, i=%v g=%+v\n&quot;</span>, i, g)<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行此段代码，发现偶尔出现以下报错：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">concurrent assignment <span class="hljs-type">error</span>, i=<span class="hljs-number">199242</span> g=&#123;X:<span class="hljs-number">1</span> Y:<span class="hljs-number">4</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-分析"><a href="#2-2-分析" class="headerlink" title="2.2 分析"></a>2.2 分析</h3><p>对含有多个字段的结构体进行并发赋值时，可能会出现数据错乱的问题：协程1赋值了X字段，而协程2赋值了Y字段。<br>原因：struct进行字段赋值时并不是原子操作，各个字段的赋值操作是独立进行的，在并发的情况下会出现异常。</p><p>扩展：如果一个struct只有一个字段，那并发赋值时就是安全的。</p><h2 id="3-如何保证并发安全"><a href="#3-如何保证并发安全" class="headerlink" title="3. 如何保证并发安全"></a>3. 如何保证并发安全</h2><p>Golang提供一个原子类型的atomic.Value来保证并发赋值安全</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// A Value provides an atomic load and store of a consistently typed value.</span><br><span class="hljs-comment">// The zero value for a Value returns nil from Load.</span><br><span class="hljs-comment">// Once Store has been called, a Value must not be copied.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// A Value must not be copied after first use.</span><br><span class="hljs-keyword">type</span> Value <span class="hljs-keyword">struct</span> &#123;<br>v <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用样例：通过Load和Store方法进行数据读取和存储，保证并发赋值安全</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> v atomic.Value<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++ &#123;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><span class="hljs-comment">// 协程 1</span><br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>v.Store(Test&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;)<br>&#125;()<br><br><span class="hljs-comment">// 协程 2</span><br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>v.Store(Test&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;)<br>&#125;()<br>wg.Wait()<br><br><span class="hljs-comment">// 赋值异常判断</span><br>g := v.Load().(Test)<br><span class="hljs-keyword">if</span> (g.X == <span class="hljs-number">1</span> &amp;&amp; g.Y == <span class="hljs-number">2</span>) || (g.X == <span class="hljs-number">3</span> &amp;&amp; g.Y == <span class="hljs-number">4</span>) &#123;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;concurrent assignment error, i=%v g=%+v&quot;</span>, i, g)<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-数据类型分析"><a href="#4-数据类型分析" class="headerlink" title="4. 数据类型分析"></a>4. 数据类型分析</h2><h3 id="4-1-基本数据类型"><a href="#4-1-基本数据类型" class="headerlink" title="4.1 基本数据类型"></a>4.1 基本数据类型</h3><p>💡 结论：</p><ul><li>字节型、布尔型、整形、浮点型、字符型：并发安全</li><li>复数型：不安全</li><li>字符串：不安全</li><li>底层结构为struct类型的数据，一般并发赋值时都不安全；但不安全不代表一定会发生错误；</li></ul><h4 id="4-1-1-字节型、布尔型、整型、浮点型、字符型"><a href="#4-1-1-字节型、布尔型、整型、浮点型、字符型" class="headerlink" title="4.1.1 字节型、布尔型、整型、浮点型、字符型"></a>4.1.1 字节型、布尔型、整型、浮点型、字符型</h4><p>由于字节型、布尔型、整型、浮点型、字符型的位宽不会超过 64 位，在 64 位的指令集架构中可以由一条机器指令完成，不存在被细分为更小的操作单位，所以这些类型的并发赋值是安全的。<br>以浮点型为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> g <span class="hljs-type">float64</span><br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++ &#123;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><span class="hljs-comment">// 协程 1</span><br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>g = <span class="hljs-number">1.1</span><br>&#125;()<br><br><span class="hljs-comment">// 协程 2</span><br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>g = <span class="hljs-number">2.2</span><br>&#125;()<br>wg.Wait()<br><br><span class="hljs-comment">// 赋值异常判断</span><br><span class="hljs-keyword">if</span> g != <span class="hljs-number">1.1</span> &amp;&amp; g != <span class="hljs-number">2.2</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;concurrent assignment error, i=%v g=%+v&quot;</span>, i, g)<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-1-2-复数型"><a href="#4-1-2-复数型" class="headerlink" title="4.1.2 复数型"></a>4.1.2 复数型</h4><p>复数型分为实部和虚部两个部分，二者的赋值是分开的，按照上面的分析说明并发赋值非安全的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> g <span class="hljs-type">complex64</span><br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++ &#123;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><span class="hljs-comment">// 协程 1</span><br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>g = <span class="hljs-built_in">complex</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>&#125;()<br><br><span class="hljs-comment">// 协程 2</span><br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>g = <span class="hljs-built_in">complex</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br>&#125;()<br>wg.Wait()<br><br><span class="hljs-comment">// 赋值异常判断</span><br><span class="hljs-keyword">if</span> g != <span class="hljs-built_in">complex</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) &amp;&amp; g != <span class="hljs-built_in">complex</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>) &#123;<br>fmt.Printf(<span class="hljs-string">&quot;concurrent assignment error, i=%v g=%+v \n&quot;</span>, i, g)<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>偶尔会得到如下的效果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">concurrent assignment <span class="hljs-type">error</span>, i=<span class="hljs-number">466735</span> g=(<span class="hljs-number">1</span>+<span class="hljs-number">4i</span>)<br></code></pre></td></tr></table></figure><h4 id="4-1-3-字符串"><a href="#4-1-3-字符串" class="headerlink" title="4.1.3 字符串"></a>4.1.3 字符串</h4><p>在Go中，string本质上是一个只读的字节数组切片，他有几个重要特点：</p><ul><li><p>string可以为空，长度为0但不是nil，而是””</p></li><li><p>string对象不可修改，无法通过索引直接修改字符串内容，需要修改时可以通过[]byte数组转换等方式实现。通常情况下，如果要修改一个字符串，必须创建一个新的字符串。<br>在源码包src&#x2F;runtime&#x2F;string.go我们可以找到 string 的底层数据结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> stringStruct <span class="hljs-keyword">struct</span> &#123;<br>str unsafe.Pointer <span class="hljs-comment">// str为字符串首地址 </span><br><span class="hljs-built_in">len</span> <span class="hljs-type">int</span>            <span class="hljs-comment">// len为字符串的长度</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因为string的底层结构时一个多字段的struct，所以并发赋值是不安全的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span><br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++ &#123;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><span class="hljs-comment">// 协程 1</span><br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>s = <span class="hljs-string">&quot;ab&quot;</span><br>&#125;()<br><br><span class="hljs-comment">// 协程 2</span><br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>s = <span class="hljs-string">&quot;cde&quot;</span><br>&#125;()<br>wg.Wait()<br><br><span class="hljs-comment">// 赋值异常判断</span><br><span class="hljs-keyword">if</span> s != <span class="hljs-string">&quot;ab&quot;</span> &amp;&amp; s != <span class="hljs-string">&quot;cde&quot;</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;concurrent assignment error, i=%v s=%v\n&quot;</span>, i, s)<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>偶现如下结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">concurrent assignment <span class="hljs-type">error</span>, i=<span class="hljs-number">348275</span> s=cd<br></code></pre></td></tr></table></figure><p>📌 注意：</p></li><li><p>底层结构是struct的类型，一般情况下并发赋值都是不安全的</p></li><li><p>并发赋值不安全不代表一定会出错，只是有可能出错；比如上面的string赋值中，如果并发赋两个床度相同的变量，可以等同退化为只有一个字段的结构体，变成并发安全的场景。</p></li></ul><h3 id="4-2-复合数据类型"><a href="#4-2-复合数据类型" class="headerlink" title="4.2 复合数据类型"></a>4.2 复合数据类型</h3><p>💡 结论：</p><ul><li>指针：安全</li><li>函数：安全</li><li>数组、切片、映射、通道、接口：不安全</li><li>底层结构为struct类型的数据，一般并发赋值时都不安全；但不安全不代表一定会发生错误；</li></ul><h4 id="4-2-1-指针"><a href="#4-2-1-指针" class="headerlink" title="4.2.1 指针"></a>4.2.1 指针</h4><p>指针是一个变量，它保存的是另一个变量的内存地址。指针的零值为nil。</p><p>因为指针存储的是内存地址，所以位宽为 32位（x86平台）或 64位（x64平台），赋值操作由一个机器指令即可完成，不会被中断，所以也不会出现并发赋值不安全的情况。<br>这在上面讨论 string 等长不同值并发赋值时，已经验证没有问题。</p><h4 id="4-2-2-函数"><a href="#4-2-2-函数" class="headerlink" title="4.2.2 函数"></a>4.2.2 函数</h4><p>Go中，函数可以像值一样进行传递，用户也可以定义函数类型。<br>常规的函数定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">some_func_name</span><span class="hljs-params">(arguments)</span></span> return_values<br></code></pre></td></tr></table></figure><p>定义一个函数类型时，去掉函数名即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(arguments)</span></span> return_values<br></code></pre></td></tr></table></figure><p>对函数类型进行赋值时，实际赋的是函数地址，一条机器指令即可完成，所以并发赋值是安全的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> g MyFunc<br><br><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> ; i &lt; <span class="hljs-number">10000000</span>; i++ &#123;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><span class="hljs-comment">// 协程 1</span><br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>g = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> x + y<br>&#125;<br>&#125;()<br><br><span class="hljs-comment">// 协程 2</span><br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>g = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> x - y<br>&#125;<br>&#125;()<br>wg.Wait()<br><br><span class="hljs-comment">// 赋值异常判断</span><br><span class="hljs-keyword">if</span> !(g(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) == <span class="hljs-number">2</span> || g(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123;<br>fmt.Printf(<span class="hljs-string">&quot;concurrent assignment error, i=%v g=%+v&quot;</span>, i, g)<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> i == <span class="hljs-number">10000000</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;no error&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们使用unsafe.Sizeof()可以查看函数类型的宽度（字节）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Add <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> add Add<br>fmt.Println(unsafe.Sizeof(add)) <br><span class="hljs-comment">// 输出 8</span><br></code></pre></td></tr></table></figure><h4 id="4-2-3-数组、切片、映射、通道、接口"><a href="#4-2-3-数组、切片、映射、通道、接口" class="headerlink" title="4.2.3 数组、切片、映射、通道、接口"></a>4.2.3 数组、切片、映射、通道、接口</h4><p>数组、切片、映射、通道、接口，这些复合类型，除了数组，其他底层数据结构都是 struct，所以并发都不是安全的，当然数组并发赋值也是不安全的。</p><ul><li>数组<br>数组是相同类型值的集合，数组的长度是其类型的一部分。数组赋值和传参都会拷贝整个数组的数据，所以数组不是引用类型；<br>数组的底层数据结构就是其本身，是一个相同类型不同值的顺序排列。所以如果数组位宽不大于 64 位且是 2 的整数次幂（8，16，32，64），那么其并发赋值是安全的，只不过大部分情况并非如此，所以其并发赋值是不安全的。<br>以字节数组为例，当位宽不超过64时：并发赋值安全<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> g [<span class="hljs-number">4</span>]<span class="hljs-type">byte</span><br><br><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> ; i &lt; <span class="hljs-number">10000000</span>; i++ &#123;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><span class="hljs-comment">// 协程 1</span><br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>g = [...]<span class="hljs-type">byte</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br>&#125;()<br><br><span class="hljs-comment">// 协程 2</span><br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>g = [...]<span class="hljs-type">byte</span>&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;<br>&#125;()<br>wg.Wait()<br><br><span class="hljs-comment">// 赋值异常判断</span><br><span class="hljs-keyword">if</span> !(g == [...]<span class="hljs-type">byte</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125; || g == [...]<span class="hljs-type">byte</span>&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;) &#123;<br>fmt.Printf(<span class="hljs-string">&quot;concurrent assignment error, i=%v g=%+v&quot;</span>, i, g)<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> i == <span class="hljs-number">10000000</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;no error&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>可以看到，位宽为 32 位的数组 [4]byte，虽然有四个元素但是赋值时由一条机器指令完成，所以也是原子操作。</li></ul><p>如果把字节数组的长度换成下面这样子，即使没有超过 64 位，也需要多条指令完成赋值，因为 CPU 中并没有这样位宽的寄存器，需要拆分为多条指令来完成。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">[<span class="hljs-number">3</span>]<span class="hljs-type">byte</span><br>[<span class="hljs-number">5</span>]<span class="hljs-type">byte</span><br>[<span class="hljs-number">7</span>]<span class="hljs-type">byte</span><br></code></pre></td></tr></table></figure><ul><li>切片<br>slice 也是相同类型值的集合，只不过切片是动态调整大小的，内部是对数组的引用，相当于动态数组。如上所述，数组的大小是固定的，因此切片为数组提供了更灵活的接口。<br>切片是一种引用类型，它内部由三个字段表示：</li><li>数组地址</li><li>数组长度</li><li>容量大小<br>在源码包src&#x2F;runtime&#x2F;slice.go我们可以找到切片的底层数据结构：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> slice <span class="hljs-keyword">struct</span> &#123;<br>array unsafe.Pointer<br><span class="hljs-built_in">len</span>   <span class="hljs-type">int</span><br><span class="hljs-built_in">cap</span>   <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure>因为其是一个 struct，所以并发赋值是不安全的.</li><li>映射<br>map是内置的k-v数据结构，是一个同种类型的无序组，内部元素可以通过唯一键进行索引，map的底层也是一个结构体，定义位于src&#x2F;runtime&#x2F;map.go。对map的并发读写会引起panic<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// A header for a Go map.</span><br><span class="hljs-keyword">type</span> hmap <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go.</span><br><span class="hljs-comment">// Make sure this stays in sync with the compiler&#x27;s definition.</span><br>count     <span class="hljs-type">int</span> <span class="hljs-comment">// # live cells == size of map.  Must be first (used by len() builtin)</span><br>flags     <span class="hljs-type">uint8</span><br>B         <span class="hljs-type">uint8</span>  <span class="hljs-comment">// log_2 of # of buckets (can hold up to loadFactor * 2^B items)</span><br>noverflow <span class="hljs-type">uint16</span> <span class="hljs-comment">// approximate number of overflow buckets; see incrnoverflow for details</span><br>hash0     <span class="hljs-type">uint32</span> <span class="hljs-comment">// hash seed</span><br><br>buckets    unsafe.Pointer <span class="hljs-comment">// array of 2^B Buckets. may be nil if count==0.</span><br>oldbuckets unsafe.Pointer <span class="hljs-comment">// previous bucket array of half the size, non-nil only when growing</span><br>nevacuate  <span class="hljs-type">uintptr</span>        <span class="hljs-comment">// progress counter for evacuation (buckets less than this have been evacuated)</span><br><br>extra *mapextra <span class="hljs-comment">// optional fields</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>通道<br>channel 在 goroutine 之间提供同步和通信。可以将其视为 goroutines 通过其发送值和接收值的管道。操作符&lt;-用于发送或接收数据，箭头方向指定数据流的方向。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">ch &lt;- val    <span class="hljs-comment">// Sending a value present in var variable to channel</span><br>val := &lt;-cha<span class="hljs-comment">// Receive a value from  the channel and assign it to val variable</span><br></code></pre></td></tr></table></figure>channel作为数据同步的通道，他在数据读取和发送的过程中，channel 是并发安全的。多个 goroutine 可以安全地从同一个 channel 发送或接收数据，而不需要使用额外的同步机制（如锁）。</li></ul><p>本文讨论的是对象赋值的安全性，即将一个channel赋值给另外一个channel，这个操作一般不会出现，但是如果一定要进行分析的话，这种操作是并发非安全的，因为它的底层也是一个struct。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> hchan <span class="hljs-keyword">struct</span> &#123;<br>qcount   <span class="hljs-type">uint</span>           <span class="hljs-comment">// total data in the queue</span><br>dataqsiz <span class="hljs-type">uint</span>           <span class="hljs-comment">// size of the circular queue</span><br>buf      unsafe.Pointer <span class="hljs-comment">// points to an array of dataqsiz elements</span><br>elemsize <span class="hljs-type">uint16</span><br>closed   <span class="hljs-type">uint32</span><br>elemtype *_type <span class="hljs-comment">// element type</span><br>sendx    <span class="hljs-type">uint</span>   <span class="hljs-comment">// send index</span><br>recvx    <span class="hljs-type">uint</span>   <span class="hljs-comment">// receive index</span><br>recvq    waitq  <span class="hljs-comment">// list of recv waiters</span><br>sendq    waitq  <span class="hljs-comment">// list of send waiters</span><br><br><span class="hljs-comment">// lock protects all fields in hchan, as well as several</span><br><span class="hljs-comment">// fields in sudogs blocked on this channel.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Do not change another G&#x27;s status while holding this lock</span><br><span class="hljs-comment">// (in particular, do not ready a G), as this can deadlock</span><br><span class="hljs-comment">// with stack shrinking.</span><br>lock mutex<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>接口<br>接口是Go中的一个类型，一般它是一组方法的集合。任意实现该接口所有方法的类型都属于该接口类型。接口的零值为nil。<br>定义一个接口类型的变量后，如果有具体类型A实现了该接口的方法，则可以将任何A类型的值赋值给这个变量。<br>Go中有一个特殊的情况，就是空接口，它不包含任何方法。所以，默认情况下，任何具体类型都实现空接口。</li></ul><ol><li>空接口的底层结构为runtime.eface</li><li>非空接口的底层结构为runtime.iface<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> eface <span class="hljs-keyword">struct</span> &#123; <span class="hljs-comment">// 16 字节</span><br>_type *_type<br>data  unsafe.Pointer<br>&#125;<br><br><span class="hljs-keyword">type</span> iface <span class="hljs-keyword">struct</span> &#123; <span class="hljs-comment">// 16 字节</span><br>tab  *itab<br>data unsafe.Pointer<br>&#125;<br></code></pre></td></tr></table></figure>由接口底层结构可以看到：</li></ol><ul><li>接口底层数据结构包含两个字段，相互赋值时如果是相同具体类型不同值并发赋给一个接口，那么只有一个字段 data 的值是不同的，此时退化成指针的并发赋值，所以是安全的。但如果是不同具体类型的值并发赋给一个接口，那么并引发 panic。</li><li>不同类型验证代码如下：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> g <span class="hljs-keyword">interface</span>&#123;&#125;<br><br><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> ; i &lt; <span class="hljs-number">10000000</span>; i++ &#123;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><span class="hljs-comment">// 协程 1</span><br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>g = <span class="hljs-string">&quot;a&quot;</span><br>&#125;()<br><br><span class="hljs-comment">// 协程 2</span><br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>g = <span class="hljs-number">2</span><br>&#125;()<br>wg.Wait()<br><br><span class="hljs-comment">// 赋值异常判断</span><br>v1, _ := g.(<span class="hljs-type">string</span>)<br>v2, _ := g.(<span class="hljs-type">int</span>)<br><span class="hljs-keyword">if</span> v1 != <span class="hljs-string">&quot;a&quot;</span> &amp;&amp; v2 != <span class="hljs-number">2</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;concurrent assignment error, i=%v g=%v &quot;</span>, i, g)<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> i == <span class="hljs-number">10000000</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;no error&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>执行时会报错：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">anic: runtime <span class="hljs-type">error</span>: invalid memory address or <span class="hljs-literal">nil</span> pointer dereference<br>[signal SIGSEGV: segmentation violation code=<span class="hljs-number">0x2</span> addr=<span class="hljs-number">0x2</span> pc=<span class="hljs-number">0x10297598c</span>]<br></code></pre></td></tr></table></figure>更多关于interface的分析，参考：《Golang Interface解析》</li></ul><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p>Go 多协程并发的场景无处不在，并发对同一变量的赋值也是经常遇到。本文尝试探讨了 Go 中所有类型并发赋值的安全性。</p><ul><li>由一条机器指令完成赋值的类型并发赋值是安全的，这些类型有：字节型，布尔型、整型、浮点型、字符型、指针、函数。</li><li>数组由一个或多个元素组成，大部分情况并发不安全。注意：当位宽不大于 64 位且是 2 的整数次幂（8，16，32，64），那么其并发赋值是安全的。</li><li>struct 或底层是 struct 的类型并发赋值大部分情况并发不安全，这些类型有：复数、字符串、 数组、切片、映射、通道、接口。注意：当 struct 赋值时退化为单个字段由一个机器指令完成赋值时，并发赋值又是安全的。这种情况有：<ul><li>实部或虚部相同的复数的并发赋值；</li><li>等长字符串的并发赋值；</li><li>同长度同容量切片的并发赋值；</li><li>同一种具体类型不同值并发赋给接口。</li></ul></li></ul><p>原文链接：<a href="https://blog.csdn.net/K346K346/article/details/115099353">https://blog.csdn.net/K346K346/article/details/115099353</a></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发安全</tag>
      
      <tag>并发赋值</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang Channels 解析</title>
    <link href="/2024/09/08/golang-channels/"/>
    <url>/2024/09/08/golang-channels/</url>
    
    <content type="html"><![CDATA[<p>Channel是一个先进先出的管道，它提供了一种同步的机制，确保数据发送和接收之间的顺序以及正确性。通过使用channel，我们可以避免在多个协程之间共享数据时出现的竞争条件和其他并发问题。</p><span id="more"></span>  <h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>在Go语言中，一种广为人知的并发编程模型是CSP(Communicating Sequential Processes)模型，提倡通过通信共享内存，而不是通过共享内存来通信。而channel正是这样一种特殊的类型，用于在并发编程中实现不同协程之间的通信和同步。  </p><p>Channel是一个先进先出的管道，它提供了一种同步的机制，确保数据发送和接收之间的顺序以及正确性。通过使用channel，我们可以避免在多个协程之间共享数据时出现的竞争条件和其他并发问题。<br><img src="/img/golang-channels/1.png"><br>通道类型的值本身是并发安全的，这也是 Go 语言自带的、唯一一个可以满足并发安全性的类型</p><h2 id="2-基本特性"><a href="#2-基本特性" class="headerlink" title="2. 基本特性"></a>2. 基本特性</h2><p>在Go中，channel的关键字是chan，通过箭头表示数据流向←，具有以下基本特性：</p><ul><li>Channel是类型相关的，特定类型的Channel只能存放特定类型的数据。</li><li>channel分缓冲型(buffered)和非缓冲型(unbuffered），非缓冲型的size是0，缓冲型的size是缓冲区的大小。</li><li>缓冲型通道读写经过buffer，非缓冲型通道的数据交互不经过通道，直接通过内存写传递。</li><li>channel分单向和双向，单向的意思是只能读（或写），双向是既能读也能写。</li><li>channel满时“写”会阻塞，channel空时“读”会阻塞。</li></ul><h3 id="2-1-无缓冲通道"><a href="#2-1-无缓冲通道" class="headerlink" title="2.1 无缓冲通道"></a>2.1 无缓冲通道</h3><p>无缓冲的 channel（unbuffered channel），其缓冲区大小则默认为 0。在功能上其接受者会阻塞等待并阻塞应用程序，直至收到通信和接收到数据。<br><img src="/img/golang-channels/2.png"><br>无缓冲通道在处理时，必须同时有发送者和接收者，不然就会阻塞。如下的案例中，如果先在main中往ch写数据，运行时就会抛错：fatal error: all goroutines are asleep - deadlock!</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-comment">// 启用goroutine从通道接收值</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>ret := &lt;-ch<br>fmt.Println(<span class="hljs-string">&quot;接收成功: &quot;</span>, ret)<br>&#125;()<br><br>ch &lt;- <span class="hljs-number">10</span><br>fmt.Println(<span class="hljs-string">&quot;发送成功&quot;</span>)<br>time.Sleep(time.Second)<br>&#125;<br><span class="hljs-comment">// 发送成功</span><br><span class="hljs-comment">// 接收成功:  10</span><br></code></pre></td></tr></table></figure><h3 id="2-2-有缓冲通道"><a href="#2-2-有缓冲通道" class="headerlink" title="2.2 有缓冲通道"></a>2.2 有缓冲通道</h3><p><img src="/img/golang-channels/3.png"><br>解决无缓冲通道（阻塞）死锁的问题，就是使用有缓冲的通道。通过缓存的使用，可以尽量避免阻塞，提供应用的性能。只要通道的容量大于零，那么该通道就是有缓冲的通道，通道的容量表示通道中能存放元素的数量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// 创建一个容量为 1 的有缓冲区的通道</span><br><br>ch &lt;- <span class="hljs-number">10</span><br>fmt.Println(<span class="hljs-string">&quot;发送成功&quot;</span>)<br><br>ret := &lt;-ch<br>fmt.Println(<span class="hljs-string">&quot;接收成功: &quot;</span>, ret)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-单向通道"><a href="#2-3-单向通道" class="headerlink" title="2.3 单向通道"></a>2.3 单向通道</h3><p>有时候我们将通道作为参数在多个函数间传递时，可以根据不同的任务类型对通道进行限制，比如限制通道在函数中只能发送或只能接收。<br>注意：发送和接收是针对channel而言，比如发送是指向channel发送数据，接收是指从channel接收数据，可以通过箭头的数据流向来标识类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span>) <span class="hljs-comment">// 单向发送通道</span><br>ch := <span class="hljs-built_in">make</span>(&lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>) <span class="hljs-comment">// 单向接收通道</span><br></code></pre></td></tr></table></figure><p>如下一个场景中，首先往一个单向发送通道写入数据，然后经中转将数据写入另一个通道，最后再以单向接收通道的形式读出数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 单向发送通道，将数据写入channel</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">a</span><span class="hljs-params">(in <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>in &lt;- i<br>&#125;<br><span class="hljs-built_in">close</span>(in)<br>&#125;<br><br><span class="hljs-comment">// 单向发送 in 通道， 单向接收 out 通道，将数据从一个channel写入另一个channel</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">a2b</span><span class="hljs-params">(in <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span>, out &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> out &#123;<br>in &lt;- i * i<br>&#125;<br><span class="hljs-built_in">close</span>(in)<br>&#125;<br><br><span class="hljs-comment">// 单向接收通道，从channel读出数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">b</span><span class="hljs-params">(out &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> out &#123;<br>fmt.Println(i)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>in := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>out := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">go</span> a(in)<br><span class="hljs-keyword">go</span> a2b(out, in)<br>b(out)<br>&#125;<br><span class="hljs-comment">// 0 1 4 9 16 25 36 49 64 81</span><br></code></pre></td></tr></table></figure><h3 id="2-4-Channel的遍历"><a href="#2-4-Channel的遍历" class="headerlink" title="2.4 Channel的遍历"></a>2.4 Channel的遍历</h3><p>如何优雅的从通道中获取数据，Go支持以下几种方式：</p><ul><li><code>for range</code>循环<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">3</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i = i + <span class="hljs-number">1</span> &#123;<br>c &lt;- i<br>&#125;<br><span class="hljs-built_in">close</span>(c)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> c &#123;<br>fmt.Println(i)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;Finished&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 0</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// Finished</span><br></code></pre></td></tr></table></figure>需要注意的是，在遍历时如果channel 没有关闭，那么会一直等待下去，出现 deadlock 的错误；如果在遍历时channel已经关闭，那么在遍历完数据后自动退出遍历。也就是说，for range 的遍历方式是阻塞型的遍历方式。</li><li><code>for &#123;&#125;</code>死循环<br>通过for{} 死循环+通道关闭判断的方式来进行取值<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i = i + <span class="hljs-number">1</span> &#123;<br>c &lt;- i<br>&#125;<br><span class="hljs-built_in">close</span>(c)<br>&#125;()<br><br><span class="hljs-keyword">for</span> &#123;<br>i, ok := &lt;-c <span class="hljs-comment">// 通道关闭后再取值ok=false</span><br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>fmt.Println(i)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;Finished&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 0</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// Finished</span><br></code></pre></td></tr></table></figure></li><li><code>for select &#123;&#125;</code>操作<br>select可以支持一组操作处理，通过case语句标识不同的处理场景。如果有多个case满足条件，则go会随机选择其中一个执行，如果没有符合条件的case，则会选择default语句处理。注意：如果没有default语句且没有满足的条件时，select语句会一直阻塞，一般通过select + default 避免阻塞问题.<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fibonacci</span><span class="hljs-params">(c, quit <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br>x, y := <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> c &lt;- x:<br>x, y = y, x+y<br><span class="hljs-keyword">case</span> &lt;-quit:<br>fmt.Println(<span class="hljs-string">&quot;quit&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>quit := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;<br>fmt.Println(&lt;-c)<br>&#125;<br>quit &lt;- <span class="hljs-number">0</span><br>&#125;()<br>fibonacci(c, quit)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-5-异常情况"><a href="#2-5-异常情况" class="headerlink" title="2.5 异常情况"></a>2.5 异常情况</h3><p><img src="/img/golang-channels/4.png"> </p><h4 id="2-5-1-发生Panic"><a href="#2-5-1-发生Panic" class="headerlink" title="2.5.1 发生Panic"></a>2.5.1 发生Panic</h4><ul><li>向一个关闭的 channel 进行写操作</li><li>关闭一个 nil 的 channel</li><li>关闭一个已经关闭的 channel</li></ul><h4 id="2-5-2-发生阻塞"><a href="#2-5-2-发生阻塞" class="headerlink" title="2.5.2 发生阻塞"></a>2.5.2 发生阻塞</h4><ul><li>读一个 nil channel 会被阻塞</li><li>写一个 nil channel 会被阻塞</li><li>读写缓冲为空或者已经满了且没有挂起的接收者和发送者。</li></ul><h2 id="3-常见应用"><a href="#3-常见应用" class="headerlink" title="3. 常见应用"></a>3. 常见应用</h2><h3 id="3-1-通知信号"><a href="#3-1-通知信号" class="headerlink" title="3.1 通知信号"></a>3.1 通知信号</h3><p>通过ch来发送停止信号，当main协程将准备工作做好之后，只需要往ch中写入数据（或关闭chan)，就能够让新起的协程退出for循环。下面中select语法类似于switch，但不同的是，case后面只能是一个面向channel的操作。当没有命中case时，会执行default，因此可以通过select来进行非阻塞的读或写。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">// do something recursively</span><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ch:<br>fmt.Println(<span class="hljs-string">&quot;channel received&quot;</span>)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;waiting&quot;</span>)<br>&#125;<br>&#125;<br>&#125;()<br><span class="hljs-comment">// do something until it is time to terminate goroutine</span><br>ch &lt;- <span class="hljs-literal">true</span> <span class="hljs-comment">// or close(ch)</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-定时任务"><a href="#3-2-定时任务" class="headerlink" title="3.2 定时任务"></a>3.2 定时任务</h3><p>与 timer 结合，实现定时任务执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span><span class="hljs-params">()</span></span> &#123;<br>ticker := time.Tick(<span class="hljs-number">1</span> * time.Second)<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ticker:<br>fmt.Println(<span class="hljs-string">&quot;执行 1s 定时任务&quot;</span>)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">go</span> worker()<br><br>time.Sleep(time.Second * <span class="hljs-number">5</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-生产消费解耦"><a href="#3-3-生产消费解耦" class="headerlink" title="3.3 生产消费解耦"></a>3.3 生产消费解耦</h3><p>服务启动时，启动 n 个 worker，作为工作协程池，这些协程工作在一个 for {} 无限循环里，从某个 channel 消费工作任务并执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>taskCh := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br><span class="hljs-keyword">go</span> worker(taskCh)<br><br><span class="hljs-comment">// 塞任务</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>taskCh &lt;- i<br>&#125;<br><br><span class="hljs-comment">// 等待任务执行完成</span><br>time.Sleep(time.Second * <span class="hljs-number">5</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span><span class="hljs-params">(taskCh &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">const</span> N = <span class="hljs-number">5</span><br><span class="hljs-comment">// 启动 5 个工作协程</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; N; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(id <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>task := &lt;-taskCh<br>fmt.Printf(<span class="hljs-string">&quot;finish task: %d by worker %d\n&quot;</span>, task, id)<br>time.Sleep(time.Second)<br>&#125;<br>&#125;(i)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4-并发数控制"><a href="#3-4-并发数控制" class="headerlink" title="3.4 并发数控制"></a>3.4 并发数控制</h3><p>有时需要定时执行几百个任务，例如每天定时按城市来执行一些离线计算的任务。但是并发数又不能太高，因为任务执行过程依赖第三方的一些资源，对请求的速率有限制。这时就可以通过 channel 来控制并发数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> limit = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> _, w := <span class="hljs-keyword">range</span> workers &#123;<br>limit &lt;- <span class="hljs-number">1</span> <span class="hljs-comment">// limit &lt;- 1在此处会限制创建的goroutine的个数</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>w()<br>&lt;-limit<br>&#125;()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-实践避坑"><a href="#4-实践避坑" class="headerlink" title="4. 实践避坑"></a>4. 实践避坑</h2><h3 id="4-1-死锁"><a href="#4-1-死锁" class="headerlink" title="4.1 死锁"></a>4.1 死锁</h3><p>go 语言新手在编译时很容易碰到这个死锁的问题：fatal error: all goroutines are asleep - deadlock! 在操作系统中，「死锁」就是两个线程互相等待，耗在那里，最后程序不得不终止。go 语言中的「死锁」也是类似的，两个 goroutine 互相等待，导致程序耗在那里，无法继续跑下去.</p><ul><li>只有生产者或者消费者<br>channel 的生产者和消费者必须成对出现，如果缺乏一个，就会造成死锁，例如：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 只有生产者，没有消费者</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span> &#123;<br>    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>    ch &lt;- <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-comment">// 只有消费者，没有生产者</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span> &#123;<br>    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>    &lt;-ch<br>&#125;<br></code></pre></td></tr></table></figure></li><li>生产者和消费者在同一个协程<br>除了需要成对出现，还需要出现在不同的 goroutine 中，例如：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 同一个 goroutine 中同时出现生产者和消费者</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f3</span><span class="hljs-params">()</span></span> &#123;<br>    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>    ch &lt;- <span class="hljs-number">1</span>  <span class="hljs-comment">// 由于消费者还没执行到，这里会一直阻塞住</span><br>    &lt;-ch<br>&#125;<br></code></pre></td></tr></table></figure></li><li>buffered channel 已满，且在同一个goroutine中<br>buffered channel 会将收到的元素先存在 hchan 结构体的 ringbuffer 中，继而才会发生阻塞。而当发生阻塞时，如果阻塞了主 goroutine ，则也会出现死锁。<br>所以实际使用中，推荐尽量使用 buffered channel ，使用起来会更安全</li></ul><h3 id="4-2-内存泄漏"><a href="#4-2-内存泄漏" class="headerlink" title="4.2 内存泄漏"></a>4.2 内存泄漏</h3><p>内存泄漏一般都是通过 OOM(Out of Memory) 告警或者发布过程中对内存的观察发现的，服务内存往往都是缓慢上升，直到被系统 OOM 掉清空内存再周而复始。在 go 语言中，错误地使用 channel 会导致 goroutine 泄漏，进而导致内存泄漏。<br>让 goroutine 泄漏的核心就是：生产者&#x2F;消费者 所在的 goroutine 已经退出，而其对应的 消费者&#x2F;生产者 所在的 goroutine 会永远阻塞住，直到进程退出</p><ul><li>生产者阻塞导致泄漏<br>使用channel做超时控制时，假设客户端超时为 500ms，而实际请求耗时为 2s，则 select 会走到 timeout 的逻辑，这时 g2 退出，channel ch 没有消费者，会一直在等待状态；如果这是在 server 代码中，这个请求处理完后，g1 就会挂起、发生了泄漏。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">leak1</span><span class="hljs-params">()</span></span> &#123;<br>    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>    <span class="hljs-comment">// g1</span><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        time.Sleep(<span class="hljs-number">2</span> * time.Second) <span class="hljs-comment">// 模拟 io 操作</span><br>        ch &lt;- <span class="hljs-number">100</span>                   <span class="hljs-comment">// 模拟返回结果</span><br>    &#125;()<br><br>    <span class="hljs-comment">// g2</span><br>    <span class="hljs-comment">// 阻塞住，直到超时或返回</span><br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-time.After(<span class="hljs-number">500</span> * time.Millisecond):<br>        fmt.Println(<span class="hljs-string">&quot;timeout! exit...&quot;</span>)<br>    <span class="hljs-keyword">case</span> result := &lt;-ch:<br>        fmt.Printf(<span class="hljs-string">&quot;result: %d\n&quot;</span>, result)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>消费者阻塞导致泄漏<br>如果生产者不继续生产，消费者所在的 goroutine 也会阻塞住，不会退出，例如：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">leak2</span><span class="hljs-params">()</span></span> &#123;<br>    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><br>    <span class="hljs-comment">// 消费者 g1</span><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> result := <span class="hljs-keyword">range</span> ch &#123;<br>            fmt.Printf(<span class="hljs-string">&quot;result: %d\n&quot;</span>, result)<br>        &#125;<br>    &#125;()<br><br>    <span class="hljs-comment">// 生产者 g2</span><br>    ch &lt;- <span class="hljs-number">1</span><br>    ch &lt;- <span class="hljs-number">2</span><br>    time.Sleep(time.Second)  <span class="hljs-comment">// 模拟耗时</span><br>    fmt.Println(<span class="hljs-string">&quot;main goroutine g2 done...&quot;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure>这种情况下，只需要增加 close(ch) 的操作即可，for-range 操作在收到 close 的信号后会退出、goroutine 不再阻塞，能够被回收。</li><li>如何预防泄漏<br>预防 goroutine 泄漏的核心就是：创建 goroutine 时就要想清楚它什么时候被回收。具体到执行层面，包括：<ul><li>当 goroutine 退出时，需要考虑它使用的 channel 有没有可能阻塞对应的生产者、消费者的 goroutine；</li><li>尽量使用 buffered channel 使用 buffered channel 能减少阻塞发生、即使疏忽了一些极端情况，也能降低 goroutine 泄漏的概率；</li></ul></li></ul><h3 id="4-3-Close-Channel"><a href="#4-3-Close-Channel" class="headerlink" title="4.3 Close Channel"></a>4.3 Close Channel</h3><ul><li>是否需要close<br>除非必须关闭 chan，否则不要主动关闭。关闭 chan 最优雅的方式，就是不要关闭 chan~<br>当一个 chan 没有 sender 和 receiver 时，即不再被使用时，GC 会在一段时间后标记、清理掉这个 chan。那么什么时候必须关闭 chan 呢？<br>比较常见的是将 close 作为一种通知机制，尤其是生产者与消费者之间是 1:M 的关系时，通过 close 告诉下游：我收工了，你们别读了</li><li>谁来关闭channel<br>chan 关闭的原则:</li><li>Don’t close a channel from the receiver side 不要在消费者端关闭 chan</li><li>Don’t close a channel if the channel has multiple concurrent senders 有多个并发写的生产者时也别关<br>只要遵循这两条原则，就能避免两种 panic 的场景，即：向 closed chan 发送数据，或者是 close 一个 closed chan。<br>按照生产者和消费者的关系可以拆解成以下几类情况：</li><li>一写一读：生产者关闭即可</li><li>一写多读：生产者关闭即可，关闭时下游全部消费者都能收到通知</li><li>多写一读：多个生产者之间需要引入一个协调 channel 来处理信号</li><li>多写多读：与 3 类似，核心思路是引入一个中间层以及使用 try-send 的套路来处理非阻塞的写入.</li></ul><h2 id="5-原理解析"><a href="#5-原理解析" class="headerlink" title="5. 原理解析"></a>5. 原理解析</h2><h3 id="5-1-底层结构"><a href="#5-1-底层结构" class="headerlink" title="5.1 底层结构"></a>5.1 底层结构</h3><p>channel底层是位于go&#x2F;src&#x2F;runtime&#x2F;chan.go文件中的hchan结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// runtime package, chan.go</span><br><span class="hljs-keyword">type</span> hchan <span class="hljs-keyword">struct</span> &#123;<br>    qcount   <span class="hljs-type">uint</span>            <span class="hljs-comment">// 通道里已有元素的数量</span><br>    dataqsiz <span class="hljs-type">uint</span>            <span class="hljs-comment">// 通道buffer(环形队列)的容量</span><br>    buf      unsafe.Pointer  <span class="hljs-comment">// 指向buffer内存的指针（只针对有缓冲的 chan）</span><br>    elemsize <span class="hljs-type">uint16</span>          <span class="hljs-comment">// 通道中元素大小</span><br>    closed   <span class="hljs-type">uint32</span>          <span class="hljs-comment">// 通道是否被关闭的标志。0：未关闭，非0：关闭。</span><br>    elemtype *_type          <span class="hljs-comment">// 通道中元素类型</span><br>    sendx    <span class="hljs-type">uint</span>            <span class="hljs-comment">// 通道写时，写到chan buffer中的位置的索引</span><br>    recvx    <span class="hljs-type">uint</span>            <span class="hljs-comment">// 通道读时，读的元素在通道中的位置的索引</span><br>    recvq    waitq           <span class="hljs-comment">// 因为通道读而阻塞的协程队列</span><br>    sendq    waitq           <span class="hljs-comment">// 因为通道写而阻塞的协程队列</span><br>    lock     mutex           <span class="hljs-comment">// 互斥锁，保证通道读写线程安全</span><br>&#125;<br><br><span class="hljs-comment">// waitq 是 sudog 的一个双向链表</span><br><span class="hljs-keyword">type</span> waitq <span class="hljs-keyword">struct</span> &#123;<br>   first *sudog<br>   last  *sudog<br>&#125;<br><br><span class="hljs-comment">// runtime/runtime2.go</span><br><span class="hljs-comment">// sudog是对go的一个封装</span><br><span class="hljs-keyword">type</span> sudog <span class="hljs-keyword">struct</span> &#123;<br>    g       *g              <span class="hljs-comment">// 阻塞的 goroutine</span><br>    elem    unsafe.Pointer  <span class="hljs-comment">// elem用来存储sender发送数据的地址或recver接收变量的地址</span><br>    c       *hchan          <span class="hljs-comment">// 阻塞的 channel</span><br>    next     *sudog         <br>    prev     *sudog<br>    <span class="hljs-comment">// other fields...</span><br>&#125;<br><br>ch &lt;- <span class="hljs-number">1</span>            <span class="hljs-comment">// 因为“写”而阻塞的goroutine的elem存的是“1”的地址</span><br>val, ok := &lt;- ch   <span class="hljs-comment">// 因为“读”而阻塞的goroutine的elem存的是“val”的地址</span><br></code></pre></td></tr></table></figure><p>一个channel的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">4</span>)<br><span class="hljs-comment">// 未阻塞</span><br>ch &lt;- <span class="hljs-number">1</span><br>ch &lt;- <span class="hljs-number">2</span><br>ch &lt;- <span class="hljs-number">3</span><br><span class="hljs-comment">// 发生阻塞</span><br>ch &lt;- <span class="hljs-number">4</span><br>ch &lt;- <span class="hljs-number">5</span><br>ch &lt;- <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p><img src="/img/golang-channels/5.png"><br><img src="/img/golang-channels/6.png"> </p><h3 id="5-2-Channel的创建"><a href="#5-2-Channel的创建" class="headerlink" title="5.2 Channel的创建"></a>5.2 Channel的创建</h3><p>channel的创建需要使用make关键字，通过make(type, size)来创建各种类型的通道</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">a := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)            <span class="hljs-comment">// unbuffered channel of integers</span><br>b := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">0</span>)         <span class="hljs-comment">// unbuffered channel of integers</span><br>c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *os.File, <span class="hljs-number">100</span>)  <span class="hljs-comment">// buffered channel of pointers to Files</span><br><br>write := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span>)        <span class="hljs-comment">// channel of integers only for writing</span><br>read := <span class="hljs-built_in">make</span>(&lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)         <span class="hljs-comment">// channel of integers only for reading</span><br></code></pre></td></tr></table></figure><p>channel初始化时分为缓冲型和非缓冲型两种，二者最大的区别是缓冲型channel在初始化时会分配ring buf，底层本质上是一个数组。在分配缓冲buf时，如果元素包含指针类型，buf和hchan地址是不连续的，否则就是连续的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makechan</span><span class="hljs-params">(t *chantype, size <span class="hljs-type">int</span>)</span></span> *hchan &#123;<br>elem := t.elem<br><br><span class="hljs-comment">// compiler checks this but be safe.</span><br><span class="hljs-keyword">if</span> elem.size &gt;= <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">16</span> &#123;<br>throw(<span class="hljs-string">&quot;makechan: invalid channel element type&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> hchanSize%maxAlign != <span class="hljs-number">0</span> || elem.align &gt; maxAlign &#123;<br>throw(<span class="hljs-string">&quot;makechan: bad alignment&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 计算缓冲区需要的总大小（缓冲区大小*元素大小），并判断是否超出最大可分配范围</span><br><span class="hljs-comment">// 如果是非缓冲通道或者是通道元素的size为0（比如struct&#123;&#125;），那么mem就是0</span><br>mem, overflow := math.MulUintptr(elem.size, <span class="hljs-type">uintptr</span>(size))<br><span class="hljs-keyword">if</span> overflow || mem &gt; maxAlloc-hchanSize || size &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;makechan: size out of range&quot;</span>))<br>&#125;<br><br><span class="hljs-comment">// Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.</span><br><span class="hljs-comment">// buf points into the same allocation, elemtype is persistent.</span><br><span class="hljs-comment">// SudoG&#x27;s are referenced from their owning thread so they can&#x27;t be collected.</span><br><span class="hljs-comment">// TODO(dvyukov,rlh): Rethink when collector can move allocated objects.</span><br><span class="hljs-keyword">var</span> c *hchan<br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> mem == <span class="hljs-number">0</span>:<br><span class="hljs-comment">// 缓冲区大小为0，或者channel中元素大小为0（struct&#123;&#125;&#123;&#125;）时，只需分配channel必需的空间即可;不分配缓冲区的内存</span><br><span class="hljs-comment">// Queue or element size is zero.</span><br>c = (*hchan)(mallocgc(hchanSize, <span class="hljs-literal">nil</span>, <span class="hljs-literal">true</span>))<br><span class="hljs-comment">// Race detector uses this location for synchronization.</span><br><span class="hljs-comment">// buf指针无实际意义</span><br>c.buf = c.raceaddr()<br><span class="hljs-keyword">case</span> elem.ptrdata == <span class="hljs-number">0</span>:<br><span class="hljs-comment">// channel中元素类型不是指针，分配一片连续内存空间，所需空间等于 缓冲区数组空间 + hchan必需的空间。</span><br><span class="hljs-comment">// Elements do not contain pointers.</span><br><span class="hljs-comment">// Allocate hchan and buf in one call.</span><br>c = (*hchan)(mallocgc(hchanSize+mem, <span class="hljs-literal">nil</span>, <span class="hljs-literal">true</span>))<br><span class="hljs-comment">// // buf指向了缓冲区内存的首地址</span><br>c.buf = add(unsafe.Pointer(c), hchanSize)<br><span class="hljs-keyword">default</span>:<br><span class="hljs-comment">// Elements contain pointers.</span><br><span class="hljs-comment">// 元素包含指针时 分别分配 chan 和 buf 的内存</span><br>c = <span class="hljs-built_in">new</span>(hchan)<br>c.buf = mallocgc(mem, elem, <span class="hljs-literal">true</span>)<br>&#125;<br><br><span class="hljs-comment">// 其他字段设置</span><br>c.elemsize = <span class="hljs-type">uint16</span>(elem.size)<br>c.elemtype = elem<br>c.dataqsiz = <span class="hljs-type">uint</span>(size)<br>lockInit(&amp;c.lock, lockRankHchan)<br><br><span class="hljs-keyword">if</span> debugChan &#123;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;makechan: chan=&quot;</span>, c, <span class="hljs-string">&quot;; elemsize=&quot;</span>, elem.size, <span class="hljs-string">&quot;; dataqsiz=&quot;</span>, size, <span class="hljs-string">&quot;\n&quot;</span>)<br>&#125;<br><span class="hljs-keyword">return</span> c<br>&#125;<br></code></pre></td></tr></table></figure><p>整体逻辑较为清晰：</p><ul><li>首先校验元素类型和缓冲区空间大小，然后创建hchan，分配所需空间。</li><li>这里有三种情况：<ul><li>当缓冲区大小为0，或者channel中元素大小为0时，只需分配channel必需的空间即可；</li><li>当channel元素类型不是指针时，则只需要为hchan和缓冲区分配一片连续内存空间，空间大小为缓冲区数组空间加上hchan必需的空间；</li><li>默认情况，缓冲区包含指针，则需要为hchan和缓冲区分别分配内存。</li></ul></li><li>最后更新hchan的其他字段，包括elemsize，elemtype，dataqsiz。</li></ul><h3 id="5-3-向Channel发送数据"><a href="#5-3-向Channel发送数据" class="headerlink" title="5.3 向Channel发送数据"></a>5.3 向Channel发送数据</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>ch &lt;- <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>通道写操作会调用chansend函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chansend</span><span class="hljs-params">(c *hchan, ep unsafe.Pointer, block <span class="hljs-type">bool</span>, callerpc <span class="hljs-type">uintptr</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-comment">// channel为空的场景下，如果是非阻塞，直接返回发送失败，如果是阻塞场景下，将当前协程挂起阻塞</span><br><span class="hljs-keyword">if</span> c == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> !block &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>gopark(<span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, waitReasonChanSendNilChan, traceEvGoStop, <span class="hljs-number">2</span>)<br>throw(<span class="hljs-string">&quot;unreachable&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">if</span> debugChan &#123;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;chansend: chan=&quot;</span>, c, <span class="hljs-string">&quot;\n&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">if</span> raceenabled &#123;<br>racereadpc(c.raceaddr(), callerpc, abi.FuncPCABIInternal(chansend))<br>&#125;<br><br><span class="hljs-comment">// Fast path: check for failed non-blocking operation without acquiring the lock.</span><br><span class="hljs-comment">// 对于非阻塞队列且channel未关闭、如果无缓冲区且没有等待的接收者或者换冲区已满都直接返回false</span><br><span class="hljs-keyword">if</span> !block &amp;&amp; c.closed == <span class="hljs-number">0</span> &amp;&amp; full(c) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// 一般情况下都是阻塞队列，主要看下面的逻辑</span><br><br><span class="hljs-keyword">var</span> t0 <span class="hljs-type">int64</span><br><span class="hljs-keyword">if</span> blockprofilerate &gt; <span class="hljs-number">0</span> &#123;<br>t0 = cputicks()<br>&#125;<br><span class="hljs-comment">// 加锁，保证协程并发安全</span><br>lock(&amp;c.lock)<br><span class="hljs-comment">// 如果channel已关闭，直接panic</span><br><span class="hljs-keyword">if</span> c.closed != <span class="hljs-number">0</span> &#123;<br>unlock(&amp;c.lock)<br><span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;send on closed channel&quot;</span>))<br>&#125;<br><br><span class="hljs-comment">// 首先判断是否有等待接收者</span><br><span class="hljs-keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// Found a waiting receiver. We pass the value we want to send</span><br><span class="hljs-comment">// directly to the receiver, bypassing the channel buffer (if any).</span><br><span class="hljs-comment">// 有等待接收者的时候分两种情况，无缓冲队列或者是缓冲队列为空</span><br><span class="hljs-comment">// 这两种情况都是直接唤醒等待的协程，直接将数据给等待者</span><br>send(c, sg, ep, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="hljs-number">3</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-comment">// 如果当前buf中的数量小于容量，说明还有空间，直接把数据写入buf，并更新sendx和qcount等字段</span><br><span class="hljs-keyword">if</span> c.qcount &lt; c.dataqsiz &#123;<br><span class="hljs-comment">// Space is available in the channel buffer. Enqueue the element to send.</span><br>qp := chanbuf(c, c.sendx)<br><span class="hljs-keyword">if</span> raceenabled &#123;<br>racenotify(c, c.sendx, <span class="hljs-literal">nil</span>)<br>&#125;<br>typedmemmove(c.elemtype, qp, ep)<br><span class="hljs-comment">// 索引更新及环形队列处理</span><br>c.sendx++<br><span class="hljs-keyword">if</span> c.sendx == c.dataqsiz &#123;<br>c.sendx = <span class="hljs-number">0</span><br>&#125;<br>c.qcount++<br>unlock(&amp;c.lock)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-keyword">if</span> !block &#123;<br>unlock(&amp;c.lock)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// Block on the channel. Some receiver will complete our operation for us.</span><br><span class="hljs-comment">// 如果队列已经满了，则需要构造一个sudog，将发送协程加入发送者队列</span><br>gp := getg()<br>mysg := acquireSudog()<br>mysg.releasetime = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> t0 != <span class="hljs-number">0</span> &#123;<br>mysg.releasetime = <span class="hljs-number">-1</span><br>&#125;<br><span class="hljs-comment">// No stack splits between assigning elem and enqueuing mysg</span><br><span class="hljs-comment">// on gp.waiting where copystack can find it.</span><br>mysg.elem = ep<br>mysg.waitlink = <span class="hljs-literal">nil</span><br>mysg.g = gp<br>mysg.isSelect = <span class="hljs-literal">false</span><br>mysg.c = c<br>gp.waiting = mysg<br>gp.param = <span class="hljs-literal">nil</span><br><span class="hljs-comment">// 当前 goroutine 进入发送等待队列</span><br>c.sendq.enqueue(mysg)<br><span class="hljs-comment">// 挂起协程</span><br>gp.parkingOnChan.Store(<span class="hljs-literal">true</span>)<br>gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanSend, traceEvGoBlockSend, <span class="hljs-number">2</span>)<br><span class="hljs-comment">// Ensure the value being sent is kept alive until the</span><br><span class="hljs-comment">// receiver copies it out. The sudog has a pointer to the</span><br><span class="hljs-comment">// stack object, but sudogs aren&#x27;t considered as roots of the</span><br><span class="hljs-comment">// stack tracer.</span><br>KeepAlive(ep)<br><br><span class="hljs-comment">// someone woke us up.</span><br><span class="hljs-comment">// 如果协程被唤醒了，说明数据会被读取走；后续执行清理工作并释放sudog结构体</span><br><span class="hljs-keyword">if</span> mysg != gp.waiting &#123;<br>throw(<span class="hljs-string">&quot;G waiting list is corrupted&quot;</span>)<br>&#125;<br>gp.waiting = <span class="hljs-literal">nil</span><br>gp.activeStackChans = <span class="hljs-literal">false</span><br>closed := !mysg.success<br>gp.param = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">if</span> mysg.releasetime &gt; <span class="hljs-number">0</span> &#123;<br>blockevent(mysg.releasetime-t0, <span class="hljs-number">2</span>)<br>&#125;<br>mysg.c = <span class="hljs-literal">nil</span><br>releaseSudog(mysg)<br><span class="hljs-keyword">if</span> closed &#123;<br><span class="hljs-keyword">if</span> c.closed == <span class="hljs-number">0</span> &#123;<br>throw(<span class="hljs-string">&quot;chansend: spurious wakeup&quot;</span>)<br>&#125;<br><span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;send on closed channel&quot;</span>))<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>主要流程分三种情况：</p><ul><li>存在等待接收的协程：说明无缓冲或者缓冲为空，直接把数据给接收者</li><li>没有等待的接收者且buf未满：把数据放入buf末尾</li><li>没有等待的接收者且buf满了：将发送者加入发送等待队列<br><img src="/img/golang-channels/7.png"></li></ul><h3 id="5-4-从Channel接收数据"><a href="#5-4-从Channel接收数据" class="headerlink" title="5.4 从Channel接收数据"></a>5.4 从Channel接收数据</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>value := &lt;- ch <span class="hljs-comment">// 一个接收值</span><br>value, ok := &lt;- ch <span class="hljs-comment">// 两个接收值</span><br></code></pre></td></tr></table></figure><ul><li>第3行中，第二个接收值“ok”表示value是否是有效数据，即value的值是否来自sender发送的数据。<br>📌 <blockquote><p>可以通过“ok”来判断chan是否关闭，即ok&#x3D;false，则chan关闭。但不能认为ok&#x3D;true，chan就未关闭，因为在某些chan已经关闭的情况下（如chan的buffer中有数据），“ok”依然是true。<br>  当ok&#x3D;true时，chan可能关闭或未关闭；当ok&#x3D;false时，chan一定是关闭了。</p></blockquote></li></ul><p>接收数据时，核心调用的是 chanrecv函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chanrecv</span><span class="hljs-params">(c *hchan, ep unsafe.Pointer, block <span class="hljs-type">bool</span>)</span></span> (selected, received <span class="hljs-type">bool</span>) &#123;<br><span class="hljs-comment">// ep：用来接收数据的地址。如果 ep 是 nil，说明忽略了接收值(-)。</span><br><span class="hljs-comment">// block表示通道是否是阻塞模式，我们创建的通道都是阻塞模式，下面代码不考虑非阻塞模式</span><br><span class="hljs-comment">// received表示接收到的是否是有效数据，即sender发送的数据。</span><br><span class="hljs-keyword">if</span> debugChan &#123;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;chanrecv: chan=&quot;</span>, c, <span class="hljs-string">&quot;\n&quot;</span>)<br>&#125;<br><span class="hljs-comment">// channel为空场景下，如果非阻塞队列直接返回false，如果阻塞队列，直接挂起等待</span><br><span class="hljs-keyword">if</span> c == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> !block &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>gopark(<span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="hljs-number">2</span>)<br>throw(<span class="hljs-string">&quot;unreachable&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// Fast path: check for failed non-blocking operation without acquiring the lock.</span><br><span class="hljs-comment">// 非阻塞模式下的快速退出场景，一般无需关注</span><br><span class="hljs-keyword">if</span> !block &amp;&amp; empty(c) &#123;<br><span class="hljs-keyword">if</span> atomic.Load(&amp;c.closed) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> empty(c) &#123;<br><span class="hljs-comment">// The channel is irreversibly closed and empty.</span><br><span class="hljs-keyword">if</span> raceenabled &#123;<br>raceacquire(c.raceaddr())<br>&#125;<br><span class="hljs-keyword">if</span> ep != <span class="hljs-literal">nil</span> &#123;<br>typedmemclr(c.elemtype, ep)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> t0 <span class="hljs-type">int64</span><br><span class="hljs-keyword">if</span> blockprofilerate &gt; <span class="hljs-number">0</span> &#123;<br>t0 = cputicks()<br>&#125;<br><br><span class="hljs-comment">// 加锁 保证协程并发安全性</span><br>lock(&amp;c.lock)<br><br><br><span class="hljs-keyword">if</span> c.closed != <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// 如果channel已经关闭且缓冲区无元素</span><br><span class="hljs-keyword">if</span> c.qcount == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> raceenabled &#123;<br>raceacquire(c.raceaddr())<br>&#125;<br>unlock(&amp;c.lock)<br><span class="hljs-comment">// 给ep一个零值</span><br><span class="hljs-keyword">if</span> ep != <span class="hljs-literal">nil</span> &#123;<br>typedmemclr(c.elemtype, ep)<br>&#125;<br><span class="hljs-comment">// 返回（true, false），即接收到值，但不是从channel中接收的有效值</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-comment">// The channel has been closed, but the channel&#x27;s buffer have data.</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// Just found waiting sender with not closed.</span><br><span class="hljs-comment">// 常规情况1: 有等待发送的队列</span><br>        <span class="hljs-comment">// 有等待发送的队列时，说明有两种情况：非缓冲队列或者缓冲已满；</span><br><span class="hljs-comment">// 对于非缓冲情况，直接从sender接收数据</span><br><span class="hljs-comment">// 对于缓冲已满情况，从buf队列头部接收数据，并将sender数据加入队列尾部</span><br><span class="hljs-keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// Found a waiting sender. If buffer is size 0, receive value</span><br><span class="hljs-comment">// directly from sender. Otherwise, receive from head of queue</span><br><span class="hljs-comment">// and add sender&#x27;s value to the tail of the queue (both map to</span><br><span class="hljs-comment">// the same buffer slot because the queue is full).</span><br>recv(c, sg, ep, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="hljs-number">3</span>)<br><span class="hljs-comment">// 接收成功</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 常规情况2: 无等待发送队列，且buf有值；</span><br><span class="hljs-comment">// 直接从recvx取数据即可，并更新recvx和qcount的值</span><br><span class="hljs-keyword">if</span> c.qcount &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// Receive directly from queue</span><br>qp := chanbuf(c, c.recvx)<br><span class="hljs-keyword">if</span> raceenabled &#123;<br>racenotify(c, c.recvx, <span class="hljs-literal">nil</span>)<br>&#125;<br><span class="hljs-keyword">if</span> ep != <span class="hljs-literal">nil</span> &#123;<br>typedmemmove(c.elemtype, ep, qp)<br>&#125;<br>typedmemclr(c.elemtype, qp)<br>c.recvx++<br><span class="hljs-keyword">if</span> c.recvx == c.dataqsiz &#123;<br>c.recvx = <span class="hljs-number">0</span><br>&#125;<br>c.qcount--<br>unlock(&amp;c.lock)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-comment">// 非阻塞模式，没有数据，直接返回</span><br><span class="hljs-keyword">if</span> !block &#123;<br>unlock(&amp;c.lock)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// 阻塞模式，没有数据，则挂起到接收队列中</span><br><span class="hljs-comment">// no sender available: block on this channel.</span><br>gp := getg()<br>mysg := acquireSudog()<br>mysg.releasetime = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> t0 != <span class="hljs-number">0</span> &#123;<br>mysg.releasetime = <span class="hljs-number">-1</span><br>&#125;<br><span class="hljs-comment">// No stack splits between assigning elem and enqueuing mysg</span><br><span class="hljs-comment">// on gp.waiting where copystack can find it.</span><br>mysg.elem = ep<br>mysg.waitlink = <span class="hljs-literal">nil</span><br>gp.waiting = mysg<br>mysg.g = gp<br>mysg.isSelect = <span class="hljs-literal">false</span><br>mysg.c = c<br>gp.param = <span class="hljs-literal">nil</span><br>    <span class="hljs-comment">// 加入到channel的等待接收队列recvq中</span><br>c.recvq.enqueue(mysg)<br><span class="hljs-comment">// stack shrinking.</span><br>gp.parkingOnChan.Store(<span class="hljs-literal">true</span>)<br>gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanReceive, traceEvGoBlockRecv, <span class="hljs-number">2</span>)<br><br><span class="hljs-comment">// someone woke us up</span><br><span class="hljs-comment">// 被唤醒之后执行清理工作并释放sudog结构体</span><br><span class="hljs-keyword">if</span> mysg != gp.waiting &#123;<br>throw(<span class="hljs-string">&quot;G waiting list is corrupted&quot;</span>)<br>&#125;<br>gp.waiting = <span class="hljs-literal">nil</span><br>gp.activeStackChans = <span class="hljs-literal">false</span><br><span class="hljs-keyword">if</span> mysg.releasetime &gt; <span class="hljs-number">0</span> &#123;<br>blockevent(mysg.releasetime-t0, <span class="hljs-number">2</span>)<br>&#125;<br>success := mysg.success<br>gp.param = <span class="hljs-literal">nil</span><br>mysg.c = <span class="hljs-literal">nil</span><br>releaseSudog(mysg)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, success<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，在整个读取数据的流程中，和发送数据的流程非常相似，主要分为3种情况</p><ul><li>存在等待发送的协程：这种场景说明无缓冲通道或者缓冲buf已满<ul><li>如果无缓冲区，那么直接从sender接收数据； </li><li>如果缓冲区已满，从buf队列的头部接收数据，并把sender的数据加到buf队列的尾部； </li><li>最后调用goready函数将等待发送数据的Goroutine的状态从_Gwaiting置为_Grunnable，等待下一次调度。</li></ul></li><li>没有等待发送的协程且buf存在数据，直接从buf中取数据。</li><li>没有等待发送的协程且无数据，接收者挂起加入接收者队列。<br><img src="/img/golang-channels/8.png"></li></ul><h3 id="5-5-关闭Channel"><a href="#5-5-关闭Channel" class="headerlink" title="5.5 关闭Channel"></a>5.5 关闭Channel</h3><p>收发完数据后，就是对channel的关闭操作，关闭操作主要执行以下逻辑：</p><ul><li>遍历recvq和sendq（实际只有recvq或者sendq），取出sudog中挂起的Goroutine加入到glist列表中，并清除sudog上的一些信息和状态。</li><li>遍历glist列表，为每个Goroutine调用goready函数，将所有Goroutine置为_Grunnable状态，等待调度。</li><li>当Goroutine被唤醒之后，会继续执行chansend和chanrecv函数中当前Goroutine被唤醒后的剩余逻辑。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">closechan</span><span class="hljs-params">(c *hchan)</span></span> &#123;<br><span class="hljs-comment">// 关闭 nil channel，panic</span><br><span class="hljs-keyword">if</span> c == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;close of nil channel&quot;</span>))<br>&#125;<br><br>lock(&amp;c.lock)<br><span class="hljs-keyword">if</span> c.closed != <span class="hljs-number">0</span> &#123;<br>unlock(&amp;c.lock)<br><span class="hljs-comment">// 关闭closed channel，panic</span><br><span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;close of closed channel&quot;</span>))<br>&#125;<br><br><span class="hljs-keyword">if</span> raceenabled &#123;<br>callerpc := getcallerpc()<br>racewritepc(c.raceaddr(), callerpc, abi.FuncPCABIInternal(closechan))<br>racerelease(c.raceaddr())<br>&#125;<br><span class="hljs-comment">// 设置为关闭状态</span><br>c.closed = <span class="hljs-number">1</span><br><br><span class="hljs-keyword">var</span> glist gList<br><br><span class="hljs-comment">// release all readers</span><br><span class="hljs-comment">// 遍历recvq，清除sudog的数据，取出其中处于_Gwaiting状态的Goroutine加入到glist中</span><br><span class="hljs-keyword">for</span> &#123;<br>sg := c.recvq.dequeue()<br><span class="hljs-keyword">if</span> sg == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> sg.elem != <span class="hljs-literal">nil</span> &#123;<br>typedmemclr(c.elemtype, sg.elem)<br>sg.elem = <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">if</span> sg.releasetime != <span class="hljs-number">0</span> &#123;<br>sg.releasetime = cputicks()<br>&#125;<br>gp := sg.g<br>gp.param = unsafe.Pointer(sg)<br>sg.success = <span class="hljs-literal">false</span><br><span class="hljs-keyword">if</span> raceenabled &#123;<br>raceacquireg(gp, c.raceaddr())<br>&#125;<br>glist.push(gp)<br>&#125;<br><br><span class="hljs-comment">// release all writers (they will panic)</span><br><span class="hljs-comment">// 遍历sendq，清除sudog的数据，取出其中处于_Gwaiting状态的Goroutine加入到glist中</span><br><span class="hljs-keyword">for</span> &#123;<br>sg := c.sendq.dequeue()<br><span class="hljs-keyword">if</span> sg == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>sg.elem = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">if</span> sg.releasetime != <span class="hljs-number">0</span> &#123;<br>sg.releasetime = cputicks()<br>&#125;<br>gp := sg.g<br>gp.param = unsafe.Pointer(sg)<br>sg.success = <span class="hljs-literal">false</span><br><span class="hljs-keyword">if</span> raceenabled &#123;<br>raceacquireg(gp, c.raceaddr())<br>&#125;<br>glist.push(gp)<br>&#125;<br>unlock(&amp;c.lock)<br><br><span class="hljs-comment">// Ready all Gs now that we&#x27;ve dropped the channel lock.</span><br><span class="hljs-comment">// 将glist中所有Goroutine的状态置为_Grunnable，等待调度器进行调度</span><br><span class="hljs-keyword">for</span> !glist.empty() &#123;<br>gp := glist.pop()<br>gp.schedlink = <span class="hljs-number">0</span><br>goready(gp, <span class="hljs-number">3</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://iswxw.blog.csdn.net/article/details/130785190">Go 并发之channel</a></p><p><a href="https://mp.weixin.qq.com/s/rFyMNeZF_cwKkBBJhHlEFQ">go channel详解</a></p><p><a href="https://mp.weixin.qq.com/s/XEdrrpIkdseFP3ZIdfOgVw">深入理解 channel</a></p><p><a href="https://www.ardanlabs.com/blog/2014/02/the-nature-of-channels-in-go.html">The Nature Of Channels In Go</a></p><p><a href="https://mp.weixin.qq.com/s/V7B9q4lZ6K3RjrP8Xd-cXw">一文带你揭秘Go语言之通道channel</a></p><p><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel/">Channel</a></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>Channel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang Context 解析</title>
    <link href="/2024/08/31/Golang-Context%E8%A7%A3%E6%9E%90/"/>
    <url>/2024/08/31/Golang-Context%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>Context 是 Go 语言中用于处理并发操作的一个重要概念。包含 goroutine 的运行状态、环境、现场等信息。Context 主要用来在 goroutine 之间传递上下文信息，包括：取消信号、超时时间、截止时间、Key-Value等。</p><span id="more"></span>  <h2 id="1-Context-介绍"><a href="#1-Context-介绍" class="headerlink" title="1. Context 介绍"></a>1. Context 介绍</h2><p>Context 是 Go 语言中用于处理并发操作的一个重要概念。Context译作“上下文”，准确说它是 goroutine 的上下文，包含 goroutine 的运行状态、环境、现场等信息。Context 主要用来在 goroutine 之间传递上下文信息，包括：取消信号、超时时间、截止时间、Key-Value等。</p><p>接口定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">interface</span> &#123;<br>    Deadline() (deadline time.Time, ok <span class="hljs-type">bool</span>) <span class="hljs-comment">//返回 context 的过期时间；</span><br>    Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125; <span class="hljs-comment">//返回 context 中的 channel；</span><br>    Err() <span class="hljs-type">error</span> <span class="hljs-comment">//返回错误；</span><br>    Value(key <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">interface</span>&#123;&#125; <span class="hljs-comment">//返回 context 中的对应 key 的值.</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>Deadline()</code>：该方法返回ctx的超时时间，以及是否设置超时时间的标识；如果没有设置超时时间，则ok&#x3D;false，deadline是一个初始的time.Time值。</li><li><code>Done()</code>：该方法返回一个只读的channel，当context被主动取消或者超时自动取消时，这个channel会被关闭；关闭的channel是可读的，协程可以正常收到关闭信号；如果一个ctx没有设置超时时间，调用该方法会返回nil；经常在select-case语句中使用，判断ctx是否关闭</li><li><code>Err()</code>：该方法返回ctx关闭的原因，如果ctx还没有关闭，就返回nil，如果被关闭了，返回的err也只有两种<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> Canceled = errors.New(<span class="hljs-string">&quot;context canceled&quot;</span>)        <span class="hljs-comment">// 正常取消</span><br><br><span class="hljs-keyword">var</span> DeadlineExceeded <span class="hljs-type">error</span> = deadlineExceededError&#123;&#125; <span class="hljs-comment">// 超时取消</span><br></code></pre></td></tr></table></figure></li><li><code>Value()</code>：golang中有一种在协程间传递信息的ctx，使用该方法可以根据key查询map中的value</li></ul><h2 id="2-Context-派生"><a href="#2-Context-派生" class="headerlink" title="2. Context 派生"></a>2. Context 派生</h2><p>Context在设计上实际只定义了接口，凡是实现改接口的结构体都可以称为Context，官方的包中实现了以下几类结构体。 </p><p><img src="/img/Golang-Context%E8%A7%A3%E6%9E%90/1.png">    </p><ul><li><code>emptyCtx</code>：空结构体，使用Background()函数和TODO()函数创建</li><li><code>valueCtx</code>：值传递的context，使用WithValue()函数创建</li><li><code>cancelCtx</code>：带有取消函数的context，使用WithCancel()函数创建</li><li><code>timerCtx</code>：带有超时时间的context，使用WithDeadline()和WithTimeout()函数创建</li></ul><h2 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3. 使用场景"></a>3. 使用场景</h2><p>Context在日常使用中，一般多用于超时控制、信号传递、共享变量等场景，下面分别简单介绍一下</p><h3 id="3-1-取消信号传递"><a href="#3-1-取消信号传递" class="headerlink" title="3.1 取消信号传递"></a>3.1 取消信号传递</h3><ul><li>在主协程中主动取消ctx，子协程收到取消请求后关闭操作<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>fmt.Printf(<span class="hljs-string">&quot;Worker received cancellation signal: %v\n&quot;</span>, ctx.Err())<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br>time.Sleep(<span class="hljs-number">500</span> * time.Millisecond)<br>fmt.Println(<span class="hljs-string">&quot;Working...&quot;</span>)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>parentCtx, cancel := context.WithCancel(context.Background())<br><span class="hljs-keyword">go</span> worker(parentCtx)<br><br>time.Sleep(<span class="hljs-number">1</span> * time.Second) <span class="hljs-comment">// 模拟主程序执行</span><br><br>cancel() <span class="hljs-comment">// 取消worker的ctx</span><br><br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>&#125;<br><span class="hljs-comment">// Working...</span><br><span class="hljs-comment">// Working...</span><br><span class="hljs-comment">// Worker received cancellation signal: context canceled</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="3-2-超时控制"><a href="#3-2-超时控制" class="headerlink" title="3.2 超时控制"></a>3.2 超时控制</h3><ul><li>使用带有超时时间的ctx，时间到后，函数自动中断处理<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">operation</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-time.After(<span class="hljs-number">3</span> * time.Second): <span class="hljs-comment">// Simulate some long operation</span><br>fmt.Println(<span class="hljs-string">&quot;Operation completed.&quot;</span>)<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>fmt.Println(<span class="hljs-string">&quot;Operation canceled due to timeout.&quot;</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>timeoutCtx, cancel := context.WithTimeout(context.Background(), <span class="hljs-number">2</span>*time.Second)<br><span class="hljs-keyword">defer</span> cancel()<br><br>operation(timeoutCtx)<br>&#125;<br><span class="hljs-comment">// Operation canceled due to timeout.</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="3-3-截止时间"><a href="#3-3-截止时间" class="headerlink" title="3.3 截止时间"></a>3.3 截止时间</h3><ul><li>ctx带有截止时间，在deadline之前可以正常工作，deadline后会报错<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">operation</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;<br>deadline, ok := ctx.Deadline()<br><span class="hljs-keyword">if</span> ok &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Operation deadline: %s\n&quot;</span>, deadline)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;No deadline for the operation.&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// Simulate some operation</span><br>time.Sleep(<span class="hljs-number">3</span> * time.Second)<br><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>fmt.Println(<span class="hljs-string">&quot;Operation canceled due to context deadline.&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;Operation completed within the deadline.&quot;</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>deadline := time.Now().Add(<span class="hljs-number">2</span> * time.Second)<br>deadlineCtx, cancel := context.WithDeadline(context.Background(), deadline)<br><span class="hljs-keyword">defer</span> cancel()<br><br>operation(deadlineCtx)<br>&#125;<br><span class="hljs-comment">// Operation deadline: 2024-08-31 12:21:15.279442 +0800 CST m=+2.000158542</span><br><span class="hljs-comment">// Operation canceled due to context deadline.</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="3-4-值传递"><a href="#3-4-值传递" class="headerlink" title="3.4 值传递"></a>3.4 值传递</h3><ul><li>通过ctx value传递userId<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">processRequest</span><span class="hljs-params">(ctx context.Context, requestID <span class="hljs-type">int</span>)</span></span> &#123;<br>userID, ok := ctx.Value(<span class="hljs-string">&quot;id&quot;</span>).(<span class="hljs-type">int</span>)<br><span class="hljs-keyword">if</span> !ok &#123;<br>fmt.Println(<span class="hljs-string">&quot;failed to get id from context.&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;processing request %d for user %d\n&quot;</span>, requestID, userID)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>parentCtx := context.WithValue(context.Background(), <span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-number">123</span>)<br><br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(requestID <span class="hljs-type">int</span>)</span></span> &#123;<br>childCtx := context.WithValue(parentCtx, <span class="hljs-string">&quot;requestID&quot;</span>, requestID)<br>processRequest(childCtx, requestID)<br>wg.Done()<br>&#125;(i)<br>&#125;<br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="4-源码分析"><a href="#4-源码分析" class="headerlink" title="4. 源码分析"></a>4. 源码分析</h2><h3 id="4-1-emptyCtx"><a href="#4-1-emptyCtx" class="headerlink" title="4.1 emptyCtx"></a>4.1 emptyCtx</h3><p>context包中定义了一个空的context， 名为emptyCtx，用于context的根节点，空的context只是简单的实现了Context，本身不包含任何值，仅用于其他context的父节点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 空的ctx本质上一个整型，它不会被取消、没有值，也没有过期时间</span><br><span class="hljs-keyword">type</span> emptyCtx <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*emptyCtx)</span></span> Deadline() (deadline time.Time, ok <span class="hljs-type">bool</span>) &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*emptyCtx)</span></span> Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125; &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*emptyCtx)</span></span> Err() <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*emptyCtx)</span></span> Value(key any) any &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>emptyCtx通过下面两个导出的函数（首字母大写）对外公开：我们所常用的 context.Background()  和 context.TODO() 方法。本质上二者并无差别</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// context.Background()函数返回一个空对象，被视为所有上下文树的根节点，不需要传递值或取消信号。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Background</span><span class="hljs-params">()</span></span> Context &#123;<span class="hljs-keyword">return</span> background&#125;<br><span class="hljs-comment">//context.TODO()函数返回一个空对象，用于该部分代码还未确定具体需要哪种上下文对象，</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TODO</span><span class="hljs-params">()</span></span> Context &#123;<span class="hljs-keyword">return</span> todo&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-valueCtx"><a href="#4-2-valueCtx" class="headerlink" title="4.2 valueCtx"></a>4.2 valueCtx</h3><p>valueCtx在空ctx的基础上，增加了key-val键值对，用于保存一些数据供上下文使用。在实际使用过程中通过WithValue()函数构造。</p><ul><li><p><code>valueCtx</code> 结构体定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 通过组合Context的方式，携带一个key-val对</span><br><span class="hljs-keyword">type</span> valueCtx <span class="hljs-keyword">struct</span> &#123;<br>Context<br>key, val any<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>WithValue()</code> 源码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithValue</span><span class="hljs-params">(parent Context, key, val any)</span></span> Context &#123;<br><span class="hljs-keyword">if</span> parent == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;cannot create context from nil parent&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> key == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;nil key&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> !reflectlite.TypeOf(key).Comparable() &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;key is not comparable&quot;</span>)<br>&#125;<br><span class="hljs-keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过以上代码可以看出，valueCtx的每次构建，都是在上一个ctx的基础上生成一个新的ctx，每一个valueCtx只有一个键值对，多个键值对构成一个串型的数据结构。<br><img src="/img/Golang-Context%E8%A7%A3%E6%9E%90/2.png">   </p></li><li><p><code>valueCtx.Value()</code>函数<br>Value()函数从当前的ctx开始找key的值，如果找不到，继续找父ctx，直至找到emptyCtx为止</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *valueCtx)</span></span> Value(key any) any &#123;<br><span class="hljs-keyword">if</span> c.key == key &#123;<br><span class="hljs-keyword">return</span> c.val<br>&#125;<br><span class="hljs-keyword">return</span> value(c.Context, key)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">value</span><span class="hljs-params">(c Context, key any)</span></span> any &#123;<br><span class="hljs-comment">// 从底层循环往父层寻找指定key的值</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">switch</span> ctx := c.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> *valueCtx:<br><span class="hljs-keyword">if</span> key == ctx.key &#123;<br><span class="hljs-keyword">return</span> ctx.val<br>&#125;<br>c = ctx.Context<br><span class="hljs-comment">// cancelCtxKey 是一个特殊的key，如果属于cancelCtx或者timerCtx且key为特殊key，则返回这个cancelCtx</span><br><span class="hljs-keyword">case</span> *cancelCtx:<br><span class="hljs-keyword">if</span> key == &amp;cancelCtxKey &#123;<br><span class="hljs-keyword">return</span> c<br>&#125;<br>c = ctx.Context<br><span class="hljs-keyword">case</span> *timerCtx:<br><span class="hljs-keyword">if</span> key == &amp;cancelCtxKey &#123;<br><span class="hljs-keyword">return</span> ctx.cancelCtx<br>&#125;<br>c = ctx.Context<br><span class="hljs-keyword">case</span> *emptyCtx:<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> c.Value(key)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>特点</p><ul><li>一个 valueCtx 只能存一个 kv 对，n 个 kv 对会嵌套 n 个 valueCtx，造成空间浪费，不适合大量存储；</li><li>基于 k 寻找 v 的过程是线性的，时间复杂度 O(N)；</li><li>不支持基于 k 的去重，相同 k 可能重复存在，并基于起点的不同，返回不同的 v.</li><li>valueCtx结构对于Context接口只重写了Value方法，其他三个方法直接调用嵌入的Context。</li></ul></li></ul><h3 id="4-3-cancelCtx"><a href="#4-3-cancelCtx" class="headerlink" title="4.3 cancelCtx"></a>4.3 cancelCtx</h3><p>context包中第三个比较重要的ctx是cancelCtx，顾名思义是可以取消的context，该context在构建时返回一个取消函数，可以供主动取消。</p><ul><li><p><code>cancelCtx</code>结构定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> cancelCtx <span class="hljs-keyword">struct</span> &#123;<br>Context                        <span class="hljs-comment">// 嵌入的Context</span><br><br>mu       sync.Mutex            <span class="hljs-comment">// 互斥锁，保护以下字段</span><br>done     atomic.Value          <span class="hljs-comment">// 原子通道，惰性创建,第一次被cancel调用关闭</span><br>children <span class="hljs-keyword">map</span>[canceler]<span class="hljs-keyword">struct</span>&#123;&#125; <span class="hljs-comment">// 存储子树中第一个可以被cancel的ctx</span><br>err      <span class="hljs-type">error</span>                 <span class="hljs-comment">// 存储error信息</span><br>cause    <span class="hljs-type">error</span>                 <span class="hljs-comment">// 存储带有原因的error信息</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>cancelCtx</code> 主要方法<br>  cancelCtx作为Context接口的实现，重写了Done、Err和Value方法，分别简单介绍如下</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Done 方法返回一个通道，使用了惰性加载的机制，只有第一次调用Done方法时才会被创建</span><br><span class="hljs-comment">// 将通道放到atomic.Value中 保证通道操作的原子性</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cancelCtx)</span></span> Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125; &#123;<br>d := c.done.Load()<br><span class="hljs-keyword">if</span> d != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> d.(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>&#125;<br><span class="hljs-comment">// 加锁的方式做二次检查，避免多并发场景下被重复创建</span><br>c.mu.Lock()<br><span class="hljs-keyword">defer</span> c.mu.Unlock()<br>d = c.done.Load()<br><span class="hljs-keyword">if</span> d == <span class="hljs-literal">nil</span> &#123;<br>d = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>c.done.Store(d)<br>&#125;<br><span class="hljs-keyword">return</span> d.(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>&#125;<br><br><span class="hljs-comment">// Value方法复用valueCtx的递归逻辑，只是有一种特殊的处理情况</span><br><span class="hljs-comment">// 当key是cancelCtxKey的时候，返回的是cancelCtx本身</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cancelCtx)</span></span> Value(key any) any &#123;<br><span class="hljs-keyword">if</span> key == &amp;cancelCtxKey &#123;<br><span class="hljs-keyword">return</span> c<br>&#125;<br><span class="hljs-keyword">return</span> value(c.Context, key)<br>&#125;<br><br><span class="hljs-comment">// Err 返回结构体err</span><br><span class="hljs-comment">// cancelCtx.err 默认是nil，在被cancel的时候指定一个error变量：“context canceled”</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cancelCtx)</span></span> Err() <span class="hljs-type">error</span> &#123;<br>c.mu.Lock()<br>err := c.err<br>c.mu.Unlock()<br><span class="hljs-keyword">return</span> err<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>WithCancel()</code> 构造方法<br>WithCancel是context官方包对外提供的函数之一，函数接受一个父上下文对象parent 作为参数，返回一个新的上下文cancelCtx对象ctx 及其对应的取消函数cancel 。当调用取消函数时，该ctx对象及其所有后代ctx对象均会被取消。核心代码逻辑介绍如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithCancel</span><span class="hljs-params">(parent Context)</span></span> (ctx Context, cancel CancelFunc) &#123;<br>c := withCancel(parent)<br><span class="hljs-comment">// 将构造的cancelCtx返回，同时返回终止该cancelCtx的闭包函数cancel；第一个参数是 true，也就是说取消的时候，需要将自己从父节点里删除。</span><br><span class="hljs-keyword">return</span> c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; c.cancel(<span class="hljs-literal">true</span>, Canceled, <span class="hljs-literal">nil</span>) &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">withCancel</span><span class="hljs-params">(parent Context)</span></span> *cancelCtx &#123;<br><span class="hljs-comment">// 如果父ctx为空，则无法构建</span><br><span class="hljs-keyword">if</span> parent == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;cannot create context from nil parent&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 构建一个新的cancelCtx</span><br>c := newCancelCtx(parent)<br><span class="hljs-comment">// 核心逻辑，构建cancel传播链</span><br>propagateCancel(parent, c)<br><span class="hljs-keyword">return</span> c<br>&#125;<br><br></code></pre></td></tr></table></figure><p>由于cancelCtx的对象在取消时，要同步取消其后代Ctx对象，因此在cancelCtx的构建时，要进行cancel信息的控制链传递，建立父子关系，将本次新建的cancelCtx放在链路中上一个cancelCtx的children map中。如果一个cancelCtx对象的后代不是cancelCtx对象，那这个后代的done channel本身就是cancelCtx的done channel，无需额外关联。因此在控制链的传递中，只需关联cancelCtx的父子关系即可。</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// parent为父ctx，child为本次创建的cancelCtx</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">propagateCancel</span><span class="hljs-params">(parent Context, child canceler)</span></span> &#123;<br>done := parent.Done()<br><span class="hljs-comment">// 如果父ctx不会被取消，直接返回即可</span><br><span class="hljs-keyword">if</span> done == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <br>&#125;<br><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-done:<br><span class="hljs-comment">// 如果父ctx已被取消则直接中止本次构建的cancelCtx，并用父ctx的取消原因作为子ctx的取消原因</span><br>child.cancel(<span class="hljs-literal">false</span>, parent.Err(), Cause(parent))<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br>&#125;<br><br><span class="hljs-comment">// 寻找parent ctx的第一个cancelCtx祖先(这个可以是parent自己,由cancelCtx.Value函数的实现决定)，本质上也就是找child ctx的第一个cancelCtx的祖先</span><br><span class="hljs-keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;<br>p.mu.Lock()<br><span class="hljs-keyword">if</span> p.err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 如果父ctx已被取消则直接中止本次构建的cancelCtx</span><br>child.cancel(<span class="hljs-literal">false</span>, p.err, p.cause)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 将本次新构建的child ctx加入到最近的cancelCtx祖先的children中</span><br><span class="hljs-keyword">if</span> p.children == <span class="hljs-literal">nil</span> &#123;<br>p.children = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[canceler]<span class="hljs-keyword">struct</span>&#123;&#125;)<br>&#125;<br>p.children[child] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;<br>p.mu.Unlock()<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 如果parent不是cancelCtx，但是又存在cancel的能力，则启动一个协程监控parent的状态，如果parent终止，也及时终止child ctx，并传递parent的error</span><br>goroutines.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-parent.Done():<br>child.cancel(<span class="hljs-literal">false</span>, parent.Err(), Cause(parent))<br><span class="hljs-keyword">case</span> &lt;-child.Done():<br>&#125;<br>&#125;()<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// parentCancelCtx 返回输入parent的第个cancelCtx祖先，可能是parent自己</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parentCancelCtx</span><span class="hljs-params">(parent Context)</span></span> (*cancelCtx, <span class="hljs-type">bool</span>) &#123;<br><span class="hljs-comment">// parent.Done() 返回控制链中第一个实现非空Done()方法的Context</span><br><span class="hljs-comment">// 在valueCtx、cancelCtx、timerCtx三者中，只有cancleCtx实现了非空的Done方法，因此parent.Done正常情况下会返回第一个祖先cancelCtx的done channel。但如果Context树中有第三方实现的Context接口实例时，parent.Done可能返回其他channel</span><br>done := parent.Done()<br><span class="hljs-keyword">if</span> done == closedchan || done == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// 通过cancelCtxKey找到第一个祖先cancelCtx</span><br>p, ok := parent.Value(&amp;cancelCtxKey).(*cancelCtx)<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-comment">// 如果p.done不等于done，说明控制链中碰到的第一个实现非空Done()的Context是第三方Context，不是cancelCtx</span><br>pdone, _ := p.done.Load().(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br><span class="hljs-keyword">if</span> pdone != done &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">return</span> p, <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/Golang-Context%E8%A7%A3%E6%9E%90/3.png"><br>如上图，由C3生成C4时，C3的parentCancelCtx是C1，C3调用Done()方法返回的也是C1的 done channel，因此将C4放入C1的children中</p><ul><li><code>cancelCtx.cancel()</code> 方法<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cancelCtx)</span></span> cancel(removeFromParent <span class="hljs-type">bool</span>, err, cause <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;context: internal error: missing cancel error&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> cause == <span class="hljs-literal">nil</span> &#123;<br>cause = err<br>&#125;<br>c.mu.Lock()<br><span class="hljs-comment">// 如果已经被取消，直接返回</span><br><span class="hljs-keyword">if</span> c.err != <span class="hljs-literal">nil</span> &#123;<br>c.mu.Unlock()<br><span class="hljs-keyword">return</span> <br>&#125;<br><br><span class="hljs-comment">// 记下错误信息，并关闭channel</span><br>c.err = err<br>c.cause = cause<br>d, _ := c.done.Load().(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br><span class="hljs-keyword">if</span> d == <span class="hljs-literal">nil</span> &#123;<br>c.done.Store(closedchan)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">close</span>(d)<br>&#125;<br><span class="hljs-comment">// 级联取消child cancelCtx</span><br><span class="hljs-keyword">for</span> child := <span class="hljs-keyword">range</span> c.children &#123;<br>child.cancel(<span class="hljs-literal">false</span>, err, cause)<br>&#125;<br>c.children = <span class="hljs-literal">nil</span><br>c.mu.Unlock()<br><br><span class="hljs-comment">// 将当前ctx从ctx的父ctx中移除</span><br><span class="hljs-keyword">if</span> removeFromParent &#123;<br>removeChild(c.Context, c)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><code>WithCacelCause()</code> 支持传递取消原因的cancelCtx<br>早期的cancelCtx在cancel时，能写入的err信息及其有限，只有超时取消和外部取消，Go  1.20版本新增一个可以设置取消原因的方法，他在调用cancel的时候，可以传递一个error参数。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithCancelCause</span><span class="hljs-params">(parent Context)</span></span> (ctx Context, cancel CancelCauseFunc) &#123;<br>c := withCancel(parent)<br><span class="hljs-keyword">return</span> c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(cause <span class="hljs-type">error</span>)</span></span> &#123; c.cancel(<span class="hljs-literal">true</span>, Canceled, cause) &#125;<br>&#125;<br><br>ctx, cancelFunc := context.WithCancelCause(parentCtx)<br><span class="hljs-keyword">defer</span> cancelFunc(errors.New(<span class="hljs-string">&quot;原因&quot;</span>))<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-4-timerCtx"><a href="#4-4-timerCtx" class="headerlink" title="4.4 timerCtx"></a>4.4 timerCtx</h3><p>timerCtx在cancelCtx的基础上进行了一次封装，除了继承cancelCtx的能力外，新增了一个time.Timer的计时器用于定时终止context，另外新增了一个deadline字段用于timerCtx的过期时间。</p><ul><li><code>timerCtx</code> 结构体<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> timerCtx <span class="hljs-keyword">struct</span> &#123;<br>*cancelCtx<br>timer *time.Timer <span class="hljs-comment">// Under cancelCtx.mu.</span><br><br>deadline time.Time<br>&#125;<br><br><span class="hljs-comment">// 重写Context接口的Deadline()方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *timerCtx)</span></span> Deadline() (deadline time.Time, ok <span class="hljs-type">bool</span>) &#123;<br><span class="hljs-keyword">return</span> c.deadline, <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><code>WithDeadline()</code> 构造方法<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithDeadline</span><span class="hljs-params">(parent Context, d time.Time)</span></span> (Context, CancelFunc) &#123;<br><span class="hljs-comment">// 校验parent ctx是否为空</span><br><span class="hljs-keyword">if</span> parent == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;cannot create context from nil parent&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 校验parent的过期时间是否比自己早，如果比自己早，直接构造一个基于parent的cancelCtx即可</span><br><span class="hljs-keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;<br><span class="hljs-comment">// The current deadline is already sooner than the new one.</span><br><span class="hljs-keyword">return</span> WithCancel(parent)<br>&#125;<br><span class="hljs-comment">// 构造新的timerCtx</span><br>c := &amp;timerCtx&#123;<br>cancelCtx: newCancelCtx(parent),<br>deadline:  d,<br>&#125;<br><span class="hljs-comment">// ctx控制链的取消关系同步，方式与cancelCtx一样</span><br>propagateCancel(parent, c)<br><span class="hljs-comment">// 判断过期时间是否已到，若是，直接 cancel timerCtx，并返回 DeadlineExceeded 的错误；</span><br>dur := time.Until(d)<br><span class="hljs-keyword">if</span> dur &lt;= <span class="hljs-number">0</span> &#123;<br>c.cancel(<span class="hljs-literal">true</span>, DeadlineExceeded, <span class="hljs-literal">nil</span>) <span class="hljs-comment">// deadline has already passed</span><br><span class="hljs-keyword">return</span> c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; c.cancel(<span class="hljs-literal">false</span>, Canceled, <span class="hljs-literal">nil</span>) &#125;<br>&#125;<br><span class="hljs-comment">// 启动定时器，时间到了后取消该ctx</span><br>c.mu.Lock()<br><span class="hljs-keyword">defer</span> c.mu.Unlock()<br><span class="hljs-keyword">if</span> c.err == <span class="hljs-literal">nil</span> &#123;<br>c.timer = time.AfterFunc(dur, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>c.cancel(<span class="hljs-literal">true</span>, DeadlineExceeded, <span class="hljs-literal">nil</span>)<br>&#125;)<br>&#125;<br><span class="hljs-keyword">return</span> c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; c.cancel(<span class="hljs-literal">true</span>, Canceled, <span class="hljs-literal">nil</span>) &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><code>WithTimeout()</code> 构造方法<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// WithTimeout 直接复用WithDeadline方法，在当前时刻加上时间段就是最后的超时时间</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithTimeout</span><span class="hljs-params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc) &#123;<br><span class="hljs-keyword">return</span> WithDeadline(parent, time.Now().Add(timeout))<br>&#125;<br></code></pre></td></tr></table></figure></li><li><code>timerCtx.cancel()</code> 方法<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *timerCtx)</span></span> cancel(removeFromParent <span class="hljs-type">bool</span>, err, cause <span class="hljs-type">error</span>) &#123;<br><span class="hljs-comment">// 直接复用cancelCtx的取消能力</span><br>c.cancelCtx.cancel(<span class="hljs-literal">false</span>, err, cause)<br><span class="hljs-comment">// 从parent ctx中移除父子关系</span><br><span class="hljs-keyword">if</span> removeFromParent &#123;<br><span class="hljs-comment">// Remove this timerCtx from its parent cancelCtx&#x27;s children.</span><br>removeChild(c.cancelCtx.Context, c)<br>&#125;<br><span class="hljs-comment">// 停止计时器</span><br>c.mu.Lock()<br><span class="hljs-keyword">if</span> c.timer != <span class="hljs-literal">nil</span> &#123;<br>c.timer.Stop()<br>c.timer = <span class="hljs-literal">nil</span><br>&#125;<br>c.mu.Unlock()<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5. 注意事项"></a>5. 注意事项</h2><ul><li>不要在结构类型中加入 Context 参数，而是将它显式地传递给需要它的每个函数，并且它应该是第一个参数，通常命名为 ctx:</li><li>Context 是线程安全的，可以放心地在多个 goroutine 中使用。</li><li>当你把 Context 传递给多个 goroutine 使用时，只要执行一次 cancel 操作，所有的 goroutine 就可以收到 取消的信号</li><li>不要把原本可以由函数参数来传递的变量，交给 Context 的 Value 来传递。<ul><li>ctx一般只存储请求维度的数据，比如用户信息、logId等，只保留告知类型的数据，而不保留控制性质的数据，即不存储业务逻辑上的控制参数数据。</li></ul></li><li>当一个函数需要接收一个 Context 时，但是此时你还不知道要传递什么 Context 时，可以先用 context.TODO 来代替，而不要选择传递一个 nil。</li><li>当一个 Context 被 cancel 时，继承自该 Context 的所有 子 Context 都会被 cancel。</li></ul><h2 id="6-参考资料"><a href="#6-参考资料" class="headerlink" title="6. 参考资料"></a>6. 参考资料</h2><p><a href="https://juejin.cn/post/7265880174381727759">Golang context实现原理与源码分析</a></p><p><a href="https://blog.51cto.com/u_15533611/5202001">Golang 笔记</a></p><p><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/">Go语言并发编程-上下文Context</a> </p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>Context</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BigCache解析</title>
    <link href="/2024/08/10/BigCache%E8%A7%A3%E6%9E%90/"/>
    <url>/2024/08/10/BigCache%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>BigCache是一个快速，支持并发访问，自淘汰的内存型缓存，可以在存储大量元素的基础上依然保持高性能。BigCache将元素保存在堆上的同时避免了GC的开销。</p><span id="more"></span>  <h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>缓存是系统提升并发能力、降低时延的利器，根据存储介质和使用场景，我们分为本地缓存与分布式缓存两种：</p><ul><li>本地缓存：一般在进程内，最简单的sync.Map就可以是一个并发安全的本地缓存。常见的有LocalCache、BigCache等。</li><li>分布式缓存：一般会用到Redis&#x2F;MemCached等分布式内存数据库实现，想比如本地缓存，分布式数据库增加了网络开销</li></ul><p>BigCache是一个快速，支持并发访问，自淘汰的内存型缓存，可以在存储大量元素的基础上依然保持高性能。BigCache将元素保存在堆上的同时避免了GC的开销。</p><p>源码地址：<a href="https://github.com/allegro/bigcache">https://github.com/allegro/bigcache</a><br>本文示例代码取自版本 v1.2.1  </p><h2 id="2-设计思想"><a href="#2-设计思想" class="headerlink" title="2. 设计思想"></a>2. 设计思想</h2><h3 id="2-1-整体设计"><a href="#2-1-整体设计" class="headerlink" title="2.1 整体设计"></a>2.1 整体设计</h3><ul><li>多： 缓存的元素数量非常大，可以达到百万级或千万级。</li><li>快： 对延迟有非常高的要求，平均延迟要求在5毫秒以内。支持10k rps级别的访问速度。</li><li>稳： 99.9分位延迟应在10毫秒左右，99.999分位延迟应在400毫秒左右。</li></ul><p>目前有许多开源的cache库，大部分都是基于map实现的，例如go-cache,ttl-cache等。bigcache明确指出，当数据量巨大时，直接基于map实现的cache库将出现严重的性能问题，这也是他们设计了一个全新的cache库的原因。</p><ul><li>核心设计思想<ul><li>数据分片存储，以降低锁冲突并提升并发量。</li><li>避免在map中存储指针，从而避免在GC时对map进行遍历扫描。</li><li>采用FIFO式的Ring Buffer设计，简化整体内存设计逻辑。</li></ul></li></ul><p><img src="/img/BigCache%E8%A7%A3%E6%9E%90/1.png"></p><h3 id="2-2-数据分片-Shard"><a href="#2-2-数据分片-Shard" class="headerlink" title="2.2 数据分片 Shard"></a>2.2 数据分片 Shard</h3><p>使用map做缓存时，实现并发安全的方式就是加一把锁。但是如果数据过多时，并发请求会导致较多的锁冲突，为了解决这种问题，BigCache采用了分片的方式降低锁粒度。在声明一个BigCache时，表面上看是一个结构体，实际上是一个数组，底层分成了N个互不关联的部分。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> BigCache <span class="hljs-keyword">struct</span> &#123;<br>shards       []*cacheShard<br>lifeWindow   <span class="hljs-type">uint64</span><br>clock        clock<br>hash         Hasher<br>config       Config<br>shardMask    <span class="hljs-type">uint64</span><br>maxShardSize <span class="hljs-type">uint32</span><br><span class="hljs-built_in">close</span>        <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在Set或者Get数据时，先对key计算hash值，根据hash值取余得到目标shard，之后所有的读写操作都是在各自的shard上进行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *BigCache)</span></span> Set(key <span class="hljs-type">string</span>, entry []<span class="hljs-type">byte</span>) <span class="hljs-type">error</span> &#123;<br>hashedKey := c.hash.Sum64(key)<br>shard := c.getShard(hashedKey)<br><span class="hljs-keyword">return</span> shard.set(key, hashedKey, entry)<br>&#125;<br></code></pre></td></tr></table></figure><p>在计算分片数时，取余操作使用的是位运算，所有分片数要设置为2的幂次方。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *BigCache)</span></span> getShard(hashedKey <span class="hljs-type">uint64</span>) (shard *cacheShard) &#123;<br><span class="hljs-keyword">return</span> c.shards[hashedKey&amp;c.shardMask]<br>&#125;<br><span class="hljs-comment">// shardMask = shardNum - 1</span><br></code></pre></td></tr></table></figure><ul><li>特点：<ul><li>减少锁冲突，提升并发量：当一个shard被加上Lock的时候，其他shard的读写不受影响。</li><li>shard一旦建好，将不再改变，无需考虑shard变化时的数据迁移问题，shard之间操作无需加锁。</li><li>shard个数必须是2的平方数。对2的平方数取余可以改成位运算，会比传统的%快很多</li></ul></li></ul><h3 id="2-3-Map-GC优化"><a href="#2-3-Map-GC优化" class="headerlink" title="2.3 Map GC优化"></a>2.3 Map GC优化</h3><p>在golang中，map的key和value一旦涉及到指针类型，在GC的时候就会触发遍历扫描，当数据量级很大时， GC延迟严重。<br>在bigcache的设计中，map定义为map[uint64]uint32 ，避免了存储任何指针。结构定义如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> cacheShard <span class="hljs-keyword">struct</span> &#123;<br>hashmap     <span class="hljs-keyword">map</span>[<span class="hljs-type">uint64</span>]<span class="hljs-type">uint32</span><br>entries     queue.BytesQueue<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li>hashmap的key是cache key的hash值，而value仅仅是个uint32。value存储的不再是实际值，而是value在 BytesQueue中的索引。</li><li>entries存储的是实际value值，它是一个ring buffer的内存结构，本质上就是个超大的[]byte数组，里面存放了所有的原始数据。每个原始数据就存放在这个大[]byte数组中的其中一段。<br>之所以用一个大的[]byte数组和ring buffer结构，除了方便管理和复用内存之外，一个更重要的原因是：对于[]byte数组, GC时只用看做一个变量扫描，无需再遍历全部数组。这样又避免了海量数据对GC造成的负担。</li></ul><h3 id="2-4-BytesQueue内存"><a href="#2-4-BytesQueue内存" class="headerlink" title="2.4 BytesQueue内存"></a>2.4 BytesQueue内存</h3><p>BigCache中的每一个shard都采用类似RingBuffer的结构</p><ul><li>对于map中每个元素而言，key存储的是 cache key的hash值，value存储的是实际值在byte数组中的位置。</li><li>数据存储完全采用FIFO的形式，所有数据的新增、包括老数据的修改，都是直接追加到数组的后面，然后修改map的位置值即可。<br><img src="/img/BigCache%E8%A7%A3%E6%9E%90/2.png"></li></ul><p>具体到每一个数据的存储，并不是完全只存储val值，会把一些相关的信息一起存储，构成数据header和body，，一个header和一个body构成一个完整的条目，其中：</p><ul><li>Block Size：标记header和Body，也就是Entry的总长度</li><li>header：包括 插入时间戳，key的hash值，key的长度， header的长度固定</li><li>body：key的原始值，value的原始值</li><li>有了BlockSize、Header Length以及Key的长度，就可以确定value的边界并正常进行数据读取了。<br><img src="/img/BigCache%E8%A7%A3%E6%9E%90/3.png"></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br><span class="hljs-comment">// header中的时间戳、hash值和key长度占用字节数固定，可以方便找到key原始值的起始位置</span><br>timestampSizeInBytes = <span class="hljs-number">8</span>       <span class="hljs-comment">// Number of bytes used for timestamp</span><br>hashSizeInBytes      = <span class="hljs-number">8</span>       <span class="hljs-comment">// Number of bytes used for hash</span><br>keySizeInBytes       = <span class="hljs-number">2</span>       <span class="hljs-comment">// Number of bytes used for size of entry key</span><br>headersSizeInBytes   = timestampSizeInBytes + hashSizeInBytes + keySizeInBytes <span class="hljs-comment">// Number of bytes used for all headers</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">wrapEntry</span><span class="hljs-params">(timestamp <span class="hljs-type">uint64</span>, hash <span class="hljs-type">uint64</span>, key <span class="hljs-type">string</span>, entry []<span class="hljs-type">byte</span>, buffer *[]<span class="hljs-type">byte</span>)</span></span> []<span class="hljs-type">byte</span> &#123;<br>keyLength := <span class="hljs-built_in">len</span>(key)<br>blobLength := <span class="hljs-built_in">len</span>(entry) + headersSizeInBytes + keyLength<br><br><span class="hljs-keyword">if</span> blobLength &gt; <span class="hljs-built_in">len</span>(*buffer) &#123;<br>*buffer = <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, blobLength)<br>&#125;<br>blob := *buffer<br><br><span class="hljs-comment">// 按照小端序的方式，顺序写入时间戳、key的hash值、key的长度、key的实际值以及value的实际值</span><br>binary.LittleEndian.PutUint64(blob, timestamp)<br>binary.LittleEndian.PutUint64(blob[timestampSizeInBytes:], hash)<br>binary.LittleEndian.PutUint16(blob[timestampSizeInBytes+hashSizeInBytes:], <span class="hljs-type">uint16</span>(keyLength))<br><span class="hljs-built_in">copy</span>(blob[headersSizeInBytes:], key)<br><span class="hljs-built_in">copy</span>(blob[headersSizeInBytes+keyLength:], entry)<br><br><span class="hljs-keyword">return</span> blob[:blobLength]<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>RingBuffer满时，bigCache如何处理？<ul><li>如果entries queue.BytesQueue 未达到设定的HardMaxCacheSize（最大内存上限），或者无HardMaxCacheSize要求，则直接扩容queue.BytesQueue 直到达到上限。不过扩容的时候，是创建了一个新的空[]byte数组，把原有数据copy过去。</li><li>如果内存已达上限，无法继续扩容，则会尝试删除最旧数据（无论是否过期），直至可以将数据放到BytesQueue中。如果这个时候新数据非常大，可能会为此淘汰掉许多旧数据。</li></ul></li></ul><h3 id="2-5-锁冲突"><a href="#2-5-锁冲突" class="headerlink" title="2.5 锁冲突"></a>2.5 锁冲突</h3><p>BigCache使用Key的hash值查找数据，不可避免的会导致hash冲突问题。锁冲突在写入和读取的过程中都有可能发生。下面分别分析Set和Get的过程，顺便看看锁冲突是如何解决的。</p><ul><li>Set流程<ul><li>计算key的hash值，得到对应的shard</li><li>将key和value等信息序列化成指定格式的[]byte, push到BytesQueue中。</li><li>根据BytesQueue返回的偏移量(也就是数组下标)，将key(hash值)和value(数组下标)设置hashmap中。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *cacheShard)</span></span> set(key <span class="hljs-type">string</span>, hashedKey <span class="hljs-type">uint64</span>, entry []<span class="hljs-type">byte</span>) <span class="hljs-type">error</span> &#123;<br>currentTimestamp := <span class="hljs-type">uint64</span>(s.clock.epoch())<br><br>s.lock.Lock()<br><span class="hljs-comment">// 从这里可以看到，如果发现存在已有的hashKey（可能是冲突，也可能是本来就存在），bigcache并不会做特殊处理，而是直接将原本的位置reset，并将新的值push到最后，然后替换这个key的下标</span><br><span class="hljs-keyword">if</span> previousIndex := s.hashmap[hashedKey]; previousIndex != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> previousEntry, err := s.entries.Get(<span class="hljs-type">int</span>(previousIndex)); err == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// resetKeyFromEntry 会将条目中key的hash值置零</span><br>resetKeyFromEntry(previousEntry)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> oldestEntry, err := s.entries.Peek(); err == <span class="hljs-literal">nil</span> &#123;<br>s.onEvict(oldestEntry, currentTimestamp, s.removeOldestEntry)<br>&#125;<br><br><span class="hljs-comment">// 构建一个数据条目</span><br>w := wrapEntry(currentTimestamp, hashedKey, key, entry, &amp;s.entryBuffer)<br><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">// 将数据条目push到最后，并修改hashmap的值，就完成了增加或者更新</span><br><span class="hljs-keyword">if</span> index, err := s.entries.Push(w); err == <span class="hljs-literal">nil</span> &#123;<br>s.hashmap[hashedKey] = <span class="hljs-type">uint32</span>(index)<br>s.lock.Unlock()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">if</span> s.removeOldestEntry(NoSpace) != <span class="hljs-literal">nil</span> &#123;<br>s.lock.Unlock()<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;entry is bigger than max shard size&quot;</span>)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li>Get流程<ul><li>读数据，hash冲突时直接返回数据不存在，可能这也是存储key实际值的意义所在。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *cacheShard)</span></span> get(key <span class="hljs-type">string</span>, hashedKey <span class="hljs-type">uint64</span>) ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br>s.lock.RLock()<br>itemIndex := s.hashmap[hashedKey]<br><br><span class="hljs-comment">// bigcache 中， ringbuffer 的第 0 位并不用来存放任何数据，</span><br><span class="hljs-comment">// 如果发现 分片 map 中得到数据的 index 为 0，就可以直接认为没有对应的缓存数据</span><br><span class="hljs-keyword">if</span> itemIndex == <span class="hljs-number">0</span> &#123;<br>s.lock.RUnlock()<br>s.miss()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, ErrEntryNotFound<br>&#125;<br><br><span class="hljs-comment">// 从ringbuff中获取到指定key的条目数据</span><br>wrappedEntry, err := s.entries.Get(<span class="hljs-type">int</span>(itemIndex))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>s.lock.RUnlock()<br>s.miss()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-comment">// 从数据中解析出实际存储的key</span><br><span class="hljs-comment">// 如果实际存储的key跟查询的key不一致，说明产生了hash冲突，直接返回空</span><br><span class="hljs-keyword">if</span> entryKey := readKeyFromEntry(wrappedEntry); key != entryKey &#123;<br><span class="hljs-keyword">if</span> s.isVerbose &#123;<br>s.logger.Printf(<span class="hljs-string">&quot;Collision detected. Both %q and %q have the same hash %x&quot;</span>, key, entryKey, hashedKey)<br>&#125;<br>s.lock.RUnlock()<br>s.collision()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, ErrEntryNotFound<br>&#125;<br>entry := readEntry(wrappedEntry)<br>s.lock.RUnlock()<br>s.hit()<br><span class="hljs-keyword">return</span> entry, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2-6-数据删除"><a href="#2-6-数据删除" class="headerlink" title="2.6 数据删除"></a>2.6 数据删除</h3><p>BigCache的删除比较简单，本质上只是将key从map中删除，并没有实际删除BytesQueue中的数据，核心逻辑只有两行。实际值的删除会等到数据清理或者Buffer满的时候淘汰掉。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">...<br><span class="hljs-comment">// 从hashmap中删除key，使数据不可读</span><br><span class="hljs-built_in">delete</span>(s.hashmap, hashedKey)<br>...<br><span class="hljs-comment">// 将entry条目的key的hash值置零</span><br>resetHashFromEntry(wrappedEntry)<br>...<br></code></pre></td></tr></table></figure><h3 id="2-7-过期淘汰"><a href="#2-7-过期淘汰" class="headerlink" title="2.7 过期淘汰"></a>2.7 过期淘汰</h3><p>BigCache中的数据在删除数据或者Set数据时，如果碰到就值，只是删除或者修改hashmap中的值，并不会实际删除数据。实际的数据删除发生在过期淘汰时。</p><p>📌 <font color="red">BigCache没有开放单个元素的可过期时间，所有元素的cache时长都是一样的，这就意味着所有元素的过期时间在队列中天然有序。</font>    </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *cacheShard)</span></span> cleanUp(currentTimestamp <span class="hljs-type">uint64</span>) &#123;<br>s.lock.Lock()<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">// 只要存在元素，就逐个便利</span><br><span class="hljs-keyword">if</span> oldestEntry, err := s.entries.Peek(); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br><span class="hljs-comment">// 直至某个元素不过期为止</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> evicted := s.onEvict(oldestEntry, currentTimestamp, s.removeOldestEntry); !evicted &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>s.lock.Unlock()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3. 注意事项"></a>3. 注意事项</h2><h3 id="3-1-数据过期处理"><a href="#3-1-数据过期处理" class="headerlink" title="3.1 数据过期处理"></a>3.1 数据过期处理</h3><p>在bigcache中，LifeWindow和CleanWindow是两个用于缓存管理的重要参数，但它们有不同的作用。</p><ul><li>LifeWindow 是缓存条目的生存时间，决定了条目在多长时间内会被视为过期。</li><li>CleanWindow 是清理过程的时间间隔，决定了过期条目实际被清除的频率。</li></ul><p>这种机制使得bigcache在设计上允许读取过期数据。它不会主动阻止访问已经过期的缓存条目，除非这些条目在CleanWindow期间被清理掉。</p><p>bigcache的这种设计是为了优化性能，因为在每次访问缓存时都检查条目是否过期会带来额外的性能开销。通过异步清理过期条目，bigcache能够在不影响访问速度的情况下提供缓存功能。</p><p>如果对数据的时效性要求很高，需要手动在读取后检查数据是否过期，代码示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">item, err := cache.Get(<span class="hljs-string">&quot;myKey&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-comment">// Handle the error</span><br>&#125;<br><br>timestamp := extractTimestamp(item) <span class="hljs-comment">// 解析数据中的时间戳</span><br><span class="hljs-keyword">if</span> time.Since(timestamp) &gt; cacheLifeWindow &#123;<br>    <span class="hljs-comment">// Data is considered stale</span><br>    <span class="hljs-comment">// Handle the stale data case</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-参考文献"><a href="#4-参考文献" class="headerlink" title="4. 参考文献"></a>4. 参考文献</h2><p><a href="https://juejin.cn/post/7107635176263385118">https://juejin.cn/post/7107635176263385118</a></p><p><a href="https://www.cyhone.com/articles/bigcache/">https://www.cyhone.com/articles/bigcache/</a> </p><p><a href="https://mp.weixin.qq.com/s/e-ku-fLsLk0Ok2eTkdx6Dw">https://mp.weixin.qq.com/s/e-ku-fLsLk0Ok2eTkdx6Dw</a></p><p><a href="https://juejin.cn/post/7258840980428750885">https://juejin.cn/post/7258840980428750885</a></p><p><a href="https://xiaorui.cc/archives/7385">https://xiaorui.cc/archives/7385</a></p>]]></content>
    
    
    <categories>
      
      <category>系统设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BigCache</tag>
      
      <tag>本地缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>布隆过滤器</title>
    <link href="/2024/08/03/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <url>/2024/08/03/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>布隆过滤器（英语：Bloom Filter）是 1970 年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。主要用于判断一个元素是否在一个集合中。</p><span id="more"></span>  <h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>通常我们要判断一个元素是否在某个集合中时，经常想到的方式是将集合中所有元素保存起来，然后通过比较进行确定。链表、树、散列表（又叫哈希表，Hash table）等数据结构都是这种思路。但是随着集合中元素数量的增加，这几种方式需要的存储空间也会呈现线性增长，最终达到瓶颈。上述三种结构的检索时间复杂度分别为O(n)，O(logn)，O(1)。</p><h2 id="2-算法介绍"><a href="#2-算法介绍" class="headerlink" title="2. 算法介绍"></a>2. 算法介绍</h2><h3 id="2-1-原理"><a href="#2-1-原理" class="headerlink" title="2.1 原理"></a>2.1 原理</h3><p>布隆过滤器包含一个位数组和一组哈希函数。位数组每个元素存储的都是比特位，元素占用空间很小；使用一组哈希函数的原因是为了降低哈希冲突。</p><ul><li>初始状态：一个位数组，全部位置都置为0<br><img src="/img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/1.png"></li><li>数据加入：分别使用多个哈希函数对元素值进行计算，得到一组哈希值，将对应哈希值下标的数组值置为1<br><img src="/img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/2.png"></li><li>数据查找：对给定元素进行相同的哈希计算，判断每个位置的值是否都为1。如果值都为1，就认为这个元素存在，如果有一个值不唯一，就说明这个值不存在。</li></ul><p>📌 <font color="red">注意：布隆过滤器返回的结果是“可能存在”和“一定不存在”，不能提供“一定存在”的语义保证。因为可能有多个元素映射到同一个位置，导致误判。</font>    </p><h3 id="2-2-误判"><a href="#2-2-误判" class="headerlink" title="2.2 误判"></a>2.2 误判</h3><p>误判率（假阳性）：一个不存在的元素，可能会被误判为存在</p><h4 id="2-2-1-误判原因"><a href="#2-2-1-误判原因" class="headerlink" title="2.2.1 误判原因"></a>2.2.1 误判原因</h4><ul><li>哈希函数冲突：不同的哈希函数对元素进行映射时，可能会产生冲突，导致不同元素因素到位数组的相同位置。如下图所示：w的位置都已经是1，被认为w存在。</li><li>位数组大小限制：为减少空间占用，位数组大小有限。当存储的元素数量较多时，数据冲突可能性升高。<br><img src="/img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/3.png"></li></ul><h4 id="2-2-2-误判概率"><a href="#2-2-2-误判概率" class="headerlink" title="2.2.2 误判概率"></a>2.2.2 误判概率</h4><p>布隆过滤器的误判，主要是因为哈希函数存在冲突导致，即不同的值可能映射到同一个位置。在进行误判率的分析时，主要受到以下变量的制约：</p><ul><li><p>m：布隆过滤器的长度，即数组的长度</p></li><li><p>n： 集合中的元素个数</p></li><li><p>k： 哈希函数的个数<br><img src="/img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/4.png"></p></li><li><p>误判率：指定m、n、k情况下的误判率计算<br><img src="/img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/5.png"></p></li><li><p>长度：数组长度可以根据期望的误判率和元素个数来判断<br><img src="/img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/6.png"></p></li><li><p>哈希函数计算：指定m和n的情况下，减少误判的最佳哈希个数<br><img src="/img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/7.png"></p></li></ul><p>推导过程：</p><ul><li>添加1个元素，则任一比特为1的概率为：1&#x2F;m，任一比特为0的概率：1-1&#x2F;m；</li><li>添加1个元素，执行k次散列之后，则任一比特为0的概率：(1-1&#x2F;m)^k，任一比特为1的概率：1-(1-1&#x2F;m)^k；</li><li>如果添加n个元素，那么任一比特为0的概率：(1-1&#x2F;m)^kn，任一比特为1的概率：1-(1-1&#x2F;m)^kn；</li><li>如果将1个新的元素，添加到已存在n个元素的布隆过滤器中，则任一比特已经为1的概率与上面相同，概率为：1-(1-1&#x2F;m)^kn。因此，k个比特都为1的概率为：(1-(1-1&#x2F;m)^kn)^k，此即为新插入元素的误识别率。</li></ul><h3 id="2-3-无法删除"><a href="#2-3-无法删除" class="headerlink" title="2.3 无法删除"></a>2.3 无法删除</h3><p>布隆过滤器不允许删除元素：如果删除某个元素，导致对应位置为0，但是可能有多个元素映射到相同的位置上面，这样就会导致一个存在的元素被判断为不存在。破坏了“一定不存在”的语义保证。</p><p>📌 <font color="red">不允许删除的机制会导致其中的无效元素可能会越来越多，即实际已经在磁盘删除中的元素，但在布隆过滤器中还认为可能存在，这会造成越来越多的误判</font>   </p><h3 id="2-4-优缺点总结"><a href="#2-4-优缺点总结" class="headerlink" title="2.4 优缺点总结"></a>2.4 优缺点总结</h3><p>优点：</p><ul><li>插入、查询的效率高，时间复杂度为常数O(k)</li><li>空间占用小（存储空间占用是一个固定长度的bit数组）</li><li>散列函数相互之间没有关系，可以并行Hash</li><li>不存储原始数据，在严格要求保密的场景下有优势<br>缺点：</li><li>存在误报的可能性，尤其数据量越大越容易误报</li><li>只支持新增，不支持删除</li><li>数组长度和hash函数个数确定复杂</li><li>当过滤器数组过长时，查询性能差（多个哈希得到的下标跨度很大，CPU缓存命中率低）</li></ul><h2 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="3. 应用场景"></a>3. 应用场景</h2><p>布隆过滤器在实际项目开发中可以快速地解决一些问题，比如网页 URL 去重、垃圾邮件识别、大集合中重复元素的判断和缓存穿透等问题。<br>典型应用有：</p><ul><li>数据库防止穿库。 Google Bigtable，HBase 和 Cassandra 以及 Postgresql 使用BloomFilter减少不存在的行或列的磁盘查找。避免代价高昂的磁盘查找会大大提高数据库查询操作的性能。</li><li>业务场景中判断用户是否阅读过某视频或文章：比如抖音或头条，当然会导致一定的误判，但不会让用户看到重复的内容。</li><li>缓存穿透场景。在一些恶意请求中，请求参数都是缓存和数据中不存在的值，为了避免缓存穿透，可以用布隆过滤器先筛选一遍，只有在布隆过滤器中，才去查询缓存，如果没查询到，则穿透到db。如果不在布隆器中，则直接返回。</li><li>WEB拦截器，如果相同请求则拦截，防止重复被攻击。可以提高缓存命中率。Squid 网页代理缓存服务器在 cache digests 中就使用了布隆过滤器。Google Chrome浏览器使用了布隆过滤器加速安全浏览服务</li></ul><h2 id="4-实现"><a href="#4-实现" class="headerlink" title="4. 实现"></a>4. 实现</h2><p>基于Golang实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-string">&quot;github.com/bits-and-blooms/bitset&quot;</span><br>)<br><br><span class="hljs-comment">// 设置哈希数组默认大小为16</span><br><span class="hljs-keyword">const</span> DefaultSize = <span class="hljs-number">16</span><br><br><span class="hljs-comment">// 设置种子，保证不同哈希函数有不同的计算方式</span><br><span class="hljs-keyword">var</span> seeds = []<span class="hljs-type">uint</span>&#123;<span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">31</span>, <span class="hljs-number">37</span>, <span class="hljs-number">61</span>&#125;<br><br><span class="hljs-comment">// 构造6个哈希函数，每个哈希函数有参数seed保证计算方式的不同</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildHash</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(seed <span class="hljs-type">uint</span>, value <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">uint</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(seed <span class="hljs-type">uint</span>, value <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">uint</span> &#123;<br><span class="hljs-keyword">var</span> result <span class="hljs-type">uint</span> = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(value); i++ &#123;<br>result = result*seed + <span class="hljs-type">uint</span>(value[i])<br>&#125;<br><span class="hljs-keyword">return</span> result &amp; (DefaultSize - <span class="hljs-number">1</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 布隆过滤器结构，包括二进制数组和多个哈希函数</span><br><span class="hljs-keyword">type</span> BloomFilter <span class="hljs-keyword">struct</span> &#123;<br>set       *bitset.BitSet<br>hashFuncs [<span class="hljs-number">6</span>]<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(seed <span class="hljs-type">uint</span>, value <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">uint</span><br>&#125;<br><br><span class="hljs-comment">// 构造一个布隆过滤器，包括数组和哈希函数的初始化</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewBloomFilter</span><span class="hljs-params">()</span></span> *BloomFilter &#123;<br>bf := <span class="hljs-built_in">new</span>(BloomFilter)<br>bf.set = bitset.New(DefaultSize)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(bf.hashFuncs); i++ &#123;<br>bf.hashFuncs[i] = buildHash()<br>&#125;<br><span class="hljs-keyword">return</span> bf<br>&#125;<br><br><span class="hljs-comment">// Add 添加元素，将哈希函数计算结果对应的数组位置1</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *BloomFilter)</span></span> Add(value <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">for</span> i, f := <span class="hljs-keyword">range</span> b.hashFuncs &#123;<br>b.set.Set(f(seeds[i], value))<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Contains 查询元素是否存在，调用每个哈希函数，并且判断数组对应位是否为1 如果不为1，直接返回false，表明一定不存在</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *BloomFilter)</span></span> Contains(value <span class="hljs-type">string</span>) <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">for</span> i, f := <span class="hljs-keyword">range</span> b.hashFuncs &#123;<br><span class="hljs-keyword">if</span> !b.set.Test(f(seeds[i], value)) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>filter := NewBloomFilter()<br>filter.Add(<span class="hljs-string">&quot;hello&quot;</span>)<br>filter.Add(<span class="hljs-string">&quot;world&quot;</span>)<br>fmt.Println(filter.Contains(<span class="hljs-string">&quot;hello&quot;</span>))<br>fmt.Println(filter.Contains(<span class="hljs-string">&quot;world&quot;</span>))<br>fmt.Println(filter.Contains(<span class="hljs-string">&quot;xiao&quot;</span>))<br>fmt.Println(filter.Contains(<span class="hljs-string">&quot;xiaoming&quot;</span>)) <span class="hljs-comment">// 出现误判</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-演进变体"><a href="#5-演进变体" class="headerlink" title="5. 演进变体"></a>5. 演进变体</h2><p>针对布隆过滤器的上述一些问题，逐步产生了一些布隆过滤器的变体，简单介绍如下：</p><h3 id="5-1-计数布隆过滤器-Counting-Bloom-Filter"><a href="#5-1-计数布隆过滤器-Counting-Bloom-Filter" class="headerlink" title="5.1 计数布隆过滤器 Counting Bloom Filter"></a>5.1 计数布隆过滤器 Counting Bloom Filter</h3><ul><li>特点：支持删除</li><li>原理：CountingBloomFilter是BloomFilter的一个变种，它扩展标准布隆过滤器的数据结构，将底层数组的每一位扩展为一个4位大小的计数器Counter，用来存储某个下标映射成功的频次。它以占用更多的空间来换取支持删除操作。</li></ul><ol><li>插入元素时，通过k个哈希函数映射到k个计数器，这些命中的计数器值增加1；</li><li>删除元素时，删除元素的时候，通过k个散列函数映射到k个计数器，这些计数器值减少1。<br><img src="/img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/8.png"></li></ol><p>优点：</p><ul><li>除了占用存储空间翻（多）倍，继承了布隆过滤器的所有优点；支持删除。</li></ul><p>缺点：</p><ul><li>误报的概率仍然存在</li><li>需要额外考虑 Counter 数组中每个 Counter 的大小（最好具备溢出策略）</li><li>存储空间较布隆过滤器翻（多）倍</li></ul><h3 id="5-2-扩展布隆过滤器-Scalable-Bloom-Filter"><a href="#5-2-扩展布隆过滤器-Scalable-Bloom-Filter" class="headerlink" title="5.2 扩展布隆过滤器 Scalable Bloom Filter"></a>5.2 扩展布隆过滤器 Scalable Bloom Filter</h3><ul><li>特点：支持扩容</li><li>原理：Scalable Bloom Filter只会向最后一层插入数据，同时也从最后一层开始查询，直到查询至 BF0 层。<br><img src="/img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/9.png"></li></ul><ol><li>插入过程：只会向最后一层插入数据<ol><li>初始，SBF只包含BF0这一层，插入了a、b、c三个元素。</li><li>然后，假设BF0已经无法保证用户设定的误判率，此时就需要进行扩容，因此新的一层BF1被创建并加入进来。后来的d、e、f元素都会被插入到BF1中。</li><li>同理，当BF1也无法满足该层事先设定的误判率时，新的一层BF2也将被加入进来，如此进行下去。</li></ol></li><li>查询过程：从最后一层开始由后向前查询<ol><li>首先在BF1中进行查询。如果查询显示存在，则直接响应客户端；</li><li>如果查询显示不存在，则继续查询BF0。如果BF0中显示存在g，则响应客户端g存在。否则，因为BF0已经是最后一层了，则响应客户端g不存在。</li></ol></li></ol><p>缺点：</p><ul><li>查询开销：需要查询多个布隆过滤器，较单一布隆过滤器增加了一定的查询时间开销。</li><li>管理复杂度：维护多个布隆过滤器的策略相对复杂。</li></ul><h3 id="5-2-布谷鸟过滤器-Cuckoo-Filter"><a href="#5-2-布谷鸟过滤器-Cuckoo-Filter" class="headerlink" title="5.2 布谷鸟过滤器 Cuckoo Filter"></a>5.2 布谷鸟过滤器 Cuckoo Filter</h3><p>布谷鸟过滤器是布隆过滤器的变体，提供了删除元素的功能。它主要基于布谷鸟哈希和指纹技术。当插入一个元素时，布谷鸟过滤器存储该元素的“指纹”到哈希表的某个位置上。如果该位置已被占用，现有的元素会被移动到另一个位置，如此迭代下去，直到每个元素都有自己的位置为止。</p><p>最简单的布谷鸟哈希结构是一维数组结构</p><ol><li>每个元素都由哈希函数h1(x)和h2(x)确定两个候选位置，查找过程会检查两个位置是否任意一个位置为空。</li><li>如果两个位置中任何一个是空的，则算法将元素插入到该空位置中，插入完成；</li><li>如果两个位置都是满的，会选择一个候选位置踢出去现有的元素(鸠占鹊巢)，并将此被踢出元素重新插入到它的备用位置。这个过程可能会重复，直到找到一个空位置或达到最大位移次数。如果没有找到空位置，则认为此哈希表太满，则进行扩容和ReHash后，再次插入。<br><img src="/img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/10.png"></li></ol><h2 id="6-参考资料"><a href="#6-参考资料" class="headerlink" title="6. 参考资料"></a>6. 参考资料</h2><p>布隆过滤器：<br><a href="https://segmentfault.com/a/1190000021136424">https://segmentfault.com/a/1190000021136424</a><br><a href="https://segmentfault.com/a/1190000024566947">https://segmentfault.com/a/1190000024566947</a></p><p>计数布隆过滤器：<br><a href="https://juejin.cn/post/7362729128477638675">https://juejin.cn/post/7362729128477638675</a> </p><p>布谷鸟过滤器：<br><a href="https://www.cnblogs.com/zhaodongge/p/15067657.html">https://www.cnblogs.com/zhaodongge/p/15067657.html</a><br><a href="https://dbwu.tech/posts/cuckoo_filter/">https://dbwu.tech/posts/cuckoo_filter/</a></p>]]></content>
    
    
    <categories>
      
      <category>系统设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>布隆过滤器</tag>
      
      <tag>系统设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang中的Defer、Panic和Recover</title>
    <link href="/2024/07/13/Golang%E4%B8%ADdefer-panic-recvover%E5%88%86%E6%9E%90/"/>
    <url>/2024/07/13/Golang%E4%B8%ADdefer-panic-recvover%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>Golang中没有类似java的try catch机制进行异常处理，而是引入了defer、panic和recover来触发异常和终止异常。</p><span id="more"></span>  <h2 id="1-Defer"><a href="#1-Defer" class="headerlink" title="1. Defer"></a>1. Defer</h2><p>defer是go语言提供的一种用于注册延迟调用的机制：让函数或者语句可以在当前函数执行完毕后执行（包括通过return正常结束或者panic导致的异常结束）。</p><p>常用于一些操作后的收尾工作，比如关闭连接、释放锁、关闭文件等，使用起来比较优雅。  </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs golang">f, _ := os.Open(<span class="hljs-string">&quot;defer.txt&quot;</span>)<br><span class="hljs-keyword">defer</span> f.Close()  <br></code></pre></td></tr></table></figure><h3 id="1-1-Defer基本原理"><a href="#1-1-Defer基本原理" class="headerlink" title="1.1 Defer基本原理"></a>1.1 Defer基本原理</h3><p>defer使用准则</p><ul><li><p>每次defer语句执行的时候，会把函数“压栈”，函数参数会被拷贝下来，但是闭包引用不会</p><ul><li>作为函数参数：在defer定义时就把值传递给defer，并被cache起来，后续不会再改变</li><li>作为闭包引用：在defer函数真正调用时根据整个上下文确定当前的值。</li></ul></li><li><p>当外层逻辑退出时，defer函数按照定义的逆序执行；【先入后出，压栈进行】</p></li><li><p>恰当的使用defer方法可以修改返回值  </p></li><li><p>先入后出</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++ &#123;<br><span class="hljs-keyword">defer</span> fmt.Println(i)<br>&#125;<br>&#125; <br><span class="hljs-comment">// 输出 3 2 1</span><br></code></pre></td></tr></table></figure></li><li><p>defer函数的参数引用方式</p><ul><li>作为函数入参，在函数定义时就已经传递给defer函数，后续不会再改变  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">b</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++ &#123;<br>        <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a <span class="hljs-type">int</span>)</span></span> &#123;<br>            fmt.Println(a)<br>        &#125;(i)<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 输出 3 2 1</span><br></code></pre></td></tr></table></figure></li><li>作为闭包的引用时，在最后执行的时候确定上下文的值  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">c</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++ &#123;<br>        <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            fmt.Println(i)<br>        &#125;()<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 输出 4 4 4 </span><br><span class="hljs-comment">// i = 3 时定义最后一个defer，又进行了+1操作后，才真正开始执行defer函数</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="1-2-defer命令拆解"><a href="#1-2-defer命令拆解" class="headerlink" title="1.2 defer命令拆解"></a>1.2 defer命令拆解</h3><p>上面说defer可以操作返回值，本质上就是在含有defer函数的代码中，一个 return xxx的语句可以进行拆解，这条语句在实际执行时分三步进行：</p><blockquote><ol><li>返回值 &#x3D; xxx</li><li>执行defer函数</li><li>空的return</li></ol></blockquote><p>典型案例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">d</span><span class="hljs-params">()</span></span> (r <span class="hljs-type">int</span>) &#123;<br>t := <span class="hljs-number">5</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>t = t + <span class="hljs-number">5</span><br>&#125;()<br><span class="hljs-keyword">return</span> t<br>&#125;<br><span class="hljs-comment">// 返回 5</span><br><span class="hljs-comment">// r=t; t=t+5; return </span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">e</span><span class="hljs-params">()</span></span> (r <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(r <span class="hljs-type">int</span>)</span></span> &#123;<br>r = r + <span class="hljs-number">5</span><br>&#125;(r)<br><span class="hljs-keyword">return</span> <span class="hljs-number">5</span><br>&#125;<br><span class="hljs-comment">// 返回 5</span><br><span class="hljs-comment">// r = 5； r=r+5（这个r为形参r，不是返回值r）； return</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> (r <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>r = r + <span class="hljs-number">5</span><br>&#125;()<br><span class="hljs-keyword">return</span> <span class="hljs-number">5</span><br>&#125;<br><br><span class="hljs-comment">// 返回 10</span><br><span class="hljs-comment">// r = 5； r=r+5； return</span><br></code></pre></td></tr></table></figure><p>从以上的实际案例中可以看到：</p><p>📌 <font color="red">能通过defer修改返回值的场景，一定是有命名返回值的函数场景。</font>  </p><h2 id="2-Painc和Recover"><a href="#2-Painc和Recover" class="headerlink" title="2. Painc和Recover"></a>2. Painc和Recover</h2><p>当go在运行过程中发送异常时，Go运行时会触发运行时panic，并在调用它的函数中向本层以及所有上层逐级抛出，若一直没有recover捕获，程序最终会终止。  </p><p>若在某层defer语句中被recover捕获，控制流程将进入到recover之后的语句中。通过panic、defer和recover，可以实现类似try catch的功能。  </p><p>例如： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;defer in&quot;</span>)<br><span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br>&#125;()<br><br>fmt.Println(<span class="hljs-string">&quot;panic begin&quot;</span>)<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;hello, I&#x27;m panic&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;panic end&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 输出</span><br><span class="hljs-comment">// panic begin</span><br><span class="hljs-comment">// defer in</span><br><span class="hljs-comment">// hello, I&#x27;m panic</span><br></code></pre></td></tr></table></figure><p>📌 <font color="red">注意：defer中的recover仅对当前协程生效，且仅在直接被defer函数调用才有效</font>    </p><h3 id="2-1-Recover使用规则"><a href="#2-1-Recover使用规则" class="headerlink" title="2.1 Recover使用规则"></a>2.1 Recover使用规则</h3><p>Recover在使用的过程中，一般会判断返回值是否为空，当返回值为空的时候代表没有正常捕获问题。golang官方介绍了几种Recover返回为空的场景。</p><ol><li>panic的参数为空</li><li>当前协程没有panic</li><li>recover没有直接被defer函数调用</li></ol><p>分别介绍如下：</p><ul><li><p>panic参数为空，可以正常捕获 &#x2F;&#x2F; 本身panic参数为nil时候等同于没有发送panic</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;panic: %v&quot;</span>, err)<br>&#125;<br>&#125;()<br><br><span class="hljs-built_in">panic</span>(<span class="hljs-literal">nil</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>跨协程调用recover函数，无法捕获异常</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// panic跟recover不在一个协程，无法捕获异常</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>log.Println(<span class="hljs-built_in">recover</span>())<br>&#125;()<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;A bad boy stole a server&quot;</span>)<br>&#125;()<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>不在defer函数中直接调用，无法捕获异常</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 对 recover进行了一层封装，无法正常生效</span><br>Recover(<span class="hljs-string">&quot;Panic in goroutine&quot;</span>)<br>&#125;()<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;A bad boy stole the server&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Recover</span><span class="hljs-params">(funcName <span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;panic para: %v, panic info: %v\n&quot;</span>, funcName, err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>进阶分析</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// recover是在匿名函数/闭包中使用，实际执行时取值，触发panic后有值</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>log.Print(<span class="hljs-built_in">recover</span>(), <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;, a handsome police catch him.\n\n&quot;</span><br>&#125;())<br>&#125;()<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;A bad boy stole a server&quot;</span>)<br>&#125;()<br><br>time.Sleep(<span class="hljs-number">3</span> * time.Second)<br><br><span class="hljs-comment">// recover作为函数参数使用，定义时就完成值拷贝，刚开始没报错，最后也不会有值。</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> log.Print(<span class="hljs-built_in">recover</span>(), <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;, but a handsome police catch nothing.\n&quot;</span><br>&#125;())<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;A bad boy stole a server, again.&quot;</span>)<br>&#125;()<br>time.Sleep(<span class="hljs-number">3</span> * time.Second)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-2-Defer、Panic、Recover原理浅析"><a href="#2-2-Defer、Panic、Recover原理浅析" class="headerlink" title="2.2 Defer、Panic、Recover原理浅析"></a>2.2 Defer、Panic、Recover原理浅析</h3><p><img src="/img/Golang%E4%B8%ADdefer-panic-recvover%E5%88%86%E6%9E%90/2.png"><br>异常恢复流程可以总结成以下主要流程：</p><ul><li>触发panic流程：panic终止程序的过程是由编译器将关键字 panic 转换成 runtime.gopanic() 内置函数。异常恢复的流程基本都在这个函数中：<ul><li>首先会创建一个_panic结构体用来记录当前panic，并且将当前panic加入当前goroutine的_panic链表</li><li>然后循环从当前 goroutine 的_defer链表中获取runtime._defer并调用runtime.reflectcall()运行defer函数。</li></ul></li><li>恢复流程：如果defer函数中如果recover调用，recover会被汇编转换成runtime.gorecover调用，该函数会标记该panic已经被recover。在执行完某个defer后，如果该panic被标记为recover，则会调用runtime.recovery恢复goroutine的执行。</li><li>崩溃流程：如果_defer链表为空，或者执行完所有的defer都不包含recover调用，则会调用runtime.fatalpanic打印panic信息，然后中止&#x2F;退出程序。</li></ul><h2 id="3-参考资料"><a href="#3-参考资料" class="headerlink" title="3. 参考资料"></a>3. 参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/487749806">https://zhuanlan.zhihu.com/p/487749806</a> </p><p><a href="https://zhuanlan.zhihu.com/p/689615742">https://zhuanlan.zhihu.com/p/689615742</a></p><p><a href="https://go101.org/article/panic-and-recover-use-cases.html">https://go101.org/article/panic-and-recover-use-cases.html</a> </p><p><a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/">https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/</a></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>异常处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB查询性能分析-Explain</title>
    <link href="/2024/06/30/MongoDB%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-Explain/"/>
    <url>/2024/06/30/MongoDB%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-Explain/</url>
    
    <content type="html"><![CDATA[<p>在日常的MongoDB开发和使用中，不可避免的会碰到一些慢查询的问题，针对这些问题，我们一般可以使用 explain 方法来获取查询的执行计划和性能分析信息。使用explain方法可以帮助我们理解查询是如何执行的，以及识别性能瓶颈和优化对象。</p><span id="more"></span>   <h2 id="1-Explain简介"><a href="#1-Explain简介" class="headerlink" title="1. Explain简介"></a>1. Explain简介</h2><h3 id="1-1-基本使用"><a href="#1-1-基本使用" class="headerlink" title="1.1 基本使用"></a>1.1 基本使用</h3><p>使用 explain 方法；你可以在任何查询、更新或删除操作中使用 explain 方法。以下是一些基本示例。<br>假设你有一个集合 myCollection，你可以如下进行操作：</p><ul><li><p>对查询操作使用 explain   </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.myCollection.find(&#123; a: &#123; $gt: <span class="hljs-number">1</span>, $lt: <span class="hljs-number">2</span> &#125; &#125;).explain() <br></code></pre></td></tr></table></figure><p>这将返回查询的执行计划，包括扫描类型、索引使用情况和其他详细信息。</p></li><li><p>对更新操作使用 explain   </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.myCollection.updateMany(&#123; a: &#123; $gt: <span class="hljs-number">1</span>, $lt: <span class="hljs-number">2</span> &#125; &#125;, &#123; $<span class="hljs-keyword">set</span>: &#123; b: <span class="hljs-number">1</span> &#125; &#125;).explain() <br></code></pre></td></tr></table></figure></li><li><p>对删除操作使用 explain    </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.myCollection.deleteMany(&#123; a: &#123; $gt: <span class="hljs-number">1</span>, $lt: <span class="hljs-number">2</span> &#125; &#125;).explain() <br></code></pre></td></tr></table></figure></li></ul><h3 id="1-2-输出含义解析"><a href="#1-2-输出含义解析" class="headerlink" title="1.2 输出含义解析"></a>1.2 输出含义解析</h3><p>explain 方法返回一个包含以下信息的文档：</p><ul><li><p>queryPlanner：描述查询计划的信息。</p><ul><li>plannerVersion：查询规划器的版本。</li><li>namespace：查询的命名空间（即数据库和集合）。</li><li>indexFilterSet：是否设置了索引过滤。</li><li>parsedQuery：解析后的查询条件。</li><li>winningPlan：实际执行的查询计划。<font color="red">（winningPlan比较重要，一般可以看出当前查询语句使用的索引计划等，方便问题排查）</font></li><li>rejectedPlans：被拒绝的查询计划（如果有）。</li></ul></li><li><p>executionStats：提供查询执行的统计信息（仅在使用 executionStats 或 allPlansExecution 模式时）。</p><ul><li>executionSuccess：查询是否成功执行。</li><li>nReturned：返回的文档数量。</li><li>executionTimeMillis：查询执行时间（毫秒）。</li><li>totalKeysExamined：检查的索引键数量。</li><li>totalDocsExamined：检查的文档数量。</li><li>serverInfo：有关服务器的信息。</li></ul></li></ul><h3 id="1-3-模式差别"><a href="#1-3-模式差别" class="headerlink" title="1.3 模式差别"></a>1.3 模式差别</h3><p>explain 方法有三种模式, 可以通过传递参数来指定模式。</p><ul><li>queryPlanner（默认）：只返回查询计划，不包含实际执行统计信息。  </li><li>executionStats：返回查询计划和执行统计信息。  </li><li>allPlansExecution：返回所有执行计划和它们的执行统计信息。</li></ul><h3 id="1-4-具体案例分析"><a href="#1-4-具体案例分析" class="headerlink" title="1.4 具体案例分析"></a>1.4 具体案例分析</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.myCollection.find(&#123; a: &#123; $gt: <span class="hljs-number">1</span>, $lt: <span class="hljs-number">2</span> &#125; &#125;).explain(&quot;executionStats&quot;) <br></code></pre></td></tr></table></figure><p>以下是一个 explain 方法的示例输出：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;queryPlanner&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;plannerVersion&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;namespace&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;myDatabase.myCollection&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;indexFilterSet&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;parsedQuery&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;a&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;$gt&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;$lt&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;winningPlan&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;stage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;FETCH&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;inputStage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;stage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;IXSCAN&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;keyPattern&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;a&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;indexName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;a_1&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;isMultiKey&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;multiKeyPaths&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;a&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;isUnique&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;isSparse&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;isPartial&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;indexVersion&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;direction&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;forward&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;indexBounds&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;a&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-string">&quot;(1.0, 2.0)&quot;</span><br>          <span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;rejectedPlans&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;executionStats&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;executionSuccess&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;nReturned&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;executionTimeMillis&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;totalKeysExamined&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;totalDocsExamined&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;executionStages&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;stage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;FETCH&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;nReturned&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;executionTimeMillisEstimate&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;works&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;advanced&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;needTime&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;needFetch&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;saveState&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;restoreState&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;isEOF&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;docsExamined&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;alreadyHasObj&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;inputStage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;stage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;IXSCAN&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;nReturned&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;executionTimeMillisEstimate&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;works&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;advanced&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;needTime&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;needFetch&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;saveState&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;restoreState&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;isEOF&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;keyPattern&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;a&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;indexName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;a_1&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;isMultiKey&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;multiKeyPaths&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;a&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;isUnique&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;isSparse&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;isPartial&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;indexVersion&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;direction&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;forward&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;indexBounds&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;a&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-string">&quot;(1.0, 2.0)&quot;</span><br>          <span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;keysExamined&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;seeks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;dupsTested&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;dupsDropped&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;seenInvalidated&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;serverInfo&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;localhost&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">27017</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;4.2.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;gitVersion&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2b62a68cfa4efae44c9a66b09a38df7e48fdbe73&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>通过分析 explain 输出，你可以了解查询是如何执行的，并据此优化索引和查询语句。</p><h2 id="2-ExecutionStats中的时间分析"><a href="#2-ExecutionStats中的时间分析" class="headerlink" title="2 ExecutionStats中的时间分析"></a>2 ExecutionStats中的时间分析</h2><p>在 MongoDB 的 explain 输出中，executionStats 部分包含了查询的执行统计信息。其中包括执行评估时间（executionTimeMillisEstimate）和实际执行时间（executionTimeMillis）。这两个时间指标有不同的含义和用途：</p><ul><li>executionTimeMillisEstimate：<ul><li>含义：执行评估时间（或执行时间估计）。</li><li>作用：这是对特定阶段或步骤的执行时间的估计值。这个值是由 MongoDB 查询引擎内部计算得出的，用于提供一个大致的时间估计，帮助了解查询各个阶段所消耗的时间。</li><li>使用场景：在分析查询计划中各个阶段的性能时，executionTimeMillisEstimate 可以帮助确定每个阶段的大致执行时间，从而识别可能的性能瓶颈。</li></ul></li><li>executionTimeMillis：<ul><li>含义：实际执行时间。</li><li>作用：这是查询从开始到结束实际花费的时间，以毫秒为单位。这个时间包括整个查询执行过程中的所有步骤和阶段。</li><li>使用场景：executionTimeMillis 提供了查询的总体执行时间，用于衡量查询的整体性能。</li></ul></li></ul><p>假设有以下 explain 输出：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;executionStats&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;executionSuccess&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;nReturned&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;executionTimeMillis&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">5</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;totalKeysExamined&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;totalDocsExamined&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;executionStages&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;stage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;FETCH&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;nReturned&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;executionTimeMillisEstimate&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;works&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;advanced&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;needTime&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;needFetch&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;saveState&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;restoreState&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;isEOF&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;docsExamined&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;alreadyHasObj&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;inputStage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;stage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;IXSCAN&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;nReturned&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;executionTimeMillisEstimate&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;works&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;advanced&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;needTime&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;needFetch&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;saveState&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;restoreState&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;isEOF&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;keyPattern&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;a&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;indexName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;a_1&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;isMultiKey&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;multiKeyPaths&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;a&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;isUnique&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;isSparse&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;isPartial&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;indexVersion&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;direction&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;forward&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;indexBounds&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;a&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-string">&quot;(1.0, 2.0)&quot;</span><br>          <span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;keysExamined&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;seeks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;dupsTested&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;dupsDropped&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;seenInvalidated&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li>executionTimeMillis：整个查询实际执行时间为 5 毫秒。</li><li>executionTimeMillisEstimate（FETCH 阶段）：这个阶段的执行时间估计为 2 毫秒。</li><li>executionTimeMillisEstimate（IXSCAN 阶段）：这个阶段的执行时间估计为 1 毫秒。</li></ul><p>通过结合这两个时间指标，可以更好地优化查询，改进性能。例如，如果某个阶段的 executionTimeMillisEstimate 特别高，可以考虑优化该阶段的索引或查询逻辑。</p><h2 id="3-WinningPaln中的Stage有哪些"><a href="#3-WinningPaln中的Stage有哪些" class="headerlink" title="3. WinningPaln中的Stage有哪些"></a>3. WinningPaln中的Stage有哪些</h2><p>在 MongoDB 查询计划（explain 输出的 winningPlan 部分）中，查询计划由多个阶段（Stage）组成，每个阶段代表查询执行过程中的一个步骤。主要包括如下类型：</p><ul><li>COLLSCAN（Collection Scan）：<ul><li>扫描整个集合的所有文档，通常是因为没有可用的索引。</li><li>使用场景：没有适用的索引，或者是全表扫描。-</li></ul></li><li>IXSCAN（Index Scan）：<ul><li>扫描索引，查找符合条件的索引条目。</li><li>使用场景：查询条件可以利用索引。</li></ul></li><li>FETCH：<ul><li>从磁盘中读取文档，通常跟在 IXSCAN 之后，通过索引查找后获取实际文档。</li><li>使用场景：通过索引查找后，需要获取完整文档。</li></ul></li><li>LIMIT：<ul><li>限制结果集的数量。</li><li>使用场景：查询中使用 limit 操作。</li></ul></li><li>SKIP：<ul><li>跳过结果集中的前若干个文档。</li><li>使用场景：查询中使用 skip 操作。</li></ul></li><li>SORT：<ul><li>对结果集进行排序。</li><li>使用场景：查询中使用 sort 操作。</li></ul></li><li>PROJECTION：<ul><li>对结果集进行字段投影，只返回指定的字段。</li><li>使用场景：查询中使用字段选择器。</li></ul></li><li>SHARD_MERGE：<ul><li>从多个分片中合并结果集。</li><li>使用场景：在分片集群环境中，跨分片查询。</li></ul></li><li>TEXT：<ul><li>执行全文搜索查询。</li><li>使用场景：查询中使用 $text 操作符。</li></ul></li><li>GEO_NEAR：<ul><li>执行地理位置查询，查找距离某点最近的文档。</li><li>使用场景：查询中使用 $near 或 $geoNear 操作符。</li></ul></li><li>GROUP：<ul><li>执行分组操作，类似于 SQL 的 GROUP BY。</li><li>使用场景：查询中使用聚合管道中的 $group 操作符。</li></ul></li><li>UNWIND：<ul><li>拆分数组字段，将每个数组元素作为单独的文档。</li><li>使用场景：查询中使用聚合管道中的 $unwind 操作符。</li></ul></li><li>LOOKUP：<ul><li>执行联表查询，将一个集合中的文档与另一个集合中的文档进行连接。</li><li>使用场景：查询中使用聚合管道中的 $lookup 操作符。</li></ul></li><li>REDUCE：<ul><li>在 MapReduce 操作中，执行 reduce 阶段。</li><li>使用场景：使用 MapReduce 执行复杂聚合操作。</li></ul></li></ul><p>假设有一个集合 myCollection，使用以下查询并结合 explain 查看查询计划：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.myCollection.find(&#123; a: &#123; $gt: <span class="hljs-number">1</span>, $lt: <span class="hljs-number">2</span> &#125; &#125;).sort(&#123; b: <span class="hljs-number">-1</span> &#125;).limit(<span class="hljs-number">5</span>).explain()<br></code></pre></td></tr></table></figure><p>得到的 explain 输出可能包含以下阶段：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;queryPlanner&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;winningPlan&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;stage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;LIMIT&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;limitAmount&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">5</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;inputStage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;stage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;SORT&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;sortPattern&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;b&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">-1</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;inputStage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;stage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;FETCH&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;inputStage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;stage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;IXSCAN&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;keyPattern&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;a&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;indexName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;a_1&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;isMultiKey&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;direction&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;forward&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;indexBounds&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;a&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;(1.0, 2.0)&quot;</span><br>              <span class="hljs-punctuation">]</span><br>            <span class="hljs-punctuation">&#125;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>LIMIT 阶段：限制结果集数量为 5。</li><li>SORT 阶段：按 b 字段进行降序排序。</li><li>FETCH 阶段：通过索引查找后，从磁盘中读取完整文档。</li><li>IXSCAN 阶段：扫描 a_1 索引，查找 a 字段在 (1, 2) 范围内的索引条目。</li></ul><p>通过理解这些阶段，可以更好地分析和优化查询性能。例如，确保查询尽可能利用索引，减少全表扫描（COLLSCAN）。</p>]]></content>
    
    
    <categories>
      
      <category>MongoDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能分析</tag>
      
      <tag>Explain</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang Json Unmarshal 大数精度丢失问题</title>
    <link href="/2024/05/08/Golang-Json-Unmarshal-%E5%A4%A7%E6%95%B0%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/"/>
    <url>/2024/05/08/Golang-Json-Unmarshal-%E5%A4%A7%E6%95%B0%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>在Golang中，使用Unmarshal将一个Json数字解析为<code>interface&#123;&#125;</code>时, int64等大类型数字会存在精度丢失的问题。    </p><p>一般来说，长度超过16位的数字易发生数据截断，而且数据值变成了科学计数法。</p><span id="more"></span>   <h2 id="1-案例介绍"><a href="#1-案例介绍" class="headerlink" title="1. 案例介绍"></a>1. 案例介绍</h2><p>假设有一个长度为17的json大数字</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">var</span> str = <span class="hljs-string">`&#123;&quot;id&quot;:10000649949036001&#125;`</span><br></code></pre></td></tr></table></figure><p>如果直接使用json的interface进行解析, 会得到 10000649949036000, 而不是我们想要的10000649949036001 </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ParseWithInterface</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> test <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;<br><br><span class="hljs-keyword">if</span> err := json.Unmarshal([]<span class="hljs-type">byte</span>(str), &amp;test); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br><br>fmt.Println(test)<br><br>dataBytes, err := json.Marshal(test)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%+s\n&quot;</span>, <span class="hljs-type">string</span>(dataBytes))<br>&#125;<br><br><span class="hljs-comment">// 输出</span><br><span class="hljs-comment">// map[id:1.0000649949036e+16]</span><br><span class="hljs-comment">// &#123;&quot;id&quot;:10000649949036000&#125;  </span><br><br></code></pre></td></tr></table></figure><h2 id="2-原因分析"><a href="#2-原因分析" class="headerlink" title="2. 原因分析"></a>2. 原因分析</h2><p>原因就出在了interface{}上，在golang中，当数据结构未知，使用map[string]interface{}接收反序列化结果时，会使用float64来进行结果解析，而float类型在处理的过程中时会有精度丢失的，一般超过16位就会发生，同时float64在处理的数据的时候，一般超过6位就会变成科学记数法。使用float64对json number进行解析可以在json的官方代码中找到。</p><blockquote><p>&#x2F;&#x2F; To unmarshal JSON into an interface value,<br>&#x2F;&#x2F; Unmarshal stores one of these in the interface value:<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;bool, for JSON booleans<br>&#x2F;&#x2F;float64, for JSON numbers<br>&#x2F;&#x2F;string, for JSON strings<br>&#x2F;&#x2F;[]interface{}, for JSON arrays<br>&#x2F;&#x2F;map[string]interface{}, for JSON objects<br>&#x2F;&#x2F;nil for JSON null</p></blockquote><h2 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3. 解决方案"></a>3. 解决方案</h2><p>既然上文已经说了int64反序列化精度丢失的原因是使用了float64进行解析，那么我们只需要在解析时强行指定不使用float64解析即可。</p><h3 id="3-1-使用Int64解析"><a href="#3-1-使用Int64解析" class="headerlink" title="3.1 使用Int64解析"></a>3.1 使用Int64解析</h3><p>在知道具体类型的情况下，可以直接定义结构体为map[string]int64, 这样在解析时，就会使用int64进行解析。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ParseWithInt64</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> data <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int64</span><br>str := <span class="hljs-string">`&#123;&quot;id&quot;:10000649949036001&#125;`</span><br>err := json.Unmarshal([]<span class="hljs-type">byte</span>(str), &amp;data)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br><br>fmt.Println(data)<br>&#125;<br><span class="hljs-comment">// 输出</span><br><span class="hljs-comment">// map[id:10000649949036001]</span><br></code></pre></td></tr></table></figure><h3 id="3-2-利用UseNumber"><a href="#3-2-利用UseNumber" class="headerlink" title="3.2 利用UseNumber"></a>3.2 利用UseNumber</h3><p>golang json提供了一种额外的解析方式，可以在解析的过程使用指定使用Number类型而不是float64进行解析，这样就可以避免精度丢失的问题。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// convertNumber converts the number literal s to a float64 or a Number</span><br><span class="hljs-comment">// depending on the setting of d.useNumber.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *decodeState)</span></span> convertNumber(s <span class="hljs-type">string</span>) (any, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> d.useNumber &#123;<br><span class="hljs-keyword">return</span> Number(s), <span class="hljs-literal">nil</span><br>&#125;<br>f, err := strconv.ParseFloat(s, <span class="hljs-number">64</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, &amp;UnmarshalTypeError&#123;Value: <span class="hljs-string">&quot;number &quot;</span> + s, Type: reflect.TypeOf(<span class="hljs-number">0.0</span>), Offset: <span class="hljs-type">int64</span>(d.off)&#125;<br>&#125;<br><span class="hljs-keyword">return</span> f, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ParseUseNumber</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> test <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;<br><br>d := json.NewDecoder(bytes.NewReader([]<span class="hljs-type">byte</span>(str)))<br>d.UseNumber()<br><span class="hljs-keyword">if</span> err := d.Decode(&amp;test); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br><br>fmt.Println(test)<br>&#125;<br><br><span class="hljs-comment">// 输出</span><br><span class="hljs-comment">// map[id:10000649949036001]</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>JSON</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang Empty 切片 vs Nil 切片</title>
    <link href="/2024/04/10/Golang-Empty-Nil-Slice/"/>
    <url>/2024/04/10/Golang-Empty-Nil-Slice/</url>
    
    <content type="html"><![CDATA[<p>切片（Slice），是Golang开发中常用到的一种基础数据结构，和数组比较相似。在日常开发中，经常见到nil切片、空切片和零切片的概念。今天主要分享一下他们之间的区别。</p><span id="more"></span>  <h2 id="1-基本对比"><a href="#1-基本对比" class="headerlink" title="1. 基本对比"></a>1. 基本对比</h2><h3 id="1-1-结论"><a href="#1-1-结论" class="headerlink" title="1.1 结论"></a>1.1 结论</h3><p>empty slice vs nil slice     </p><ul><li>相同点   <ul><li>they both have zero length and capacity,   </li><li>they can be used with the same effect in for loops and append functions,</li><li>and they even look the same when printed.</li></ul></li><li>不同点   <ul><li>nil切片和nil比较的结果是true  </li><li>empty切片和nil比较的结果是false</li></ul></li></ul><h3 id="1-2-nil-切片"><a href="#1-2-nil-切片" class="headerlink" title="1.2 nil 切片"></a>1.2 nil 切片</h3><blockquote><p>nil slice: 长度和容量都为0，并且和nil比较的结果true的切片<br>一般可以通过直接定义变量或者new创建   </p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">var</span> slice1 []<span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> slice2 = *<span class="hljs-built_in">new</span>([]<span class="hljs-type">int</span>)<br>fmt.Println(slice1, <span class="hljs-built_in">len</span>(slice1), <span class="hljs-built_in">cap</span>(slice1), slice1 == <span class="hljs-literal">nil</span>)<br>fmt.Println(slice2, <span class="hljs-built_in">len</span>(slice2), <span class="hljs-built_in">cap</span>(slice2), slice2 == <span class="hljs-literal">nil</span>)  <br><span class="hljs-comment">// [] 0 0 true</span><br><span class="hljs-comment">// [] 0 0 true</span><br></code></pre></td></tr></table></figure><p>可以简单理解为nil切片是只声明但是未初始化的切片。   </p><h3 id="1-3-empty-切片"><a href="#1-3-empty-切片" class="headerlink" title="1.3 empty 切片"></a>1.3 empty 切片</h3><blockquote><p>empty slice: 长度和容量都为0，但是和nil比较的结果为false的切片<br>一般可以通过声明一个长度为0的切片创建  </p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">var</span> slice3 = []<span class="hljs-type">int</span>&#123;&#125;<br><span class="hljs-keyword">var</span> slice4 = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br>fmt.Println(slice3, <span class="hljs-built_in">len</span>(slice3), <span class="hljs-built_in">cap</span>(slice3), slice3 == <span class="hljs-literal">nil</span>)<br>fmt.Println(slice4, <span class="hljs-built_in">len</span>(slice4), <span class="hljs-built_in">cap</span>(slice4), slice4 == <span class="hljs-literal">nil</span>)  <br><span class="hljs-comment">// [] 0 0 false</span><br><span class="hljs-comment">// [] 0 0 false</span><br></code></pre></td></tr></table></figure><p>可以简单理解empty切片是声明后切初始化了长度为0的切片。</p><h3 id="1-4-零-切片"><a href="#1-4-零-切片" class="headerlink" title="1.4 零 切片"></a>1.4 零 切片</h3><blockquote><p>零切片： 叫法不常见，主要是值长度部位0，但是内部数组元素都是零值或者nil的切片<br>使用make创建的长度不为0的初始切片就是零切片  </p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs golang">slice5 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">5</span>)  <span class="hljs-comment">// 0 0 0 0 0</span><br>slice6 := <span class="hljs-built_in">make</span>([]*<span class="hljs-type">int</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// nil nil nil nil nil</span><br>fmt.Println(slice5, <span class="hljs-built_in">len</span>(slice5), <span class="hljs-built_in">cap</span>(slice5), slice5 == <span class="hljs-literal">nil</span>)<br>fmt.Println(slice6, <span class="hljs-built_in">len</span>(slice6), <span class="hljs-built_in">cap</span>(slice6), slice6 == <span class="hljs-literal">nil</span>)<br><span class="hljs-comment">// [0 0 0 0 0] 5 5 false</span><br><span class="hljs-comment">// [nil nil nil nil nil] 5 5 false</span><br></code></pre></td></tr></table></figure><h2 id="2-底层原理"><a href="#2-底层原理" class="headerlink" title="2. 底层原理"></a>2. 底层原理</h2><p>golang的slice底层结构体由3个字段构成：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> slice <span class="hljs-keyword">struct</span>&#123;<br>    ptr unsafe.Pointer <br>    <span class="hljs-built_in">len</span> <span class="hljs-type">int</span> <br>    <span class="hljs-built_in">cap</span> <span class="hljs-type">int</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>其中len和cap分别是切片的长度和容量，而ptr则是指向底层数组的指针。    </p><p>所谓nil切片，就是ptr指向的指针也为nil<br><img src="/img/Golang-Empty-Nil-Slice/1.jpg">     </p><p>可以通过一个小实验验证指针的数据：  </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">var</span> s1 []<span class="hljs-type">int</span>  <br>s2 := []<span class="hljs-type">int</span>&#123;&#125;  <br>s3 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br><br>fmt.Printf(<span class="hljs-string">&quot;s1 (addr: %p): %+8v\n&quot;</span>, &amp;s1, *(*reflect.SliceHeader)(unsafe.Pointer(&amp;s1)))<br>fmt.Printf(<span class="hljs-string">&quot;s2 (addr: %p): %+8v\n&quot;</span>, &amp;s2, *(*reflect.SliceHeader)(unsafe.Pointer(&amp;s2))) <br>fmt.Printf(<span class="hljs-string">&quot;s3 (addr: %p): %+8v\n&quot;</span>, &amp;s3, *(*reflect.SliceHeader)(unsafe.Pointer(&amp;s3))) <br><span class="hljs-comment">// s1 (addr: 0xc0000080d8): &#123;Data:       0 Len:       0 Cap:       0&#125;</span><br><span class="hljs-comment">// s2 (addr: 0xc0000080f0): &#123;Data:12760120 Len:       0 Cap:       0&#125;</span><br><span class="hljs-comment">// s3 (addr: 0xc000008108): &#123;Data:12760120 Len:       0 Cap:       0&#125;</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>Slice</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Golang泛型</title>
    <link href="/2024/03/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3golang%E6%B3%9B%E5%9E%8B/"/>
    <url>/2024/03/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3golang%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>泛型（Generics）是一种编程思想，它允许在编写代码时使用未知的类型。泛型可以增加代码的灵活性和可复用性，同时还能提高代码的安全性和可读性。Go从1.18开始支持泛型的实现并在后续的版本中逐渐完善。</p><span id="more"></span>  <h2 id="1-Golang泛型"><a href="#1-Golang泛型" class="headerlink" title="1. Golang泛型"></a>1. Golang泛型</h2><ul><li>举个栗子, 现在有一个a+b的函数  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>&#123;<br>    <span class="hljs-keyword">return</span> a + b<br>&#125;<br></code></pre></td></tr></table></figure>函数比较简单，一看就是两个int类型的数据相加。现在思考一个问题，在golang泛型出现之前，如果想实现两个float相加该如何处理？一般存在两种方式：</li><li>再写一个函数   <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(a <span class="hljs-type">float64</span>, b <span class="hljs-type">float64</span>)</span></span> <span class="hljs-type">float64</span>&#123;<br>    <span class="hljs-keyword">return</span> a + b<br>&#125; <br></code></pre></td></tr></table></figure></li><li>把函数改造成反射函数  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add</span><span class="hljs-params">(a <span class="hljs-keyword">interface</span>&#123;&#125;, b <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    <span class="hljs-keyword">switch</span> a.(<span class="hljs-keyword">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">int</span>:<br>        <span class="hljs-keyword">return</span> a.(<span class="hljs-type">int</span>) + b.(<span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">float32</span>:<br>        <span class="hljs-keyword">return</span> a.(<span class="hljs-type">float32</span>) + b.(<span class="hljs-type">float32</span>)<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><p>现在golang支持泛型以后，该怎么实现呢？   </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add</span>[<span class="hljs-title">T</span> <span class="hljs-title">int</span> | <span class="hljs-title">float32</span> | <span class="hljs-title">float64</span>]<span class="hljs-params">(a, b T)</span></span> T &#123;<br><span class="hljs-keyword">return</span> a + b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(Add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br>fmt.Println(Add(<span class="hljs-number">1.1</span>, <span class="hljs-number">2.1</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>以上就是golang中最新支持的泛型函数。除了泛型函数外，还支持泛型类型和泛型接口。  </p><ul><li>泛型函数  </li><li>泛型类型  </li><li>泛型接口</li></ul><h2 id="2-泛型基本特性"><a href="#2-泛型基本特性" class="headerlink" title="2. 泛型基本特性"></a>2. 泛型基本特性</h2><p>泛型作为和常规类型不同的区别就在于它可以支持多种类型的参数，所以在定义和使用时也有着两个基本的特性：类型参数和类型约束。<br><img src="/img/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3golang%E6%B3%9B%E5%9E%8B/1.jpg">   </p><h3 id="2-1-类型参数"><a href="#2-1-类型参数" class="headerlink" title="2.1 类型参数"></a>2.1 类型参数</h3><ul><li>类型参数是泛型函数或类型的一个占位符，表示一个未知的类型。  </li><li>类型参数列表出现在常规参数之前。为了区分类型参数列表和常规参数列表，类型参数列表使用方括号[]而不是圆括号()</li></ul><h3 id="2-2-类型约束"><a href="#2-2-类型约束" class="headerlink" title="2.2 类型约束"></a>2.2 类型约束</h3><p>在使用泛型时，有时需要对泛型类型进行一定的约束。例如，我们希望某个泛型函数或类型只能接受特定类型的参数，或者特定类型的参数必须实现某个接口。在 Go 中，可以使用泛型约束来实现这些需求。   </p><p>如上图所示，T就是该泛型函数的参数，any就是参数的类型，达标任意类型即可。   </p><p>对于泛型类型的约束方法，常见的方式有如下几种：  </p><h4 id="2-2-1-常规类型约束"><a href="#2-2-1-常规类型约束" class="headerlink" title="2.2.1 常规类型约束"></a>2.2.1 常规类型约束</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add</span>[<span class="hljs-title">T</span> <span class="hljs-title">int</span> | <span class="hljs-title">float32</span> | <span class="hljs-title">float64</span>]<span class="hljs-params">(a, b T)</span></span> T &#123;<br><span class="hljs-keyword">return</span> a + b<br>&#125;<br></code></pre></td></tr></table></figure><p>当前这种类型约束方式简单明了，代表函数可以支持int，float32和float64三种参数的类型。 </p><h4 id="2-2-2-类型集约束"><a href="#2-2-2-类型集约束" class="headerlink" title="2.2.2 类型集约束"></a>2.2.2 类型集约束</h4><p>类型集表示一堆类型的集合，用来在泛型函数的声明中约束类型参数的范围. 如果需要支持的类型比较多，可以写在类型集中。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// 一堆类型的集合，用来在范型函数的声明中约束类型参数的范围</span><br><span class="hljs-keyword">type</span> numbers <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-type">int</span> | <span class="hljs-type">int32</span> | <span class="hljs-type">uint32</span> | <span class="hljs-type">int64</span> | <span class="hljs-type">uint64</span> | <span class="hljs-type">float32</span> | <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-comment">// 约束T可以为number中的任一个元素</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sub</span>[<span class="hljs-title">T</span> <span class="hljs-title">numbers</span>]<span class="hljs-params">(a, b T)</span></span> T &#123;<br><span class="hljs-keyword">return</span> a - b<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-3-联合约束元素"><a href="#2-2-3-联合约束元素" class="headerlink" title="2.2.3 联合约束元素"></a>2.2.3 联合约束元素</h4><p>联合元素，写成一系列由竖线 ( |) 分隔的约束元素。例如：int | float32或~int8 | ~int16 | ~int32 | ~int64  </p><ul><li>~int 代表所有int的衍生类型，比如自定义的别名；type myInt int; myInt就是 ~int类型。</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> Integer <span class="hljs-keyword">interface</span> &#123;<br>~<span class="hljs-type">int</span> | ~<span class="hljs-type">int8</span> | ~<span class="hljs-type">int16</span> | ~<span class="hljs-type">int32</span> | ~<span class="hljs-type">int64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AddInteger</span>[<span class="hljs-title">T</span> <span class="hljs-title">Integer</span>]<span class="hljs-params">(a, b T)</span></span> T &#123;<br><span class="hljs-keyword">return</span> a + b<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-4-推荐写法"><a href="#2-2-4-推荐写法" class="headerlink" title="2.2.4 推荐写法"></a>2.2.4 推荐写法</h4><p>在使用类型推荐时，尽量将类型限制在最简单的基本类型中，比如同样是类型T的数组。 </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// 推荐</span><br><span class="hljs-keyword">type</span> Student1[T <span class="hljs-type">int</span> | <span class="hljs-type">string</span>] <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>Data []T<br>&#125;<br><br><span class="hljs-keyword">type</span> Student2[T []<span class="hljs-type">int</span> | []<span class="hljs-type">string</span>] <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>Data T<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-泛型实践"><a href="#3-泛型实践" class="headerlink" title="3. 泛型实践"></a>3. 泛型实践</h2><p>Golang 泛型可以应用于各种数据结构和算法，例如排序、搜索、映射等；也可使用泛型类型实现一些通用的数据结构。</p><h3 id="3-1-工具函数"><a href="#3-1-工具函数" class="headerlink" title="3.1 工具函数"></a>3.1 工具函数</h3><ul><li>排序<br>在 Golang 中，使用 sort 包可以对任意类型的切片进行排序。  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sort</span>[<span class="hljs-title">T</span> <span class="hljs-title">int</span> | <span class="hljs-title">int32</span> | <span class="hljs-title">float32</span>]<span class="hljs-params">(s []T)</span></span> &#123;<br>sort.Slice(s, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> s[i] &lt; s[j]<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li><li>搜索<br>在 Golang 中，使用 search 包可以对任意类型的切片进行搜索.   <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Search</span>[<span class="hljs-title">T</span> <span class="hljs-title">int</span> | <span class="hljs-title">int32</span> | <span class="hljs-title">int64</span>]<span class="hljs-params">(s []T, x T)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> sort.Search(<span class="hljs-built_in">len</span>(s), <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> s[i] &gt;= x<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li><li>映射<br>在 Golang 中，使用 map 类型可以实现映射。为了支持泛型映射，我们可以定义一个泛型函数 Map[K comparable, V any]，如下所示：  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Map</span>[<span class="hljs-title">K</span> <span class="hljs-title">comparable</span>, <span class="hljs-title">V</span> <span class="hljs-title">any</span>]<span class="hljs-params">(s []K, f <span class="hljs-keyword">func</span>(K)</span></span> V) <span class="hljs-keyword">map</span>[K]V &#123;<br>result := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[K]V)<br><span class="hljs-keyword">for</span> _, k := <span class="hljs-keyword">range</span> s &#123;<br>result[k] = f(k)<br>&#125;<br><span class="hljs-keyword">return</span> result<br>&#125;  <br><br>words := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>, <span class="hljs-string">&quot;durian&quot;</span>, <span class="hljs-string">&quot;elderberry&quot;</span>, <span class="hljs-string">&quot;fig&quot;</span>&#125;<br>uppercased := generics.Map(words, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(word <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> strings.ToUpper(word)<br>&#125;)<br>fmt.Println(uppercased)<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-2-数据结构"><a href="#3-2-数据结构" class="headerlink" title="3.2 数据结构"></a>3.2 数据结构</h3><p>简单的实现一个基于泛型的队列。  </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// Queue - 队列</span><br><span class="hljs-keyword">type</span> Queue[T any] <span class="hljs-keyword">struct</span> &#123;<br>items []T<br>&#125;<br><br><span class="hljs-comment">// Put 将数据放入队列尾部</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue[T])</span></span> Put(value T) &#123;<br>q.items = <span class="hljs-built_in">append</span>(q.items, value)<br>&#125;<br><br><span class="hljs-comment">// Pop 从队列头部取出并从头部删除对应数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue[T])</span></span> Pop() (T, <span class="hljs-type">bool</span>) &#123;<br><span class="hljs-keyword">var</span> value T<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(q.items) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> value, <span class="hljs-literal">true</span><br>&#125;<br><br>value = q.items[<span class="hljs-number">0</span>]<br>q.items = q.items[<span class="hljs-number">1</span>:]<br><span class="hljs-keyword">return</span> value, <span class="hljs-built_in">len</span>(q.items) == <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-comment">// Size 队列大小</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q Queue[T])</span></span> Size() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(q.items)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-接口"><a href="#4-接口" class="headerlink" title="4. 接口"></a>4. 接口</h2><ul><li>在泛型出来之前，接口的定义是：接口是一个方法集   <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> <span class="hljs-type">error</span> <span class="hljs-keyword">interface</span>&#123;<br>Error() <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>在泛型出来之后，接口的定义是：接口是一个类型集  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> number <span class="hljs-keyword">interface</span>&#123;<br><span class="hljs-type">int</span> | <span class="hljs-type">float32</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-1-并集、交集、空集"><a href="#4-1-并集、交集、空集" class="headerlink" title="4.1 并集、交集、空集"></a>4.1 并集、交集、空集</h3><ul><li>并集：使用|连接的就是并集      <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// number 是下列基础类型的并集</span><br><span class="hljs-keyword">type</span> number <span class="hljs-keyword">interface</span>&#123;<br><span class="hljs-type">int</span> | <span class="hljs-type">int32</span> | <span class="hljs-type">uint32</span> | <span class="hljs-type">int64</span> | <span class="hljs-type">uint64</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>交集：如果一个接口的定义包含多行类型，就取他们的交集。  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> Int <span class="hljs-keyword">interface</span> &#123;<br>    <span class="hljs-type">int</span> | <span class="hljs-type">int8</span> | <span class="hljs-type">int16</span> | <span class="hljs-type">int32</span> | <span class="hljs-type">int64</span> | <span class="hljs-type">uint</span> | <span class="hljs-type">uint8</span> | <span class="hljs-type">uint16</span> | <span class="hljs-type">uint32</span> | <span class="hljs-type">uint64</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Uint <span class="hljs-keyword">interface</span> &#123;<br>    <span class="hljs-type">uint</span> | <span class="hljs-type">uint8</span> | <span class="hljs-type">uint16</span> | <span class="hljs-type">uint32</span> | <span class="hljs-type">uint64</span><br>&#125;<br><br><span class="hljs-comment">// 接口Status代表 Int和Uint的交集</span><br><span class="hljs-keyword">type</span> Status <span class="hljs-keyword">interface</span> &#123;  <br>    Int<br>    Uint<br>&#125;<br></code></pre></td></tr></table></figure></li><li>空集：如果多行类型没有交集，就是空集.    <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// 类型 ~int 和 ~float 没有相交的类型，所以接口 Bad 代表的类型集为空</span><br><span class="hljs-keyword">type</span> Bad <span class="hljs-keyword">interface</span> &#123;<br>    ~<span class="hljs-type">int</span><br>    ~float <br>&#125; <br></code></pre></td></tr></table></figure></li></ul><h3 id="4-2-接口类型"><a href="#4-2-接口类型" class="headerlink" title="4.2 接口类型"></a>4.2 接口类型</h3><ul><li>基本接口: 接口的定义中只有方法    <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// 接口中只有方法，所以是基本接口</span><br><span class="hljs-keyword">type</span> MyError <span class="hljs-keyword">interface</span> &#123; <br>    Error() <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>一般接口: 接口的定义中不仅有方法，还有类型    <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// 接口 Uint 中有类型，所以是一般接口</span><br><span class="hljs-keyword">type</span> Uint <span class="hljs-keyword">interface</span> &#123; <br>    ~<span class="hljs-type">uint</span> | ~<span class="hljs-type">uint8</span> | ~<span class="hljs-type">uint16</span> | ~<span class="hljs-type">uint32</span> | ~<span class="hljs-type">uint64</span><br>&#125;<br><br><span class="hljs-comment">// ReadWriter 接口既有方法也有类型，所以是一般接口</span><br><span class="hljs-keyword">type</span> ReadWriter <span class="hljs-keyword">interface</span> &#123;  <br>    ~<span class="hljs-type">string</span> | ~[]<span class="hljs-type">rune</span><br><br>    Read(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br>    Write(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br>&#125;<br><br><span class="hljs-comment">// 一般接口类型不能用来定义变量，只能用于泛型的类型约束中  </span><br><br><span class="hljs-comment">// 错误。Uint是一般接口，只能用于类型约束，不得用于变量定义</span><br><span class="hljs-keyword">var</span> uintInf Uint   <br></code></pre></td></tr></table></figure></li><li>如何实现一般接口？ <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// 先定义一个具体的类型，然后再实现具体的方法 </span><br><br><span class="hljs-comment">// StringReadWriter 实现了接口 ReadWriter</span><br><span class="hljs-keyword">type</span> StringReadWriter <span class="hljs-type">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s StringReadWriter)</span></span> Read(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s StringReadWriter)</span></span> Write(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5. 参考资料"></a>5. 参考资料</h2><ul><li><a href="https://www.kunkkawu.com/archives/shen-ru-li-jie-golang-de-fan-xing">https://www.kunkkawu.com/archives/shen-ru-li-jie-golang-de-fan-xing</a>  </li><li><a href="https://juejin.cn/post/7229462763947917367">https://juejin.cn/post/7229462763947917367</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>泛型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB复合索引的ESR原则</title>
    <link href="/2024/02/21/MongoDB%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84ESR%E5%8E%9F%E5%88%99/"/>
    <url>/2024/02/21/MongoDB%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84ESR%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<p>提到索引，大家都不会陌生，它的重要性在数据库中不言而喻。常见的存储如MysQL，MongoDB都支持多种类型的索引。本文主要以实际工作中碰到的例子聊一下MongoDB中的复合索引。</p><span id="more"></span>  <p>所谓复合索引，就是包含多个字段的索引，比如index(a,b)。复合索引在使用的过程中主要有两个原则： </p><ul><li>最左匹配原则 </li><li>ESR原则</li></ul><h3 id="1-最左匹配原则"><a href="#1-最左匹配原则" class="headerlink" title="1. 最左匹配原则"></a>1. 最左匹配原则</h3><p>最左匹配原则比较好理解，他和MySQL中的最左匹配原则一致，即最左优先：在检索数据时从复合索引的最左边开始匹配。</p><p>复合索引创建时一个基本的原则就是：将选择性最强的列放到最前面。</p><p>选择性最高指的是数据的重复值最少，因为区分度高的列能够很容易过滤掉很多的数据。如果组合索引中第一次能够过滤掉很多的数据，后面的索引查询的数据范围就小了很多了。</p><h3 id="2-ESR原则"><a href="#2-ESR原则" class="headerlink" title="2. ESR原则"></a>2. ESR原则</h3><p><a href="https://www.mongodb.com/docs/manual/tutorial/equality-sort-range-rule/">The ESR (Equality, Sort, Range) Rules</a> </p><p>简单来说就是我们在构建复合索引时，需要根据以下三项原则的顺序进行构建：  </p><ul><li>等值查询字段放在最前面</li><li>中间放排序字段</li><li>最后是范围查询字段</li></ul><p>E 放在前面比较好理解，等值匹配过滤掉大量数据，「那为什么是 ESR 不是 ERS 呢?」<br><img src="/img/MongoDB%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84ESR%E5%8E%9F%E5%88%99/1.png"><br>如图所示，如果把范围匹配放在中间，那么后续我们排序的时候只能进行「内存排序」，内存排序是比较消耗资源的，数据量大时可能会面临着「多次的磁盘读取刷内存操作」，对性能影响比较显著。</p><h3 id="3-实际案例分析"><a href="#3-实际案例分析" class="headerlink" title="3. 实际案例分析"></a>3. 实际案例分析</h3><p>以上两个原则看起来比较简单，但笔者在实际应用中还是踩了一些坑。</p><p>我有一个这样的mongo集合： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Demo <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// QueueID 队列id</span><br>QueueID <span class="hljs-type">string</span> <span class="hljs-string">`bson:&quot;queue_id,omitempty&quot;`</span><br><br><span class="hljs-comment">// Status 任务状态</span><br>Status <span class="hljs-type">int</span> <span class="hljs-string">`bson:&quot;status,omitempty&quot;`</span><br><br><span class="hljs-comment">// UpdateTime 更新时间</span><br>UpdateTime time.Time <span class="hljs-string">`bson:&quot;update_time,omitempty&quot;`</span><br><br><span class="hljs-comment">// 其他字段</span><br>xxxxx<br><br>&#125; <br></code></pre></td></tr></table></figure><p>mongo在查询时需要执行类似如下条件的查询：</p><pre><code class="go">db.collections.find(&#123; queue_id: 123, status: &#123; $in: [1, 2, 3] &#125; &#125;).sort(&#123; updateTime: 1 &#125;).limit(1)</code></pre><p>即：查询指定queue_id, 指定status范围，并按照updateTime进行升序的一条记录。   </p><p>在初步了解ESR原则后，我一想，这不就是queue_id为等值查询、updateTime为排序查询、status为范围查询的经典情况吗，大手一挥就创建了一个（queue_id, updateTime, status）的复合索引并愉快的上线了。</p><p>然而待数据量增大后，发现一个比较严重的问题，Mongo实例的CPU飙到了60%，排查原因发现索引执行不太正常。</p><p>参考官方资料后，发现in在执行的时候，可能是等值查询也可能是范围查询<br><img src="/img/MongoDB%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84ESR%E5%8E%9F%E5%88%99/2.png">    </p><ul><li>如果in单独使用，就是等值查询</li><li>如果in和sort一起使用，就是范围查询（针对同一个字段）</li></ul><p>所以在本例中，status的使用是等值查询，应该放在updateTime的前面，将索引修改为（queue_id, status, updateTime）后，CPU使用率即刻下降到30%左右。</p>]]></content>
    
    
    <categories>
      
      <category>MongoDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MongoDB</tag>
      
      <tag>索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka高性能分析</title>
    <link href="/2024/02/17/kafka%E9%AB%98%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    <url>/2024/02/17/kafka%E9%AB%98%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Kafka</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kafka</tag>
      
      <tag>高可用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka高可用分析</title>
    <link href="/2024/02/17/kafka%E9%AB%98%E5%8F%AF%E7%94%A8%E5%88%86%E6%9E%90/"/>
    <url>/2024/02/17/kafka%E9%AB%98%E5%8F%AF%E7%94%A8%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Kafka</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kafka</tag>
      
      <tag>高可用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang限流器</title>
    <link href="/2024/01/07/Golang%E9%99%90%E6%B5%81/"/>
    <url>/2024/01/07/Golang%E9%99%90%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<p>在高并发业务场景下，保护系统时，常用的”三板斧”有：”熔断、降级和限流”。本文主要记录golang中常用的限流算法的实现方式。这里所说的限流并非是网关层面或者服务调度之间的限流，而是业务代码中的逻辑限流。</p><span id="more"></span>   <p>限流算法常用的几种实现方式有如下四种：</p><ul><li>计数器</li><li>滑动窗口</li><li>漏桶</li><li>令牌桶</li></ul><h2 id="1-计数器"><a href="#1-计数器" class="headerlink" title="1. 计数器"></a>1. 计数器</h2><h3 id="1-1-原理"><a href="#1-1-原理" class="headerlink" title="1.1 原理"></a>1.1 原理</h3><p>计数器是一种最简单限流算法，其原理就是：<strong>在一段时间间隔内，对请求进行计数，与阀值进行比较判断是否需要限流，一旦到了时间临界点，将计数器清零。</strong></p><ul><li>可以在程序中设置一个变量 count，当过来一个请求我就将这个数 +1，同时记录请求时间。</li><li>当下一个请求来的时候判断 count 的计数值是否超过设定的频次，以及当前请求的时间和第一次请求时间是否在 1 分钟内。</li><li>如果在 1 分钟内并且超过设定的频次则证明请求过多，后面的请求就拒绝掉。</li><li>如果该请求与第一个请求的间隔时间大于计数周期，且 count 值还在限流范围内，就重置 count。</li></ul><p><img src="/img/Golang%E9%99%90%E6%B5%81/1.png"> </p><h3 id="1-2-缺点"><a href="#1-2-缺点" class="headerlink" title="1.2 缺点"></a>1.2 缺点</h3><p>计数器算法存在“时间临界点”缺陷。比如每一分钟限制200个请求，可以在00:00:00-00:00:58秒里面都没有请求，在00:00:59瞬间发送200个请求，这个对于计数器算法来是允许的，然后在00:01:00再次发送200个请求，意味着在短短1s内发送了400个请求，如果量更大呢，系统可能会承受不住瞬间流量，导致系统崩溃。<br><img src="/img/Golang%E9%99%90%E6%B5%81/2.png"></p><h2 id="2-滑动窗口"><a href="#2-滑动窗口" class="headerlink" title="2. 滑动窗口"></a>2. 滑动窗口</h2><h3 id="2-1-原理"><a href="#2-1-原理" class="headerlink" title="2.1 原理"></a>2.1 原理</h3><p>滑动窗口算法将一个大的时间窗口分成多个小窗口，每次大窗口向后滑动一个小窗口，并保证大的窗口内流量不会超出最大值，这种实现比固定窗口的流量曲线更加平滑。</p><p>普通时间窗口有一个问题，比如窗口期内请求的上限是200，假设有200个请求集中在前1s的后100ms，200个请求集中在后1s的前100ms，其实在这200ms内就已经请求超限了，但是由于时间窗每经过1s就会重置计数，就无法识别到这种请求超限。</p><p><img src="/img/Golang%E9%99%90%E6%B5%81/3.png"><br>对于滑动时间窗口，我们可以把1ms的时间窗口划分成一些小窗口，上图中我们用红色的虚线代表一个时间窗口（一分钟），每个时间窗口有 6 个格子，每个格子是 10 秒钟。每过 10 秒钟时间窗口向右移动一格，可以看红色箭头的方向。我们为每个格子都设置一个独立的计数器 Counter，假如一个请求在 0:45 访问了那么我们将第五个格子的计数器 +1（也是就是 0:40~0:50），在判断限流的时候需要把所有格子的计数加起来和设定的频次进行比较即可。   </p><p>当用户在0:59 秒钟发送了 200 个请求就会被第六个格子的计数器记录 +200，当下一秒的时候时间窗口向右移动了一个，此时计数器已经记录了该用户发送的 200 个请求，所以再发送的话就会触发限流，则拒绝新的请求。 </p><h3 id="2-2-缺点"><a href="#2-2-缺点" class="headerlink" title="2.2 缺点"></a>2.2 缺点</h3><p>滑动窗口算法是计数器算法的一种改进[计数器就是只有一个格子的滑动窗口]，但从根本上并没有真正解决固定窗口算法的临界突发流量问题。想让限流做的更精确只能划分更多的格子。</p><h2 id="3-漏桶算法"><a href="#3-漏桶算法" class="headerlink" title="3. 漏桶算法"></a>3. 漏桶算法</h2><h3 id="3-1-原理"><a href="#3-1-原理" class="headerlink" title="3.1 原理"></a>3.1 原理</h3><p>漏桶算法是首先想象有一个木桶，桶的容量是固定的。当有请求到来时先放到木桶中，处理请求的worker以固定的速度从木桶中取出请求进行相应。如果木桶已经满了，直接返回请求频率超限的错误码或者页面。   </p><p>漏桶算法是流量最均匀的限流实现方式，一般用于流量“整形”。例如保护数据库的限流，先把对数据库的访问加入到木桶中，worker再以db能够承受的qps从木桶中取出请求，去访问数据库。<br><img src="/img/Golang%E9%99%90%E6%B5%81/4.png">    </p><h3 id="3-2-缺点"><a href="#3-2-缺点" class="headerlink" title="3.2 缺点"></a>3.2 缺点</h3><p>木桶流入请求的速率是不固定的，但是流出的速率是恒定的。这样的话能保护系统资源不被打满，但是面对突发流量时会有大量请求失败，不适合电商抢购和微博出现热点事件等场景的限流。  </p><h2 id="4-令牌桶算法"><a href="#4-令牌桶算法" class="headerlink" title="4. 令牌桶算法"></a>4. 令牌桶算法</h2><h3 id="4-1-原理"><a href="#4-1-原理" class="headerlink" title="4.1 原理"></a>4.1 原理</h3><p>令牌桶是反向的”漏桶”，它是以恒定的速度往木桶里加入令牌，木桶满了则不再加入令牌。服务收到请求时尝试从木桶中取出一个令牌，如果能够得到令牌则继续执行后续的业务逻辑。如果没有得到令牌，直接返回访问频率超限的错误码或页面等，不继续执行后续的业务逻辑。</p><p>特点：由于木桶内只要有令牌，请求就可以被处理，所以令牌桶算法可以支持突发流量<br><img src="/img/Golang%E9%99%90%E6%B5%81/0.png">      </p><p>同时由于往木桶添加令牌的速度是恒定的，且木桶的容量有上限，所以单位时间内处理的请求书也能够得到控制，起到限流的目的。假设加入令牌的速度为 1 token&#x2F;10ms，桶的容量为500，在请求比较的少的时候（小于每10毫秒1个请求）时，木桶可以先”攒”一些令牌（最多500个）。当有突发流量时，一下把木桶内的令牌取空，也就是有500个在并发执行的业务逻辑，之后要等每10ms补充一个新的令牌才能接收一个新的请求。</p><h3 id="4-2-适用场景"><a href="#4-2-适用场景" class="headerlink" title="4.2 适用场景"></a>4.2 适用场景</h3><p>适合电商抢购或者微博出现热点事件这种场景，因为在限流的同时可以应对一定的突发流量。如果采用漏桶那样的均匀速度处理请求的算法，在发生热点时间的时候，会造成大量的用户无法访问，对用户体验的损害比较大。 </p><h3 id="4-3-实现"><a href="#4-3-实现" class="headerlink" title="4.3 实现"></a>4.3 实现</h3><p>golang官方实现了令牌桶限流方法<code>Limiter</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Limiter <span class="hljs-keyword">struct</span> &#123;<br>mu     sync.Mutex<br>limit  Limit<br>burst  <span class="hljs-type">int</span> <span class="hljs-comment">// 令牌桶的大小</span><br>tokens <span class="hljs-type">float64</span><br>last time.Time <span class="hljs-comment">// 上次更新tokens的时间</span><br>lastEvent time.Time <span class="hljs-comment">// 上次发生限速器事件的时间（通过或者限制都是限速器事件）</span><br>&#125; <br></code></pre></td></tr></table></figure><p>其主要字段的作用是：  </p><ul><li>limit：limit字段表示往桶里放Token的速率，它的类型是Limit，是int64的类型别名。设置limit时既可以用数字指定每秒向桶中放多少个Token，也可以指定向桶中放Token的时间间隔，其实指定了每秒放Token的个数后就能计算出放每个Token的时间间隔了。</li><li>burst: 令牌桶的大小。</li><li>tokens: 桶中的令牌。</li><li>last: 上次往桶中放 Token 的时间。</li><li>lastEvent：上次发生限速器事件的时间（通过或者限制都是限速器事件）</li></ul><h4 id="4-3-1-构造限流器"><a href="#4-3-1-构造限流器" class="headerlink" title="4.3.1 构造限流器"></a>4.3.1 构造限流器</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">limiter := rate.NewLimiter(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure><p>这里有两个参数：</p><ul><li>第一个参数是 r Limit，设置的是限流器Limiter的limit字段，代表每秒可以向 Token 桶中产生多少 token。Limit 实际上是 float64 的别名。</li><li>第二个参数是 b int，b 代表 Token 桶的容量大小，也就是设置的限流器 Limiter 的burst字段。</li></ul><p>那么，对于以上例子来说，其构造出的限流器的令牌桶大小为 100, 以每秒 10 个 Token 的速率向桶中放置 Token。</p><h4 id="4-3-2-使用限流器"><a href="#4-3-2-使用限流器" class="headerlink" title="4.3.2 使用限流器"></a>4.3.2 使用限流器</h4><p>Limiter 提供了三类方法供程序消费 Token，可以每次消费一个 Token，也可以一次性消费多个 Token。 每种方法代表了当 Token 不足时，各自不同的对应手段，可以阻塞等待桶中Token补充，也可以直接返回取Token失败。   </p><p>其中比较常见的是Wait&#x2F;WaitN方法 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lim *Limiter)</span></span> Wait(ctx context.Context) (err <span class="hljs-type">error</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lim *Limiter)</span></span> WaitN(ctx context.Context, n <span class="hljs-type">int</span>) (err <span class="hljs-type">error</span>)<br></code></pre></td></tr></table></figure><p>Wait 实际上就是 WaitN(ctx,1)。   </p><p>当使用 Wait 方法消费 Token 时，如果此时桶内 Token 数组不足 (小于 N)，那么 Wait 方法将会阻塞一段时间，直至 Token 满足条件。如果充足则直接返回。  </p><p>这里可以看到，Wait 方法有一个 context 参数。我们可以设置 context 的 Deadline 或者 Timeout，来决定此次 Wait 的最长时间。     </p><p>其他还有两种用法分别如下，具体使用方法可查阅官方文档信息</p><ul><li>Allow&#x2F;AllowN </li><li>Reserve&#x2F;ReserverN</li></ul>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>限流器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis分布式锁</title>
    <link href="/2023/12/23/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <url>/2023/12/23/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    
    <content type="html"><![CDATA[<p>分布式锁，就是控制分布式系统不同进程共同访问共享资源的一种锁的实现。如果不同的系统或同一个系统的不同主机之间共享了某个临界资源，往往需要互斥来防止彼此干扰，以保证一致性。 </p><span id="more"></span>   <h2 id="Redis分布式锁的实现方式"><a href="#Redis分布式锁的实现方式" class="headerlink" title="Redis分布式锁的实现方式"></a>Redis分布式锁的实现方式</h2><blockquote><p>在线redis环境：<a href="https://try.redis.io/">https://try.redis.io/</a>   </p></blockquote><h3 id="1-什么是分布式锁"><a href="#1-什么是分布式锁" class="headerlink" title="1. 什么是分布式锁"></a>1. 什么是分布式锁</h3><p>分布式锁就是，控制分布式系统不同进程共同访问共享资源的一种锁的实现。如果不同的系统或同一个系统的不同主机之间共享了某个临界资源，往往需要互斥来防止彼此干扰，以保证一致性。<br>分布式锁一般具有以下特征:  </p><ul><li>互斥性：任意时刻只有一个客户端可持有</li><li>超时释放：持有锁超时可以及时释放，防止死锁和不必要的资源浪费  </li><li>可重入性：一个线程获取锁之后，还可以再次对其请求加锁</li><li>高性能高可用：加锁和解锁需要开销尽量低，同时也要保证高可用 </li><li>安全性：锁只能被持有的客户端删除，不能被其他客户端删除</li></ul><!--  --><p><img src="/img/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/1.png"></p><h3 id="2-SETNX"><a href="#2-SETNX" class="headerlink" title="2. SETNX"></a>2. SETNX</h3><p>一提到使用Redis作为分布式锁，大家耳熟能详的就会想到<code>SETNX + EXPIRE</code>。即先用<code>setnx</code>来抢锁，然后再用<code>expire</code>设置一个过期时间。</p><blockquote><p>SETNX是 SET IF NOT EXISTS的简称，顾名思义就是不存在就设置<br>命令使用：SETNX key value<br>如果key不存在，设置成功返回1，如果key已经存在，设置失败返回0</p></blockquote><p>但是直接使用SETNX + EXPIRE 指令，会存在一些问题：</p><ul><li>原子性：setnx 和 exipre是两个命令，如果设置过期时间出错，就会导致长时间持有锁得不到释放。</li><li>误删除问题：假设线程a执行完后，主动去释放锁。但它不知道当前的锁可能是线程b持有的（线程a去释放锁时，有可能过期时间已经到了，此时线程b进来占有了锁）。那线程a就把线程b的锁释放掉了，但是线程b临界区业务代码可能都还没执行完成。</li></ul><h4 id="2-1-原子性"><a href="#2-1-原子性" class="headerlink" title="2.1 原子性"></a>2.1 原子性</h4><p>为解决原子性问题，常见的有两种方式:  </p><h5 id="2-1-1-使用Lua脚本"><a href="#2-1-1-使用Lua脚本" class="headerlink" title="2.1.1 使用Lua脚本"></a>2.1.1 使用Lua脚本</h5><p>lua脚本在执行过程中，是可以保证原子处理的，可以将setnx和expire两个命令都放到lua脚本中进行操作。  </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&#x27;setnx&#x27;</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">1</span>]) == <span class="hljs-number">1</span> <span class="hljs-keyword">then</span><br>   redis.call(<span class="hljs-string">&#x27;expire&#x27;</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">2</span>])<br><span class="hljs-keyword">else</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span>;<br></code></pre></td></tr></table></figure><h5 id="2-1-2-使用SET的扩展命令"><a href="#2-1-2-使用SET的扩展命令" class="headerlink" title="2.1.2 使用SET的扩展命令"></a>2.1.2 使用SET的扩展命令</h5><p>虽然<code>SETNX</code>和<code>EXPIRE</code>两个指令是独立的，但是单独的一个SET命令是却是原子的，可以使用SET的参数扩展功能实现NX和EXPIRE的能力<br><code>SET key value [EX seconds] [PX millseconds] NX</code>  </p><blockquote><p>SET key value [EX seconds] [PX milliseconds] NX<br>NX :表示key不存在的时候，才能set成功，也即保证只有第一个客户端请求才能获得锁，而其他客户端请求只能等其释放锁，才能获取。<br>EX seconds :设定key的过期时间，时间单位是秒。<br>PX milliseconds: 设定key的过期时间，单位为毫秒  </p></blockquote><p>在实际的开发过程中，我们一般使用第三方库，不会直接执行redis的cmd命令。可以在使用第三方的sdk时，查看sdk是否已经提供了一些原子的操作，避免自己写原生lua脚本或者命令。比如go-redis中，SETNX + EXPIRE已经可以在一个客户端操作中完成：  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Lock 使用 SETNX实现加锁</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Client)</span></span> Lock(key, value <span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>ret := c.client.SetNX(key, value, time.Minute)<br><span class="hljs-keyword">if</span> ret.Val() &#123;<br>fmt.Println(<span class="hljs-string">&quot;加锁成功&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;加锁失败&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// Redis `SET key value [expiration] NX` command.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Zero expiration means the key has no expiration time.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cmdable)</span></span> SetNX(key <span class="hljs-type">string</span>, value <span class="hljs-keyword">interface</span>&#123;&#125;, expiration time.Duration) *BoolCmd &#123;&#125;<br><br></code></pre></td></tr></table></figure><h4 id="2-2-误删除"><a href="#2-2-误删除" class="headerlink" title="2.2 误删除"></a>2.2 误删除</h4><p>既然锁可能会被别的线程删除，那给锁的value值设置一个标记当前的线程唯一值即可。在删除的时候首先校验值是否相等，只有相等的情况下才可以删除锁。<br>同样的，为保证一致性，值的比较和删除操作需要保证原子性。 </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&#x27;get&#x27;</span>,KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>] <span class="hljs-keyword">then</span> <br>   <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&#x27;del&#x27;</span>,KEYS[<span class="hljs-number">1</span>]) <br><span class="hljs-keyword">else</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span>;<br></code></pre></td></tr></table></figure><h3 id="3-Redisson"><a href="#3-Redisson" class="headerlink" title="3. Redisson"></a>3. Redisson</h3><p>参考文章：  </p><ul><li><a href="https://blog.csdn.net/qq_34826261/article/details/126177704">https://blog.csdn.net/qq_34826261&#x2F;article&#x2F;details&#x2F;126177704</a>  </li><li><a href="https://zhuanlan.zhihu.com/p/135864820">https://zhuanlan.zhihu.com/p/135864820</a>  </li><li><a href="https://juejin.cn/post/7168802584684134413">https://juejin.cn/post/7168802584684134413</a></li></ul><p>上面介绍的<code>SETNX + Exipred + 原子操作 + 唯一值校验删除</code>的方案在很大程度上已经能够满足使用，但是还有一个可能存在的情况没有解决： </p><ul><li>锁过期释放，但业务还没执行完成：假设线程a获取锁成功，一直在执行临界区的代码。100s过去后，它还没执行完。但这时候锁已经过期了，此时线程b又请求过来。显然线程b就可以获得锁成功，也开始执行临界区的代码。那么问题就来了，临界区的业务代码都不是严格串行执行。</li></ul><p>针对这种问题，Redisson框架做了一些额外的优化，在加锁的同时开启一个定时守护线程，每隔一段时间检查锁是否还存在，存在则对锁的过期时间延长，防止锁过期提前释放。  </p><p>Redisson主要原理及结构如下：  </p><ul><li>基于Redis命令的实现： Redisson利用了Redis的单线程特性和原子操作的特点。它通过调用Redis的SETNX命令来尝试获取锁，当锁不存在时，才能获取到锁。</li><li>心跳续约(看门狗)机制： 为防止业务逻辑还没执行完锁就到期的问题，Redisson在获取锁之后会启动一个定时任务来周期性地续约锁的有效时间。</li><li>实现可重入锁： Redisson支持可重入锁，保证同一线程在持有锁的情况下能够多次获取锁，而不会因为自己已经持有锁而被阻塞。  </li><li>分布式锁释放的安全性保证： Redisson通过Lua脚本来释放锁，保证了释放锁的原子性。使用Lua脚本可以保证释放锁的操作是原子的，避免了在执行释放锁逻辑时出现的并发问题。</li></ul><p><img src="/img/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/redisson.png">   </p><blockquote><p>部分核心逻辑如下： </p><ul><li>加锁 <ul><li>每次加锁都有一个加锁等待时间 </li><li>如果加锁成功，直接返回true</li><li>如果加锁失败，则订阅锁释放消息，在加锁等待时间内监听锁释放消息，如果一直没有监听到，则取消订阅并返回false </li><li>如果在等待时间内监听到锁释放消息，则进入一个不断重试获取锁的循环</li></ul></li><li>续期机制  <ul><li>只有在加锁时没有设置过期时间时才会启用Watch Dog机制  </li><li>Watch Dog启动守护线程，守护线程轮询周期为：internalLockLeaseTime&#x2F;3。internalLockLeaseTime的默认值由lockWatchdogTimeout来配置。默认值为30秒。也就是说默认情况下，守护线程每10秒检查续期</li></ul></li></ul></blockquote><h3 id="4-RedLock"><a href="#4-RedLock" class="headerlink" title="4. RedLock"></a>4. RedLock</h3><p>Redisson解决了锁超时续期自动释放的问题，但是还有一种极端的情况没有解决：  </p><ul><li>客户端A尝试在Redis Master节点上锁，客户端A成功获得锁的瞬间，锁数据还没有同步至Slave节点。这时Master挂了，于是发生主从切换，其它客户端连接到Slave节点尝试抢占锁，由于Slave没有客户端A的上锁信息。自然又会有一个新的客户端B抢到锁，此时就会出现两个客户端同时拥有分布式锁的奇葩现像。</li></ul><p>鉴于此，Redis作者提出一种更高级的RedLock算法，它需要部署 N （N &gt;&#x3D; 2n+1）个独立的 Redis master实例，且实例之间没有任何的联系。也就是说，只要一半以上的 Redis 实例加锁成功，那么 Redlock 依然可以正常运行。  </p><p><img src="/img/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/redlock.png">  </p><p>假设我们有 5 个 Redis 实例，当我们对 order1 这个订单加锁时，先记录当前时间用于统计加锁过程花费的时间，然后依次让 5 个 Redis 实例执行 SET order1 token NX EX 60 命令，最后统计<strong>加锁成功的实例数量以及加锁过程耗费的时间</strong>  </p><ul><li>统计个数: 当超过一半的加锁成功，认为是成功   </li><li>统计时间: 避免整体的加锁时长已经超过锁本身的有效时间，比如锁的过期时间是3s，但是加锁过程耗费了4s，肯定是认为加锁失败的。</li></ul><p>解锁过程相对简单，只需要5个实例依次删除redis key即可。   </p><p>Redlock在Redisson中也有对应的实现，不过在最新版的Redisson中，Redlock已经不再建议使用.因为现在加锁操作实现，可以等所有从节点数据同步了才算加锁成功。这样的话就可以保证主从切换锁不会丢失了。  </p><pre><code class="hljs">8.4. RedLockThis object is deprecated. Use RLock or RFencedLock instead.</code></pre><p>可以通过Redis的Wait命令实现主从同步  </p><blockquote><p>Redis WAIT 命令用来阻塞当前客户端，直到所有先前的写入命令成功传输并且至少由指定数量的从节点复制完成。如果执行超过超时时间（以毫秒为单位），则即使尚未完成指定数量的从结点复制，该命令也会返回。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>分布式锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
