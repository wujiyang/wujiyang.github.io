<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>深入理解Golang泛型</title>
    <link href="/2024/03/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3golang%E6%B3%9B%E5%9E%8B/"/>
    <url>/2024/03/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3golang%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>泛型（Generics）是一种编程思想，它允许在编写代码时使用未知的类型。泛型可以增加代码的灵活性和可复用性，同时还能提高代码的安全性和可读性。Go从1.18开始支持泛型的实现并在后续的版本中逐渐完善。</p><span id="more"></span>  <h2 id="1-Golang泛型"><a href="#1-Golang泛型" class="headerlink" title="1. Golang泛型"></a>1. Golang泛型</h2><ul><li>举个栗子, 现在有一个a+b的函数  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>&#123;<br>    <span class="hljs-keyword">return</span> a + b<br>&#125;<br></code></pre></td></tr></table></figure>函数比较简单，一看就是两个int类型的数据相加。现在思考一个问题，在golang泛型出现之前，如果想实现两个float相加该如何处理？一般存在两种方式：</li><li>再写一个函数   <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(a <span class="hljs-type">float64</span>, b <span class="hljs-type">float64</span>)</span></span> <span class="hljs-type">float64</span>&#123;<br>    <span class="hljs-keyword">return</span> a + b<br>&#125; <br></code></pre></td></tr></table></figure></li><li>把函数改造成反射函数  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add</span><span class="hljs-params">(a <span class="hljs-keyword">interface</span>&#123;&#125;, b <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    <span class="hljs-keyword">switch</span> a.(<span class="hljs-keyword">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">int</span>:<br>        <span class="hljs-keyword">return</span> a.(<span class="hljs-type">int</span>) + b.(<span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">float32</span>:<br>        <span class="hljs-keyword">return</span> a.(<span class="hljs-type">float32</span>) + b.(<span class="hljs-type">float32</span>)<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><p>现在golang支持泛型以后，该怎么实现呢？   </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add</span>[<span class="hljs-title">T</span> <span class="hljs-title">int</span> | <span class="hljs-title">float32</span> | <span class="hljs-title">float64</span>]<span class="hljs-params">(a, b T)</span></span> T &#123;<br><span class="hljs-keyword">return</span> a + b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(Add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br>fmt.Println(Add(<span class="hljs-number">1.1</span>, <span class="hljs-number">2.1</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>以上就是golang中最新支持的泛型函数。除了泛型函数外，还支持泛型类型和泛型接口。  </p><ul><li>泛型函数  </li><li>泛型类型  </li><li>泛型接口</li></ul><h2 id="2-泛型基本特性"><a href="#2-泛型基本特性" class="headerlink" title="2. 泛型基本特性"></a>2. 泛型基本特性</h2><p>泛型作为和常规类型不同的区别就在于它可以支持多种类型的参数，所以在定义和使用时也有着两个基本的特性：类型参数和类型约束。<br><img src="/img/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3golang%E6%B3%9B%E5%9E%8B/1.jpg">   </p><h3 id="2-1-类型参数"><a href="#2-1-类型参数" class="headerlink" title="2.1 类型参数"></a>2.1 类型参数</h3><ul><li>类型参数是泛型函数或类型的一个占位符，表示一个未知的类型。  </li><li>类型参数列表出现在常规参数之前。为了区分类型参数列表和常规参数列表，类型参数列表使用方括号[]而不是圆括号()</li></ul><h3 id="2-2-类型约束"><a href="#2-2-类型约束" class="headerlink" title="2.2 类型约束"></a>2.2 类型约束</h3><p>在使用泛型时，有时需要对泛型类型进行一定的约束。例如，我们希望某个泛型函数或类型只能接受特定类型的参数，或者特定类型的参数必须实现某个接口。在 Go 中，可以使用泛型约束来实现这些需求。   </p><p>如上图所示，T就是该泛型函数的参数，any就是参数的类型，达标任意类型即可。   </p><p>对于泛型类型的约束方法，常见的方式有如下几种：  </p><h4 id="2-2-1-常规类型约束"><a href="#2-2-1-常规类型约束" class="headerlink" title="2.2.1 常规类型约束"></a>2.2.1 常规类型约束</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add</span>[<span class="hljs-title">T</span> <span class="hljs-title">int</span> | <span class="hljs-title">float32</span> | <span class="hljs-title">float64</span>]<span class="hljs-params">(a, b T)</span></span> T &#123;<br><span class="hljs-keyword">return</span> a + b<br>&#125;<br></code></pre></td></tr></table></figure><p>当前这种类型约束方式简单明了，代表函数可以支持int，float32和float64三种参数的类型。 </p><h4 id="2-2-2-类型集约束"><a href="#2-2-2-类型集约束" class="headerlink" title="2.2.2 类型集约束"></a>2.2.2 类型集约束</h4><p>类型集表示一堆类型的集合，用来在泛型函数的声明中约束类型参数的范围. 如果需要支持的类型比较多，可以写在类型集中。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// 一堆类型的集合，用来在范型函数的声明中约束类型参数的范围</span><br><span class="hljs-keyword">type</span> numbers <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-type">int</span> | <span class="hljs-type">int32</span> | <span class="hljs-type">uint32</span> | <span class="hljs-type">int64</span> | <span class="hljs-type">uint64</span> | <span class="hljs-type">float32</span> | <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-comment">// 约束T可以为number中的任一个元素</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sub</span>[<span class="hljs-title">T</span> <span class="hljs-title">numbers</span>]<span class="hljs-params">(a, b T)</span></span> T &#123;<br><span class="hljs-keyword">return</span> a - b<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-3-联合约束元素"><a href="#2-2-3-联合约束元素" class="headerlink" title="2.2.3 联合约束元素"></a>2.2.3 联合约束元素</h4><p>联合元素，写成一系列由竖线 ( |) 分隔的约束元素。例如：int | float32或~int8 | ~int16 | ~int32 | ~int64  </p><ul><li>~int 代表所有int的衍生类型，比如自定义的别名；type myInt int; myInt就是 ~int类型。</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> Integer <span class="hljs-keyword">interface</span> &#123;<br>~<span class="hljs-type">int</span> | ~<span class="hljs-type">int8</span> | ~<span class="hljs-type">int16</span> | ~<span class="hljs-type">int32</span> | ~<span class="hljs-type">int64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AddInteger</span>[<span class="hljs-title">T</span> <span class="hljs-title">Integer</span>]<span class="hljs-params">(a, b T)</span></span> T &#123;<br><span class="hljs-keyword">return</span> a + b<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-4-推荐写法"><a href="#2-2-4-推荐写法" class="headerlink" title="2.2.4 推荐写法"></a>2.2.4 推荐写法</h4><p>在使用类型推荐时，尽量将类型限制在最简单的基本类型中，比如同样是类型T的数组。 </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// 推荐</span><br><span class="hljs-keyword">type</span> Student1[T <span class="hljs-type">int</span> | <span class="hljs-type">string</span>] <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>Data []T<br>&#125;<br><br><span class="hljs-keyword">type</span> Student2[T []<span class="hljs-type">int</span> | []<span class="hljs-type">string</span>] <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>Data T<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-泛型实践"><a href="#3-泛型实践" class="headerlink" title="3. 泛型实践"></a>3. 泛型实践</h2><p>Golang 泛型可以应用于各种数据结构和算法，例如排序、搜索、映射等；也可使用泛型类型实现一些通用的数据结构。</p><h3 id="3-1-工具函数"><a href="#3-1-工具函数" class="headerlink" title="3.1 工具函数"></a>3.1 工具函数</h3><ul><li>排序<br>在 Golang 中，使用 sort 包可以对任意类型的切片进行排序。  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sort</span>[<span class="hljs-title">T</span> <span class="hljs-title">int</span> | <span class="hljs-title">int32</span> | <span class="hljs-title">float32</span>]<span class="hljs-params">(s []T)</span></span> &#123;<br>sort.Slice(s, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> s[i] &lt; s[j]<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li><li>搜索<br>在 Golang 中，使用 search 包可以对任意类型的切片进行搜索.   <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Search</span>[<span class="hljs-title">T</span> <span class="hljs-title">int</span> | <span class="hljs-title">int32</span> | <span class="hljs-title">int64</span>]<span class="hljs-params">(s []T, x T)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> sort.Search(<span class="hljs-built_in">len</span>(s), <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> s[i] &gt;= x<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li><li>映射<br>在 Golang 中，使用 map 类型可以实现映射。为了支持泛型映射，我们可以定义一个泛型函数 Map[K comparable, V any]，如下所示：  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Map</span>[<span class="hljs-title">K</span> <span class="hljs-title">comparable</span>, <span class="hljs-title">V</span> <span class="hljs-title">any</span>]<span class="hljs-params">(s []K, f <span class="hljs-keyword">func</span>(K)</span></span> V) <span class="hljs-keyword">map</span>[K]V &#123;<br>result := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[K]V)<br><span class="hljs-keyword">for</span> _, k := <span class="hljs-keyword">range</span> s &#123;<br>result[k] = f(k)<br>&#125;<br><span class="hljs-keyword">return</span> result<br>&#125;  <br><br>words := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>, <span class="hljs-string">&quot;durian&quot;</span>, <span class="hljs-string">&quot;elderberry&quot;</span>, <span class="hljs-string">&quot;fig&quot;</span>&#125;<br>uppercased := generics.Map(words, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(word <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> strings.ToUpper(word)<br>&#125;)<br>fmt.Println(uppercased)<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-2-数据结构"><a href="#3-2-数据结构" class="headerlink" title="3.2 数据结构"></a>3.2 数据结构</h3><p>简单的实现一个基于泛型的队列。  </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// Queue - 队列</span><br><span class="hljs-keyword">type</span> Queue[T any] <span class="hljs-keyword">struct</span> &#123;<br>items []T<br>&#125;<br><br><span class="hljs-comment">// Put 将数据放入队列尾部</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue[T])</span></span> Put(value T) &#123;<br>q.items = <span class="hljs-built_in">append</span>(q.items, value)<br>&#125;<br><br><span class="hljs-comment">// Pop 从队列头部取出并从头部删除对应数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue[T])</span></span> Pop() (T, <span class="hljs-type">bool</span>) &#123;<br><span class="hljs-keyword">var</span> value T<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(q.items) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> value, <span class="hljs-literal">true</span><br>&#125;<br><br>value = q.items[<span class="hljs-number">0</span>]<br>q.items = q.items[<span class="hljs-number">1</span>:]<br><span class="hljs-keyword">return</span> value, <span class="hljs-built_in">len</span>(q.items) == <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-comment">// Size 队列大小</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q Queue[T])</span></span> Size() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(q.items)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-接口"><a href="#4-接口" class="headerlink" title="4. 接口"></a>4. 接口</h2><ul><li>在泛型出来之前，接口的定义是：接口是一个方法集   <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> <span class="hljs-type">error</span> <span class="hljs-keyword">interface</span>&#123;<br>Error() <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>在泛型出来之后，接口的定义是：接口是一个类型集  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> number <span class="hljs-keyword">interface</span>&#123;<br><span class="hljs-type">int</span> | <span class="hljs-type">float32</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-1-并集、交集、空集"><a href="#4-1-并集、交集、空集" class="headerlink" title="4.1 并集、交集、空集"></a>4.1 并集、交集、空集</h3><ul><li>并集：使用|连接的就是并集      <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// number 是下列基础类型的并集</span><br><span class="hljs-keyword">type</span> number <span class="hljs-keyword">interface</span>&#123;<br><span class="hljs-type">int</span> | <span class="hljs-type">int32</span> | <span class="hljs-type">uint32</span> | <span class="hljs-type">int64</span> | <span class="hljs-type">uint64</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>交集：如果一个接口的定义包含多行类型，就取他们的交集。  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> Int <span class="hljs-keyword">interface</span> &#123;<br>    <span class="hljs-type">int</span> | <span class="hljs-type">int8</span> | <span class="hljs-type">int16</span> | <span class="hljs-type">int32</span> | <span class="hljs-type">int64</span> | <span class="hljs-type">uint</span> | <span class="hljs-type">uint8</span> | <span class="hljs-type">uint16</span> | <span class="hljs-type">uint32</span> | <span class="hljs-type">uint64</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Uint <span class="hljs-keyword">interface</span> &#123;<br>    <span class="hljs-type">uint</span> | <span class="hljs-type">uint8</span> | <span class="hljs-type">uint16</span> | <span class="hljs-type">uint32</span> | <span class="hljs-type">uint64</span><br>&#125;<br><br><span class="hljs-comment">// 接口Status代表 Int和Uint的交集</span><br><span class="hljs-keyword">type</span> Status <span class="hljs-keyword">interface</span> &#123;  <br>    Int<br>    Uint<br>&#125;<br></code></pre></td></tr></table></figure></li><li>空集：如果多行类型没有交集，就是空集.    <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// 类型 ~int 和 ~float 没有相交的类型，所以接口 Bad 代表的类型集为空</span><br><span class="hljs-keyword">type</span> Bad <span class="hljs-keyword">interface</span> &#123;<br>    ~<span class="hljs-type">int</span><br>    ~float <br>&#125; <br></code></pre></td></tr></table></figure></li></ul><h3 id="4-2-接口类型"><a href="#4-2-接口类型" class="headerlink" title="4.2 接口类型"></a>4.2 接口类型</h3><ul><li>基本接口: 接口的定义中只有方法    <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// 接口中只有方法，所以是基本接口</span><br><span class="hljs-keyword">type</span> MyError <span class="hljs-keyword">interface</span> &#123; <br>    Error() <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>一般接口: 接口的定义中不仅有方法，还有类型    <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// 接口 Uint 中有类型，所以是一般接口</span><br><span class="hljs-keyword">type</span> Uint <span class="hljs-keyword">interface</span> &#123; <br>    ~<span class="hljs-type">uint</span> | ~<span class="hljs-type">uint8</span> | ~<span class="hljs-type">uint16</span> | ~<span class="hljs-type">uint32</span> | ~<span class="hljs-type">uint64</span><br>&#125;<br><br><span class="hljs-comment">// ReadWriter 接口既有方法也有类型，所以是一般接口</span><br><span class="hljs-keyword">type</span> ReadWriter <span class="hljs-keyword">interface</span> &#123;  <br>    ~<span class="hljs-type">string</span> | ~[]<span class="hljs-type">rune</span><br><br>    Read(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br>    Write(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br>&#125;<br><br><span class="hljs-comment">// 一般接口类型不能用来定义变量，只能用于泛型的类型约束中  </span><br><br><span class="hljs-comment">// 错误。Uint是一般接口，只能用于类型约束，不得用于变量定义</span><br><span class="hljs-keyword">var</span> uintInf Uint   <br></code></pre></td></tr></table></figure></li><li>如何实现一般接口？ <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// 先定义一个具体的类型，然后再实现具体的方法 </span><br><br><span class="hljs-comment">// StringReadWriter 实现了接口 ReadWriter</span><br><span class="hljs-keyword">type</span> StringReadWriter <span class="hljs-type">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s StringReadWriter)</span></span> Read(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s StringReadWriter)</span></span> Write(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.kunkkawu.com/archives/shen-ru-li-jie-golang-de-fan-xing">https://www.kunkkawu.com/archives/shen-ru-li-jie-golang-de-fan-xing</a>  </li><li><a href="https://juejin.cn/post/7229462763947917367">https://juejin.cn/post/7229462763947917367</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>泛型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB复合索引的ESR原则</title>
    <link href="/2024/02/21/MongoDB%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84ESR%E5%8E%9F%E5%88%99/"/>
    <url>/2024/02/21/MongoDB%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84ESR%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<p>提到索引，大家都不会陌生，它的重要性在数据库中不言而喻。常见的存储如MysQL，MongoDB都支持多种类型的索引。本文主要以实际工作中碰到的例子聊一下MongoDB中的复合索引。</p><span id="more"></span>  <p>所谓复合索引，就是包含多个字段的索引，比如index(a,b)。复合索引在使用的过程中主要有两个原则： </p><ul><li>最左匹配原则 </li><li>ESR原则</li></ul><h3 id="1-最左匹配原则"><a href="#1-最左匹配原则" class="headerlink" title="1. 最左匹配原则"></a>1. 最左匹配原则</h3><p>最左匹配原则比较好理解，他和MySQL中的最左匹配原则一致，即最左优先：在检索数据时从复合索引的最左边开始匹配。</p><p>复合索引创建时一个基本的原则就是：将选择性最强的列放到最前面。</p><p>选择性最高指的是数据的重复值最少，因为区分度高的列能够很容易过滤掉很多的数据。如果组合索引中第一次能够过滤掉很多的数据，后面的索引查询的数据范围就小了很多了。</p><h3 id="2-ESR原则"><a href="#2-ESR原则" class="headerlink" title="2. ESR原则"></a>2. ESR原则</h3><p><a href="https://www.mongodb.com/docs/manual/tutorial/equality-sort-range-rule/">The ESR (Equality, Sort, Range) Rules</a> </p><p>简单来说就是我们在构建复合索引时，需要根据以下三项原则的顺序进行构建：  </p><ul><li>等值查询字段放在最前面</li><li>中间放排序字段</li><li>最后是范围查询字段</li></ul><p>E 放在前面比较好理解，等值匹配过滤掉大量数据，「那为什么是 ESR 不是 ERS 呢?」<br><img src="/img/MongoDB%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84ESR%E5%8E%9F%E5%88%99/1.png"><br>如图所示，如果把范围匹配放在中间，那么后续我们排序的时候只能进行「内存排序」，内存排序是比较消耗资源的，数据量大时可能会面临着「多次的磁盘读取刷内存操作」，对性能影响比较显著。</p><h3 id="3-实际案例分析"><a href="#3-实际案例分析" class="headerlink" title="3. 实际案例分析"></a>3. 实际案例分析</h3><p>以上两个原则看起来比较简单，但笔者在实际应用中还是踩了一些坑。</p><p>我有一个这样的mongo集合： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Demo <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// QueueID 队列id</span><br>QueueID <span class="hljs-type">string</span> <span class="hljs-string">`bson:&quot;queue_id,omitempty&quot;`</span><br><br><span class="hljs-comment">// Status 任务状态</span><br>Status <span class="hljs-type">int</span> <span class="hljs-string">`bson:&quot;status,omitempty&quot;`</span><br><br><span class="hljs-comment">// UpdateTime 更新时间</span><br>UpdateTime time.Time <span class="hljs-string">`bson:&quot;update_time,omitempty&quot;`</span><br><br><span class="hljs-comment">// 其他字段</span><br>xxxxx<br><br>&#125; <br></code></pre></td></tr></table></figure><p>mongo在查询时需要执行类似如下条件的查询：</p><pre><code class="go">db.collections.find(&#123; queue_id: 123, status: &#123; $in: [1, 2, 3] &#125; &#125;).sort(&#123; updateTime: 1 &#125;).limit(1)</code></pre><p>即：查询指定queue_id, 指定status范围，并按照updateTime进行升序的一条记录。   </p><p>在初步了解ESR原则后，我一想，这不就是queue_id为等值查询、updateTime为排序查询、status为范围查询的经典情况吗，大手一挥就创建了一个（queue_id, updateTime, status）的复合索引并愉快的上线了。</p><p>然而待数据量增大后，发现一个比较严重的问题，Mongo实例的CPU飙到了60%，排查原因发现索引执行不太正常。</p><p>参考官方资料后，发现in在执行的时候，可能是等值查询也可能是范围查询<br><img src="/img/MongoDB%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84ESR%E5%8E%9F%E5%88%99/2.png">    </p><ul><li>如果in单独使用，就是等值查询</li><li>如果in和sort一起使用，就是范围查询（针对同一个字段）</li></ul><p>所以在本例中，status的使用是等值查询，应该放在updateTime的前面，将索引修改为（queue_id, status, updateTime）后，CPU使用率即刻下降到30%左右。</p>]]></content>
    
    
    <categories>
      
      <category>MongoDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MongoDB</tag>
      
      <tag>索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka高性能分析</title>
    <link href="/2024/02/17/kafka%E9%AB%98%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    <url>/2024/02/17/kafka%E9%AB%98%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Kafka</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kafka</tag>
      
      <tag>高可用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka高可用分析</title>
    <link href="/2024/02/17/kafka%E9%AB%98%E5%8F%AF%E7%94%A8%E5%88%86%E6%9E%90/"/>
    <url>/2024/02/17/kafka%E9%AB%98%E5%8F%AF%E7%94%A8%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Kafka</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kafka</tag>
      
      <tag>高可用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang限流器</title>
    <link href="/2024/01/07/Golang%E9%99%90%E6%B5%81/"/>
    <url>/2024/01/07/Golang%E9%99%90%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<p>在高并发业务场景下，保护系统时，常用的”三板斧”有：”熔断、降级和限流”。本文主要记录golang中常用的限流算法的实现方式。这里所说的限流并非是网关层面或者服务调度之间的限流，而是业务代码中的逻辑限流。</p><span id="more"></span>   <p>限流算法常用的几种实现方式有如下四种：</p><ul><li>计数器</li><li>滑动窗口</li><li>漏桶</li><li>令牌桶</li></ul><h2 id="1-计数器"><a href="#1-计数器" class="headerlink" title="1. 计数器"></a>1. 计数器</h2><h3 id="1-1-原理"><a href="#1-1-原理" class="headerlink" title="1.1 原理"></a>1.1 原理</h3><p>计数器是一种最简单限流算法，其原理就是：<strong>在一段时间间隔内，对请求进行计数，与阀值进行比较判断是否需要限流，一旦到了时间临界点，将计数器清零。</strong></p><ul><li>可以在程序中设置一个变量 count，当过来一个请求我就将这个数 +1，同时记录请求时间。</li><li>当下一个请求来的时候判断 count 的计数值是否超过设定的频次，以及当前请求的时间和第一次请求时间是否在 1 分钟内。</li><li>如果在 1 分钟内并且超过设定的频次则证明请求过多，后面的请求就拒绝掉。</li><li>如果该请求与第一个请求的间隔时间大于计数周期，且 count 值还在限流范围内，就重置 count。</li></ul><p><img src="/img/Golang%E9%99%90%E6%B5%81/1.png"> </p><h3 id="1-2-缺点"><a href="#1-2-缺点" class="headerlink" title="1.2 缺点"></a>1.2 缺点</h3><p>计数器算法存在“时间临界点”缺陷。比如每一分钟限制200个请求，可以在00:00:00-00:00:58秒里面都没有请求，在00:00:59瞬间发送200个请求，这个对于计数器算法来是允许的，然后在00:01:00再次发送200个请求，意味着在短短1s内发送了400个请求，如果量更大呢，系统可能会承受不住瞬间流量，导致系统崩溃。<br><img src="/img/Golang%E9%99%90%E6%B5%81/2.png"></p><h2 id="2-滑动窗口"><a href="#2-滑动窗口" class="headerlink" title="2. 滑动窗口"></a>2. 滑动窗口</h2><h3 id="2-1-原理"><a href="#2-1-原理" class="headerlink" title="2.1 原理"></a>2.1 原理</h3><p>滑动窗口算法将一个大的时间窗口分成多个小窗口，每次大窗口向后滑动一个小窗口，并保证大的窗口内流量不会超出最大值，这种实现比固定窗口的流量曲线更加平滑。</p><p>普通时间窗口有一个问题，比如窗口期内请求的上限是200，假设有200个请求集中在前1s的后100ms，200个请求集中在后1s的前100ms，其实在这200ms内就已经请求超限了，但是由于时间窗每经过1s就会重置计数，就无法识别到这种请求超限。</p><p><img src="/img/Golang%E9%99%90%E6%B5%81/3.png"><br>对于滑动时间窗口，我们可以把1ms的时间窗口划分成一些小窗口，上图中我们用红色的虚线代表一个时间窗口（一分钟），每个时间窗口有 6 个格子，每个格子是 10 秒钟。每过 10 秒钟时间窗口向右移动一格，可以看红色箭头的方向。我们为每个格子都设置一个独立的计数器 Counter，假如一个请求在 0:45 访问了那么我们将第五个格子的计数器 +1（也是就是 0:40~0:50），在判断限流的时候需要把所有格子的计数加起来和设定的频次进行比较即可。   </p><p>当用户在0:59 秒钟发送了 200 个请求就会被第六个格子的计数器记录 +200，当下一秒的时候时间窗口向右移动了一个，此时计数器已经记录了该用户发送的 200 个请求，所以再发送的话就会触发限流，则拒绝新的请求。 </p><h3 id="2-2-缺点"><a href="#2-2-缺点" class="headerlink" title="2.2 缺点"></a>2.2 缺点</h3><p>滑动窗口算法是计数器算法的一种改进[计数器就是只有一个格子的滑动窗口]，但从根本上并没有真正解决固定窗口算法的临界突发流量问题。想让限流做的更精确只能划分更多的格子。</p><h2 id="3-漏桶算法"><a href="#3-漏桶算法" class="headerlink" title="3. 漏桶算法"></a>3. 漏桶算法</h2><h3 id="3-1-原理"><a href="#3-1-原理" class="headerlink" title="3.1 原理"></a>3.1 原理</h3><p>漏桶算法是首先想象有一个木桶，桶的容量是固定的。当有请求到来时先放到木桶中，处理请求的worker以固定的速度从木桶中取出请求进行相应。如果木桶已经满了，直接返回请求频率超限的错误码或者页面。   </p><p>漏桶算法是流量最均匀的限流实现方式，一般用于流量“整形”。例如保护数据库的限流，先把对数据库的访问加入到木桶中，worker再以db能够承受的qps从木桶中取出请求，去访问数据库。<br><img src="/img/Golang%E9%99%90%E6%B5%81/4.png">    </p><h3 id="3-2-缺点"><a href="#3-2-缺点" class="headerlink" title="3.2 缺点"></a>3.2 缺点</h3><p>木桶流入请求的速率是不固定的，但是流出的速率是恒定的。这样的话能保护系统资源不被打满，但是面对突发流量时会有大量请求失败，不适合电商抢购和微博出现热点事件等场景的限流。  </p><h2 id="4-令牌桶算法"><a href="#4-令牌桶算法" class="headerlink" title="4. 令牌桶算法"></a>4. 令牌桶算法</h2><h3 id="4-1-原理"><a href="#4-1-原理" class="headerlink" title="4.1 原理"></a>4.1 原理</h3><p>令牌桶是反向的”漏桶”，它是以恒定的速度往木桶里加入令牌，木桶满了则不再加入令牌。服务收到请求时尝试从木桶中取出一个令牌，如果能够得到令牌则继续执行后续的业务逻辑。如果没有得到令牌，直接返回访问频率超限的错误码或页面等，不继续执行后续的业务逻辑。</p><p>特点：由于木桶内只要有令牌，请求就可以被处理，所以令牌桶算法可以支持突发流量<br><img src="/img/Golang%E9%99%90%E6%B5%81/0.png">      </p><p>同时由于往木桶添加令牌的速度是恒定的，且木桶的容量有上限，所以单位时间内处理的请求书也能够得到控制，起到限流的目的。假设加入令牌的速度为 1 token&#x2F;10ms，桶的容量为500，在请求比较的少的时候（小于每10毫秒1个请求）时，木桶可以先”攒”一些令牌（最多500个）。当有突发流量时，一下把木桶内的令牌取空，也就是有500个在并发执行的业务逻辑，之后要等每10ms补充一个新的令牌才能接收一个新的请求。</p><h3 id="4-2-适用场景"><a href="#4-2-适用场景" class="headerlink" title="4.2 适用场景"></a>4.2 适用场景</h3><p>适合电商抢购或者微博出现热点事件这种场景，因为在限流的同时可以应对一定的突发流量。如果采用漏桶那样的均匀速度处理请求的算法，在发生热点时间的时候，会造成大量的用户无法访问，对用户体验的损害比较大。 </p><h3 id="4-3-实现"><a href="#4-3-实现" class="headerlink" title="4.3 实现"></a>4.3 实现</h3><p>golang官方实现了令牌桶限流方法<code>Limiter</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Limiter <span class="hljs-keyword">struct</span> &#123;<br>mu     sync.Mutex<br>limit  Limit<br>burst  <span class="hljs-type">int</span> <span class="hljs-comment">// 令牌桶的大小</span><br>tokens <span class="hljs-type">float64</span><br>last time.Time <span class="hljs-comment">// 上次更新tokens的时间</span><br>lastEvent time.Time <span class="hljs-comment">// 上次发生限速器事件的时间（通过或者限制都是限速器事件）</span><br>&#125; <br></code></pre></td></tr></table></figure><p>其主要字段的作用是：  </p><ul><li>limit：limit字段表示往桶里放Token的速率，它的类型是Limit，是int64的类型别名。设置limit时既可以用数字指定每秒向桶中放多少个Token，也可以指定向桶中放Token的时间间隔，其实指定了每秒放Token的个数后就能计算出放每个Token的时间间隔了。</li><li>burst: 令牌桶的大小。</li><li>tokens: 桶中的令牌。</li><li>last: 上次往桶中放 Token 的时间。</li><li>lastEvent：上次发生限速器事件的时间（通过或者限制都是限速器事件）</li></ul><h4 id="4-3-1-构造限流器"><a href="#4-3-1-构造限流器" class="headerlink" title="4.3.1 构造限流器"></a>4.3.1 构造限流器</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">limiter := rate.NewLimiter(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure><p>这里有两个参数：</p><ul><li>第一个参数是 r Limit，设置的是限流器Limiter的limit字段，代表每秒可以向 Token 桶中产生多少 token。Limit 实际上是 float64 的别名。</li><li>第二个参数是 b int，b 代表 Token 桶的容量大小，也就是设置的限流器 Limiter 的burst字段。</li></ul><p>那么，对于以上例子来说，其构造出的限流器的令牌桶大小为 100, 以每秒 10 个 Token 的速率向桶中放置 Token。</p><h4 id="4-3-2-使用限流器"><a href="#4-3-2-使用限流器" class="headerlink" title="4.3.2 使用限流器"></a>4.3.2 使用限流器</h4><p>Limiter 提供了三类方法供程序消费 Token，可以每次消费一个 Token，也可以一次性消费多个 Token。 每种方法代表了当 Token 不足时，各自不同的对应手段，可以阻塞等待桶中Token补充，也可以直接返回取Token失败。   </p><p>其中比较常见的是Wait&#x2F;WaitN方法 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lim *Limiter)</span></span> Wait(ctx context.Context) (err <span class="hljs-type">error</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lim *Limiter)</span></span> WaitN(ctx context.Context, n <span class="hljs-type">int</span>) (err <span class="hljs-type">error</span>)<br></code></pre></td></tr></table></figure><p>Wait 实际上就是 WaitN(ctx,1)。   </p><p>当使用 Wait 方法消费 Token 时，如果此时桶内 Token 数组不足 (小于 N)，那么 Wait 方法将会阻塞一段时间，直至 Token 满足条件。如果充足则直接返回。  </p><p>这里可以看到，Wait 方法有一个 context 参数。我们可以设置 context 的 Deadline 或者 Timeout，来决定此次 Wait 的最长时间。     </p><p>其他还有两种用法分别如下，具体使用方法可查阅官方文档信息</p><ul><li>Allow&#x2F;AllowN </li><li>Reserve&#x2F;ReserverN</li></ul>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>限流器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis分布式锁</title>
    <link href="/2023/12/23/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <url>/2023/12/23/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    
    <content type="html"><![CDATA[<p>分布式锁，就是控制分布式系统不同进程共同访问共享资源的一种锁的实现。如果不同的系统或同一个系统的不同主机之间共享了某个临界资源，往往需要互斥来防止彼此干扰，以保证一致性。 </p><span id="more"></span>   <h2 id="Redis分布式锁的实现方式"><a href="#Redis分布式锁的实现方式" class="headerlink" title="Redis分布式锁的实现方式"></a>Redis分布式锁的实现方式</h2><blockquote><p>在线redis环境：<a href="https://try.redis.io/">https://try.redis.io/</a>   </p></blockquote><h3 id="1-什么是分布式锁"><a href="#1-什么是分布式锁" class="headerlink" title="1. 什么是分布式锁"></a>1. 什么是分布式锁</h3><p>分布式锁就是，控制分布式系统不同进程共同访问共享资源的一种锁的实现。如果不同的系统或同一个系统的不同主机之间共享了某个临界资源，往往需要互斥来防止彼此干扰，以保证一致性。<br>分布式锁一般具有以下特征:  </p><ul><li>互斥性：任意时刻只有一个客户端可持有</li><li>超时释放：持有锁超时可以及时释放，防止死锁和不必要的资源浪费  </li><li>可重入性：一个线程获取锁之后，还可以再次对其请求加锁</li><li>高性能高可用：加锁和解锁需要开销尽量低，同时也要保证高可用 </li><li>安全性：锁只能被持有的客户端删除，不能被其他客户端删除</li></ul><!--  --><p><img src="/img/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/1.png"></p><h3 id="2-SETNX"><a href="#2-SETNX" class="headerlink" title="2. SETNX"></a>2. SETNX</h3><p>一提到使用Redis作为分布式锁，大家耳熟能详的就会想到<code>SETNX + EXPIRE</code>。即先用<code>setnx</code>来抢锁，然后再用<code>expire</code>设置一个过期时间。</p><blockquote><p>SETNX是 SET IF NOT EXISTS的简称，顾名思义就是不存在就设置<br>命令使用：SETNX key value<br>如果key不存在，设置成功返回1，如果key已经存在，设置失败返回0</p></blockquote><p>但是直接使用SETNX + EXPIRE 指令，会存在一些问题：</p><ul><li>原子性：setnx 和 exipre是两个命令，如果设置过期时间出错，就会导致长时间持有锁得不到释放。</li><li>误删除问题：假设线程a执行完后，主动去释放锁。但它不知道当前的锁可能是线程b持有的（线程a去释放锁时，有可能过期时间已经到了，此时线程b进来占有了锁）。那线程a就把线程b的锁释放掉了，但是线程b临界区业务代码可能都还没执行完成。</li></ul><h4 id="2-1-原子性"><a href="#2-1-原子性" class="headerlink" title="2.1 原子性"></a>2.1 原子性</h4><p>为解决原子性问题，常见的有两种方式:  </p><h5 id="2-1-1-使用Lua脚本"><a href="#2-1-1-使用Lua脚本" class="headerlink" title="2.1.1 使用Lua脚本"></a>2.1.1 使用Lua脚本</h5><p>lua脚本在执行过程中，是可以保证原子处理的，可以将setnx和expire两个命令都放到lua脚本中进行操作。  </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&#x27;setnx&#x27;</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">1</span>]) == <span class="hljs-number">1</span> <span class="hljs-keyword">then</span><br>   redis.call(<span class="hljs-string">&#x27;expire&#x27;</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">2</span>])<br><span class="hljs-keyword">else</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span>;<br></code></pre></td></tr></table></figure><h5 id="2-1-2-使用SET的扩展命令"><a href="#2-1-2-使用SET的扩展命令" class="headerlink" title="2.1.2 使用SET的扩展命令"></a>2.1.2 使用SET的扩展命令</h5><p>虽然<code>SETNX</code>和<code>EXPIRE</code>两个指令是独立的，但是单独的一个SET命令是却是原子的，可以使用SET的参数扩展功能实现NX和EXPIRE的能力<br><code>SET key value [EX seconds] [PX millseconds] NX</code>  </p><blockquote><p>SET key value [EX seconds] [PX milliseconds] NX<br>NX :表示key不存在的时候，才能set成功，也即保证只有第一个客户端请求才能获得锁，而其他客户端请求只能等其释放锁，才能获取。<br>EX seconds :设定key的过期时间，时间单位是秒。<br>PX milliseconds: 设定key的过期时间，单位为毫秒  </p></blockquote><p>在实际的开发过程中，我们一般使用第三方库，不会直接执行redis的cmd命令。可以在使用第三方的sdk时，查看sdk是否已经提供了一些原子的操作，避免自己写原生lua脚本或者命令。比如go-redis中，SETNX + EXPIRE已经可以在一个客户端操作中完成：  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Lock 使用 SETNX实现加锁</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Client)</span></span> Lock(key, value <span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>ret := c.client.SetNX(key, value, time.Minute)<br><span class="hljs-keyword">if</span> ret.Val() &#123;<br>fmt.Println(<span class="hljs-string">&quot;加锁成功&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;加锁失败&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// Redis `SET key value [expiration] NX` command.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Zero expiration means the key has no expiration time.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cmdable)</span></span> SetNX(key <span class="hljs-type">string</span>, value <span class="hljs-keyword">interface</span>&#123;&#125;, expiration time.Duration) *BoolCmd &#123;&#125;<br><br></code></pre></td></tr></table></figure><h4 id="2-2-误删除"><a href="#2-2-误删除" class="headerlink" title="2.2 误删除"></a>2.2 误删除</h4><p>既然锁可能会被别的线程删除，那给锁的value值设置一个标记当前的线程唯一值即可。在删除的时候首先校验值是否相等，只有相等的情况下才可以删除锁。<br>同样的，为保证一致性，值的比较和删除操作需要保证原子性。 </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&#x27;get&#x27;</span>,KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>] <span class="hljs-keyword">then</span> <br>   <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&#x27;del&#x27;</span>,KEYS[<span class="hljs-number">1</span>]) <br><span class="hljs-keyword">else</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span>;<br></code></pre></td></tr></table></figure><h3 id="3-Redisson"><a href="#3-Redisson" class="headerlink" title="3. Redisson"></a>3. Redisson</h3><p>参考文章：  </p><ul><li><a href="https://blog.csdn.net/qq_34826261/article/details/126177704">https://blog.csdn.net/qq_34826261&#x2F;article&#x2F;details&#x2F;126177704</a>  </li><li><a href="https://zhuanlan.zhihu.com/p/135864820">https://zhuanlan.zhihu.com/p/135864820</a>  </li><li><a href="https://juejin.cn/post/7168802584684134413">https://juejin.cn/post/7168802584684134413</a></li></ul><p>上面介绍的<code>SETNX + Exipred + 原子操作 + 唯一值校验删除</code>的方案在很大程度上已经能够满足使用，但是还有一个可能存在的情况没有解决： </p><ul><li>锁过期释放，但业务还没执行完成：假设线程a获取锁成功，一直在执行临界区的代码。100s过去后，它还没执行完。但这时候锁已经过期了，此时线程b又请求过来。显然线程b就可以获得锁成功，也开始执行临界区的代码。那么问题就来了，临界区的业务代码都不是严格串行执行。</li></ul><p>针对这种问题，Redisson框架做了一些额外的优化，在加锁的同时开启一个定时守护线程，每隔一段时间检查锁是否还存在，存在则对锁的过期时间延长，防止锁过期提前释放。  </p><p>Redisson主要原理及结构如下：  </p><ul><li>基于Redis命令的实现： Redisson利用了Redis的单线程特性和原子操作的特点。它通过调用Redis的SETNX命令来尝试获取锁，当锁不存在时，才能获取到锁。</li><li>心跳续约(看门狗)机制： 为防止业务逻辑还没执行完锁就到期的问题，Redisson在获取锁之后会启动一个定时任务来周期性地续约锁的有效时间。</li><li>实现可重入锁： Redisson支持可重入锁，保证同一线程在持有锁的情况下能够多次获取锁，而不会因为自己已经持有锁而被阻塞。  </li><li>分布式锁释放的安全性保证： Redisson通过Lua脚本来释放锁，保证了释放锁的原子性。使用Lua脚本可以保证释放锁的操作是原子的，避免了在执行释放锁逻辑时出现的并发问题。</li></ul><p><img src="/img/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/redisson.png">   </p><blockquote><p>部分核心逻辑如下： </p><ul><li>加锁 <ul><li>每次加锁都有一个加锁等待时间 </li><li>如果加锁成功，直接返回true</li><li>如果加锁失败，则订阅锁释放消息，在加锁等待时间内监听锁释放消息，如果一直没有监听到，则取消订阅并返回false </li><li>如果在等待时间内监听到锁释放消息，则进入一个不断重试获取锁的循环</li></ul></li><li>续期机制  <ul><li>只有在加锁时没有设置过期时间时才会启用Watch Dog机制  </li><li>Watch Dog启动守护线程，守护线程轮询周期为：internalLockLeaseTime&#x2F;3。internalLockLeaseTime的默认值由lockWatchdogTimeout来配置。默认值为30秒。也就是说默认情况下，守护线程每10秒检查续期</li></ul></li></ul></blockquote><h3 id="4-RedLock"><a href="#4-RedLock" class="headerlink" title="4. RedLock"></a>4. RedLock</h3><p>Redisson解决了锁超时续期自动释放的问题，但是还有一种极端的情况没有解决：  </p><ul><li>客户端A尝试在Redis Master节点上锁，客户端A成功获得锁的瞬间，锁数据还没有同步至Slave节点。这时Master挂了，于是发生主从切换，其它客户端连接到Slave节点尝试抢占锁，由于Slave没有客户端A的上锁信息。自然又会有一个新的客户端B抢到锁，此时就会出现两个客户端同时拥有分布式锁的奇葩现像。</li></ul><p>鉴于此，Redis作者提出一种更高级的RedLock算法，它需要部署 N （N &gt;&#x3D; 2n+1）个独立的 Redis master实例，且实例之间没有任何的联系。也就是说，只要一半以上的 Redis 实例加锁成功，那么 Redlock 依然可以正常运行。  </p><p><img src="/img/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/redlock.png">  </p><p>假设我们有 5 个 Redis 实例，当我们对 order1 这个订单加锁时，先记录当前时间用于统计加锁过程花费的时间，然后依次让 5 个 Redis 实例执行 SET order1 token NX EX 60 命令，最后统计<strong>加锁成功的实例数量以及加锁过程耗费的时间</strong>  </p><ul><li>统计个数: 当超过一半的加锁成功，认为是成功   </li><li>统计时间: 避免整体的加锁时长已经超过锁本身的有效时间，比如锁的过期时间是3s，但是加锁过程耗费了4s，肯定是认为加锁失败的。</li></ul><p>解锁过程相对简单，只需要5个实例依次删除redis key即可。   </p><p>Redlock在Redisson中也有对应的实现，不过在最新版的Redisson中，Redlock已经不再建议使用.因为现在加锁操作实现，可以等所有从节点数据同步了才算加锁成功。这样的话就可以保证主从切换锁不会丢失了。  </p><pre><code class="hljs">8.4. RedLockThis object is deprecated. Use RLock or RFencedLock instead.</code></pre><p>可以通过Redis的Wait命令实现主从同步  </p><blockquote><p>Redis WAIT 命令用来阻塞当前客户端，直到所有先前的写入命令成功传输并且至少由指定数量的从节点复制完成。如果执行超过超时时间（以毫秒为单位），则即使尚未完成指定数量的从结点复制，该命令也会返回。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>分布式锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
