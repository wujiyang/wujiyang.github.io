<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Golang Channels 解析</title>
    <link href="/2024/09/08/golang-channels/"/>
    <url>/2024/09/08/golang-channels/</url>
    
    <content type="html"><![CDATA[<p>Channel是一个先进先出的管道，它提供了一种同步的机制，确保数据发送和接收之间的顺序以及正确性。通过使用channel，我们可以避免在多个协程之间共享数据时出现的竞争条件和其他并发问题。</p><span id="more"></span>  <h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>在Go语言中，一种广为人知的并发编程模型是CSP(Communicating Sequential Processes)模型，提倡通过通信共享内存，而不是通过共享内存来通信。而channel正是这样一种特殊的类型，用于在并发编程中实现不同协程之间的通信和同步。  </p><p>Channel是一个先进先出的管道，它提供了一种同步的机制，确保数据发送和接收之间的顺序以及正确性。通过使用channel，我们可以避免在多个协程之间共享数据时出现的竞争条件和其他并发问题。<br><img src="/img/golang-channels/1.png"><br>通道类型的值本身是并发安全的，这也是 Go 语言自带的、唯一一个可以满足并发安全性的类型</p><h2 id="2-基本特性"><a href="#2-基本特性" class="headerlink" title="2. 基本特性"></a>2. 基本特性</h2><p>在Go中，channel的关键字是chan，通过箭头表示数据流向←，具有以下基本特性：</p><ul><li>Channel是类型相关的，特定类型的Channel只能存放特定类型的数据。</li><li>channel分缓冲型(buffered)和非缓冲型(unbuffered），非缓冲型的size是0，缓冲型的size是缓冲区的大小。</li><li>缓冲型通道读写经过buffer，非缓冲型通道的数据交互不经过通道，直接通过内存写传递。</li><li>channel分单向和双向，单向的意思是只能读（或写），双向是既能读也能写。</li><li>channel满时“写”会阻塞，channel空时“读”会阻塞。</li></ul><h3 id="2-1-无缓冲通道"><a href="#2-1-无缓冲通道" class="headerlink" title="2.1 无缓冲通道"></a>2.1 无缓冲通道</h3><p>无缓冲的 channel（unbuffered channel），其缓冲区大小则默认为 0。在功能上其接受者会阻塞等待并阻塞应用程序，直至收到通信和接收到数据。<br><img src="/img/golang-channels/2.png"><br>无缓冲通道在处理时，必须同时有发送者和接收者，不然就会阻塞。如下的案例中，如果先在main中往ch写数据，运行时就会抛错：fatal error: all goroutines are asleep - deadlock!</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-comment">// 启用goroutine从通道接收值</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>ret := &lt;-ch<br>fmt.Println(<span class="hljs-string">&quot;接收成功: &quot;</span>, ret)<br>&#125;()<br><br>ch &lt;- <span class="hljs-number">10</span><br>fmt.Println(<span class="hljs-string">&quot;发送成功&quot;</span>)<br>time.Sleep(time.Second)<br>&#125;<br><span class="hljs-comment">// 发送成功</span><br><span class="hljs-comment">// 接收成功:  10</span><br></code></pre></td></tr></table></figure><h3 id="2-2-有缓冲通道"><a href="#2-2-有缓冲通道" class="headerlink" title="2.2 有缓冲通道"></a>2.2 有缓冲通道</h3><p><img src="/img/golang-channels/3.png"><br>解决无缓冲通道（阻塞）死锁的问题，就是使用有缓冲的通道。通过缓存的使用，可以尽量避免阻塞，提供应用的性能。只要通道的容量大于零，那么该通道就是有缓冲的通道，通道的容量表示通道中能存放元素的数量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// 创建一个容量为 1 的有缓冲区的通道</span><br><br>ch &lt;- <span class="hljs-number">10</span><br>fmt.Println(<span class="hljs-string">&quot;发送成功&quot;</span>)<br><br>ret := &lt;-ch<br>fmt.Println(<span class="hljs-string">&quot;接收成功: &quot;</span>, ret)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-单向通道"><a href="#2-3-单向通道" class="headerlink" title="2.3 单向通道"></a>2.3 单向通道</h3><p>有时候我们将通道作为参数在多个函数间传递时，可以根据不同的任务类型对通道进行限制，比如限制通道在函数中只能发送或只能接收。<br>注意：发送和接收是针对channel而言，比如发送是指向channel发送数据，接收是指从channel接收数据，可以通过箭头的数据流向来标识类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span>) <span class="hljs-comment">// 单向发送通道</span><br>ch := <span class="hljs-built_in">make</span>(&lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>) <span class="hljs-comment">// 单向接收通道</span><br></code></pre></td></tr></table></figure><p>如下一个场景中，首先往一个单向发送通道写入数据，然后经中转将数据写入另一个通道，最后再以单向接收通道的形式读出数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 单向发送通道，将数据写入channel</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">a</span><span class="hljs-params">(in <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>in &lt;- i<br>&#125;<br><span class="hljs-built_in">close</span>(in)<br>&#125;<br><br><span class="hljs-comment">// 单向发送 in 通道， 单向接收 out 通道，将数据从一个channel写入另一个channel</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">a2b</span><span class="hljs-params">(in <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span>, out &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> out &#123;<br>in &lt;- i * i<br>&#125;<br><span class="hljs-built_in">close</span>(in)<br>&#125;<br><br><span class="hljs-comment">// 单向接收通道，从channel读出数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">b</span><span class="hljs-params">(out &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> out &#123;<br>fmt.Println(i)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>in := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>out := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">go</span> a(in)<br><span class="hljs-keyword">go</span> a2b(out, in)<br>b(out)<br>&#125;<br><span class="hljs-comment">// 0 1 4 9 16 25 36 49 64 81</span><br></code></pre></td></tr></table></figure><h3 id="2-4-Channel的遍历"><a href="#2-4-Channel的遍历" class="headerlink" title="2.4 Channel的遍历"></a>2.4 Channel的遍历</h3><p>如何优雅的从通道中获取数据，Go支持以下几种方式：</p><ul><li><code>for range</code>循环<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">3</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i = i + <span class="hljs-number">1</span> &#123;<br>c &lt;- i<br>&#125;<br><span class="hljs-built_in">close</span>(c)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> c &#123;<br>fmt.Println(i)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;Finished&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 0</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// Finished</span><br></code></pre></td></tr></table></figure>需要注意的是，在遍历时如果channel 没有关闭，那么会一直等待下去，出现 deadlock 的错误；如果在遍历时channel已经关闭，那么在遍历完数据后自动退出遍历。也就是说，for range 的遍历方式是阻塞型的遍历方式。</li><li><code>for &#123;&#125;</code>死循环<br>通过for{} 死循环+通道关闭判断的方式来进行取值<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i = i + <span class="hljs-number">1</span> &#123;<br>c &lt;- i<br>&#125;<br><span class="hljs-built_in">close</span>(c)<br>&#125;()<br><br><span class="hljs-keyword">for</span> &#123;<br>i, ok := &lt;-c <span class="hljs-comment">// 通道关闭后再取值ok=false</span><br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>fmt.Println(i)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;Finished&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 0</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// Finished</span><br></code></pre></td></tr></table></figure></li><li><code>for select &#123;&#125;</code>操作<br>select可以支持一组操作处理，通过case语句标识不同的处理场景。如果有多个case满足条件，则go会随机选择其中一个执行，如果没有符合条件的case，则会选择default语句处理。注意：如果没有default语句且没有满足的条件时，select语句会一直阻塞，一般通过select + default 避免阻塞问题.<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fibonacci</span><span class="hljs-params">(c, quit <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br>x, y := <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> c &lt;- x:<br>x, y = y, x+y<br><span class="hljs-keyword">case</span> &lt;-quit:<br>fmt.Println(<span class="hljs-string">&quot;quit&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>quit := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;<br>fmt.Println(&lt;-c)<br>&#125;<br>quit &lt;- <span class="hljs-number">0</span><br>&#125;()<br>fibonacci(c, quit)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-5-异常情况"><a href="#2-5-异常情况" class="headerlink" title="2.5 异常情况"></a>2.5 异常情况</h3><p><img src="/img/golang-channels/4.png"> </p><h4 id="2-5-1-发生Panic"><a href="#2-5-1-发生Panic" class="headerlink" title="2.5.1 发生Panic"></a>2.5.1 发生Panic</h4><ul><li>向一个关闭的 channel 进行写操作</li><li>关闭一个 nil 的 channel</li><li>关闭一个已经关闭的 channel</li></ul><h4 id="2-5-2-发生阻塞"><a href="#2-5-2-发生阻塞" class="headerlink" title="2.5.2 发生阻塞"></a>2.5.2 发生阻塞</h4><ul><li>读一个 nil channel 会被阻塞</li><li>写一个 nil channel 会被阻塞</li><li>读写缓冲为空或者已经满了且没有挂起的接收者和发送者。</li></ul><h2 id="3-常见应用"><a href="#3-常见应用" class="headerlink" title="3. 常见应用"></a>3. 常见应用</h2><h3 id="3-1-通知信号"><a href="#3-1-通知信号" class="headerlink" title="3.1 通知信号"></a>3.1 通知信号</h3><p>通过ch来发送停止信号，当main协程将准备工作做好之后，只需要往ch中写入数据（或关闭chan)，就能够让新起的协程退出for循环。下面中select语法类似于switch，但不同的是，case后面只能是一个面向channel的操作。当没有命中case时，会执行default，因此可以通过select来进行非阻塞的读或写。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">// do something recursively</span><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ch:<br>fmt.Println(<span class="hljs-string">&quot;channel received&quot;</span>)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;waiting&quot;</span>)<br>&#125;<br>&#125;<br>&#125;()<br><span class="hljs-comment">// do something until it is time to terminate goroutine</span><br>ch &lt;- <span class="hljs-literal">true</span> <span class="hljs-comment">// or close(ch)</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-定时任务"><a href="#3-2-定时任务" class="headerlink" title="3.2 定时任务"></a>3.2 定时任务</h3><p>与 timer 结合，实现定时任务执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span><span class="hljs-params">()</span></span> &#123;<br>ticker := time.Tick(<span class="hljs-number">1</span> * time.Second)<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ticker:<br>fmt.Println(<span class="hljs-string">&quot;执行 1s 定时任务&quot;</span>)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">go</span> worker()<br><br>time.Sleep(time.Second * <span class="hljs-number">5</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-生产消费解耦"><a href="#3-3-生产消费解耦" class="headerlink" title="3.3 生产消费解耦"></a>3.3 生产消费解耦</h3><p>服务启动时，启动 n 个 worker，作为工作协程池，这些协程工作在一个 for {} 无限循环里，从某个 channel 消费工作任务并执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>taskCh := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br><span class="hljs-keyword">go</span> worker(taskCh)<br><br><span class="hljs-comment">// 塞任务</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>taskCh &lt;- i<br>&#125;<br><br><span class="hljs-comment">// 等待任务执行完成</span><br>time.Sleep(time.Second * <span class="hljs-number">5</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span><span class="hljs-params">(taskCh &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">const</span> N = <span class="hljs-number">5</span><br><span class="hljs-comment">// 启动 5 个工作协程</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; N; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(id <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>task := &lt;-taskCh<br>fmt.Printf(<span class="hljs-string">&quot;finish task: %d by worker %d\n&quot;</span>, task, id)<br>time.Sleep(time.Second)<br>&#125;<br>&#125;(i)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4-并发数控制"><a href="#3-4-并发数控制" class="headerlink" title="3.4 并发数控制"></a>3.4 并发数控制</h3><p>有时需要定时执行几百个任务，例如每天定时按城市来执行一些离线计算的任务。但是并发数又不能太高，因为任务执行过程依赖第三方的一些资源，对请求的速率有限制。这时就可以通过 channel 来控制并发数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> limit = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> _, w := <span class="hljs-keyword">range</span> workers &#123;<br>limit &lt;- <span class="hljs-number">1</span> <span class="hljs-comment">// limit &lt;- 1在此处会限制创建的goroutine的个数</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>w()<br>&lt;-limit<br>&#125;()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-实践避坑"><a href="#4-实践避坑" class="headerlink" title="4. 实践避坑"></a>4. 实践避坑</h2><h3 id="4-1-死锁"><a href="#4-1-死锁" class="headerlink" title="4.1 死锁"></a>4.1 死锁</h3><p>go 语言新手在编译时很容易碰到这个死锁的问题：fatal error: all goroutines are asleep - deadlock! 在操作系统中，「死锁」就是两个线程互相等待，耗在那里，最后程序不得不终止。go 语言中的「死锁」也是类似的，两个 goroutine 互相等待，导致程序耗在那里，无法继续跑下去.</p><ul><li>只有生产者或者消费者<br>channel 的生产者和消费者必须成对出现，如果缺乏一个，就会造成死锁，例如：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 只有生产者，没有消费者</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span> &#123;<br>    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>    ch &lt;- <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-comment">// 只有消费者，没有生产者</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span> &#123;<br>    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>    &lt;-ch<br>&#125;<br></code></pre></td></tr></table></figure></li><li>生产者和消费者在同一个协程<br>除了需要成对出现，还需要出现在不同的 goroutine 中，例如：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 同一个 goroutine 中同时出现生产者和消费者</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f3</span><span class="hljs-params">()</span></span> &#123;<br>    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>    ch &lt;- <span class="hljs-number">1</span>  <span class="hljs-comment">// 由于消费者还没执行到，这里会一直阻塞住</span><br>    &lt;-ch<br>&#125;<br></code></pre></td></tr></table></figure></li><li>buffered channel 已满，且在同一个goroutine中<br>buffered channel 会将收到的元素先存在 hchan 结构体的 ringbuffer 中，继而才会发生阻塞。而当发生阻塞时，如果阻塞了主 goroutine ，则也会出现死锁。<br>所以实际使用中，推荐尽量使用 buffered channel ，使用起来会更安全</li></ul><h3 id="4-2-内存泄漏"><a href="#4-2-内存泄漏" class="headerlink" title="4.2 内存泄漏"></a>4.2 内存泄漏</h3><p>内存泄漏一般都是通过 OOM(Out of Memory) 告警或者发布过程中对内存的观察发现的，服务内存往往都是缓慢上升，直到被系统 OOM 掉清空内存再周而复始。在 go 语言中，错误地使用 channel 会导致 goroutine 泄漏，进而导致内存泄漏。<br>让 goroutine 泄漏的核心就是：生产者&#x2F;消费者 所在的 goroutine 已经退出，而其对应的 消费者&#x2F;生产者 所在的 goroutine 会永远阻塞住，直到进程退出</p><ul><li>生产者阻塞导致泄漏<br>使用channel做超时控制时，假设客户端超时为 500ms，而实际请求耗时为 2s，则 select 会走到 timeout 的逻辑，这时 g2 退出，channel ch 没有消费者，会一直在等待状态；如果这是在 server 代码中，这个请求处理完后，g1 就会挂起、发生了泄漏。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">leak1</span><span class="hljs-params">()</span></span> &#123;<br>    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>    <span class="hljs-comment">// g1</span><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        time.Sleep(<span class="hljs-number">2</span> * time.Second) <span class="hljs-comment">// 模拟 io 操作</span><br>        ch &lt;- <span class="hljs-number">100</span>                   <span class="hljs-comment">// 模拟返回结果</span><br>    &#125;()<br><br>    <span class="hljs-comment">// g2</span><br>    <span class="hljs-comment">// 阻塞住，直到超时或返回</span><br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-time.After(<span class="hljs-number">500</span> * time.Millisecond):<br>        fmt.Println(<span class="hljs-string">&quot;timeout! exit...&quot;</span>)<br>    <span class="hljs-keyword">case</span> result := &lt;-ch:<br>        fmt.Printf(<span class="hljs-string">&quot;result: %d\n&quot;</span>, result)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>消费者阻塞导致泄漏<br>如果生产者不继续生产，消费者所在的 goroutine 也会阻塞住，不会退出，例如：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">leak2</span><span class="hljs-params">()</span></span> &#123;<br>    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><br>    <span class="hljs-comment">// 消费者 g1</span><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> result := <span class="hljs-keyword">range</span> ch &#123;<br>            fmt.Printf(<span class="hljs-string">&quot;result: %d\n&quot;</span>, result)<br>        &#125;<br>    &#125;()<br><br>    <span class="hljs-comment">// 生产者 g2</span><br>    ch &lt;- <span class="hljs-number">1</span><br>    ch &lt;- <span class="hljs-number">2</span><br>    time.Sleep(time.Second)  <span class="hljs-comment">// 模拟耗时</span><br>    fmt.Println(<span class="hljs-string">&quot;main goroutine g2 done...&quot;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure>这种情况下，只需要增加 close(ch) 的操作即可，for-range 操作在收到 close 的信号后会退出、goroutine 不再阻塞，能够被回收。</li><li>如何预防泄漏<br>预防 goroutine 泄漏的核心就是：创建 goroutine 时就要想清楚它什么时候被回收。具体到执行层面，包括：<ul><li>当 goroutine 退出时，需要考虑它使用的 channel 有没有可能阻塞对应的生产者、消费者的 goroutine；</li><li>尽量使用 buffered channel 使用 buffered channel 能减少阻塞发生、即使疏忽了一些极端情况，也能降低 goroutine 泄漏的概率；</li></ul></li></ul><h3 id="4-3-Close-Channel"><a href="#4-3-Close-Channel" class="headerlink" title="4.3 Close Channel"></a>4.3 Close Channel</h3><ul><li>是否需要close<br>除非必须关闭 chan，否则不要主动关闭。关闭 chan 最优雅的方式，就是不要关闭 chan~<br>当一个 chan 没有 sender 和 receiver 时，即不再被使用时，GC 会在一段时间后标记、清理掉这个 chan。那么什么时候必须关闭 chan 呢？<br>比较常见的是将 close 作为一种通知机制，尤其是生产者与消费者之间是 1:M 的关系时，通过 close 告诉下游：我收工了，你们别读了</li><li>谁来关闭channel<br>chan 关闭的原则:</li><li>Don’t close a channel from the receiver side 不要在消费者端关闭 chan</li><li>Don’t close a channel if the channel has multiple concurrent senders 有多个并发写的生产者时也别关<br>只要遵循这两条原则，就能避免两种 panic 的场景，即：向 closed chan 发送数据，或者是 close 一个 closed chan。<br>按照生产者和消费者的关系可以拆解成以下几类情况：</li><li>一写一读：生产者关闭即可</li><li>一写多读：生产者关闭即可，关闭时下游全部消费者都能收到通知</li><li>多写一读：多个生产者之间需要引入一个协调 channel 来处理信号</li><li>多写多读：与 3 类似，核心思路是引入一个中间层以及使用 try-send 的套路来处理非阻塞的写入.</li></ul><h2 id="5-原理解析"><a href="#5-原理解析" class="headerlink" title="5. 原理解析"></a>5. 原理解析</h2><h3 id="5-1-底层结构"><a href="#5-1-底层结构" class="headerlink" title="5.1 底层结构"></a>5.1 底层结构</h3><p>channel底层是位于go&#x2F;src&#x2F;runtime&#x2F;chan.go文件中的hchan结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// runtime package, chan.go</span><br><span class="hljs-keyword">type</span> hchan <span class="hljs-keyword">struct</span> &#123;<br>    qcount   <span class="hljs-type">uint</span>            <span class="hljs-comment">// 通道里已有元素的数量</span><br>    dataqsiz <span class="hljs-type">uint</span>            <span class="hljs-comment">// 通道buffer(环形队列)的容量</span><br>    buf      unsafe.Pointer  <span class="hljs-comment">// 指向buffer内存的指针（只针对有缓冲的 chan）</span><br>    elemsize <span class="hljs-type">uint16</span>          <span class="hljs-comment">// 通道中元素大小</span><br>    closed   <span class="hljs-type">uint32</span>          <span class="hljs-comment">// 通道是否被关闭的标志。0：未关闭，非0：关闭。</span><br>    elemtype *_type          <span class="hljs-comment">// 通道中元素类型</span><br>    sendx    <span class="hljs-type">uint</span>            <span class="hljs-comment">// 通道写时，写到chan buffer中的位置的索引</span><br>    recvx    <span class="hljs-type">uint</span>            <span class="hljs-comment">// 通道读时，读的元素在通道中的位置的索引</span><br>    recvq    waitq           <span class="hljs-comment">// 因为通道读而阻塞的协程队列</span><br>    sendq    waitq           <span class="hljs-comment">// 因为通道写而阻塞的协程队列</span><br>    lock     mutex           <span class="hljs-comment">// 互斥锁，保证通道读写线程安全</span><br>&#125;<br><br><span class="hljs-comment">// waitq 是 sudog 的一个双向链表</span><br><span class="hljs-keyword">type</span> waitq <span class="hljs-keyword">struct</span> &#123;<br>   first *sudog<br>   last  *sudog<br>&#125;<br><br><span class="hljs-comment">// runtime/runtime2.go</span><br><span class="hljs-comment">// sudog是对go的一个封装</span><br><span class="hljs-keyword">type</span> sudog <span class="hljs-keyword">struct</span> &#123;<br>    g       *g              <span class="hljs-comment">// 阻塞的 goroutine</span><br>    elem    unsafe.Pointer  <span class="hljs-comment">// elem用来存储sender发送数据的地址或recver接收变量的地址</span><br>    c       *hchan          <span class="hljs-comment">// 阻塞的 channel</span><br>    next     *sudog         <br>    prev     *sudog<br>    <span class="hljs-comment">// other fields...</span><br>&#125;<br><br>ch &lt;- <span class="hljs-number">1</span>            <span class="hljs-comment">// 因为“写”而阻塞的goroutine的elem存的是“1”的地址</span><br>val, ok := &lt;- ch   <span class="hljs-comment">// 因为“读”而阻塞的goroutine的elem存的是“val”的地址</span><br></code></pre></td></tr></table></figure><p>一个channel的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">4</span>)<br><span class="hljs-comment">// 未阻塞</span><br>ch &lt;- <span class="hljs-number">1</span><br>ch &lt;- <span class="hljs-number">2</span><br>ch &lt;- <span class="hljs-number">3</span><br><span class="hljs-comment">// 发生阻塞</span><br>ch &lt;- <span class="hljs-number">4</span><br>ch &lt;- <span class="hljs-number">5</span><br>ch &lt;- <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p><img src="/img/golang-channels/5.png"><br><img src="/img/golang-channels/6.png"> </p><h3 id="5-2-Channel的创建"><a href="#5-2-Channel的创建" class="headerlink" title="5.2 Channel的创建"></a>5.2 Channel的创建</h3><p>channel的创建需要使用make关键字，通过make(type, size)来创建各种类型的通道</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">a := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)            <span class="hljs-comment">// unbuffered channel of integers</span><br>b := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">0</span>)         <span class="hljs-comment">// unbuffered channel of integers</span><br>c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *os.File, <span class="hljs-number">100</span>)  <span class="hljs-comment">// buffered channel of pointers to Files</span><br><br>write := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span>)        <span class="hljs-comment">// channel of integers only for writing</span><br>read := <span class="hljs-built_in">make</span>(&lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)         <span class="hljs-comment">// channel of integers only for reading</span><br></code></pre></td></tr></table></figure><p>channel初始化时分为缓冲型和非缓冲型两种，二者最大的区别是缓冲型channel在初始化时会分配ring buf，底层本质上是一个数组。在分配缓冲buf时，如果元素包含指针类型，buf和hchan地址是不连续的，否则就是连续的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makechan</span><span class="hljs-params">(t *chantype, size <span class="hljs-type">int</span>)</span></span> *hchan &#123;<br>elem := t.elem<br><br><span class="hljs-comment">// compiler checks this but be safe.</span><br><span class="hljs-keyword">if</span> elem.size &gt;= <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">16</span> &#123;<br>throw(<span class="hljs-string">&quot;makechan: invalid channel element type&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> hchanSize%maxAlign != <span class="hljs-number">0</span> || elem.align &gt; maxAlign &#123;<br>throw(<span class="hljs-string">&quot;makechan: bad alignment&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 计算缓冲区需要的总大小（缓冲区大小*元素大小），并判断是否超出最大可分配范围</span><br><span class="hljs-comment">// 如果是非缓冲通道或者是通道元素的size为0（比如struct&#123;&#125;），那么mem就是0</span><br>mem, overflow := math.MulUintptr(elem.size, <span class="hljs-type">uintptr</span>(size))<br><span class="hljs-keyword">if</span> overflow || mem &gt; maxAlloc-hchanSize || size &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;makechan: size out of range&quot;</span>))<br>&#125;<br><br><span class="hljs-comment">// Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.</span><br><span class="hljs-comment">// buf points into the same allocation, elemtype is persistent.</span><br><span class="hljs-comment">// SudoG&#x27;s are referenced from their owning thread so they can&#x27;t be collected.</span><br><span class="hljs-comment">// TODO(dvyukov,rlh): Rethink when collector can move allocated objects.</span><br><span class="hljs-keyword">var</span> c *hchan<br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> mem == <span class="hljs-number">0</span>:<br><span class="hljs-comment">// 缓冲区大小为0，或者channel中元素大小为0（struct&#123;&#125;&#123;&#125;）时，只需分配channel必需的空间即可;不分配缓冲区的内存</span><br><span class="hljs-comment">// Queue or element size is zero.</span><br>c = (*hchan)(mallocgc(hchanSize, <span class="hljs-literal">nil</span>, <span class="hljs-literal">true</span>))<br><span class="hljs-comment">// Race detector uses this location for synchronization.</span><br><span class="hljs-comment">// buf指针无实际意义</span><br>c.buf = c.raceaddr()<br><span class="hljs-keyword">case</span> elem.ptrdata == <span class="hljs-number">0</span>:<br><span class="hljs-comment">// channel中元素类型不是指针，分配一片连续内存空间，所需空间等于 缓冲区数组空间 + hchan必需的空间。</span><br><span class="hljs-comment">// Elements do not contain pointers.</span><br><span class="hljs-comment">// Allocate hchan and buf in one call.</span><br>c = (*hchan)(mallocgc(hchanSize+mem, <span class="hljs-literal">nil</span>, <span class="hljs-literal">true</span>))<br><span class="hljs-comment">// // buf指向了缓冲区内存的首地址</span><br>c.buf = add(unsafe.Pointer(c), hchanSize)<br><span class="hljs-keyword">default</span>:<br><span class="hljs-comment">// Elements contain pointers.</span><br><span class="hljs-comment">// 元素包含指针时 分别分配 chan 和 buf 的内存</span><br>c = <span class="hljs-built_in">new</span>(hchan)<br>c.buf = mallocgc(mem, elem, <span class="hljs-literal">true</span>)<br>&#125;<br><br><span class="hljs-comment">// 其他字段设置</span><br>c.elemsize = <span class="hljs-type">uint16</span>(elem.size)<br>c.elemtype = elem<br>c.dataqsiz = <span class="hljs-type">uint</span>(size)<br>lockInit(&amp;c.lock, lockRankHchan)<br><br><span class="hljs-keyword">if</span> debugChan &#123;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;makechan: chan=&quot;</span>, c, <span class="hljs-string">&quot;; elemsize=&quot;</span>, elem.size, <span class="hljs-string">&quot;; dataqsiz=&quot;</span>, size, <span class="hljs-string">&quot;\n&quot;</span>)<br>&#125;<br><span class="hljs-keyword">return</span> c<br>&#125;<br></code></pre></td></tr></table></figure><p>整体逻辑较为清晰：</p><ul><li>首先校验元素类型和缓冲区空间大小，然后创建hchan，分配所需空间。</li><li>这里有三种情况：<ul><li>当缓冲区大小为0，或者channel中元素大小为0时，只需分配channel必需的空间即可；</li><li>当channel元素类型不是指针时，则只需要为hchan和缓冲区分配一片连续内存空间，空间大小为缓冲区数组空间加上hchan必需的空间；</li><li>默认情况，缓冲区包含指针，则需要为hchan和缓冲区分别分配内存。</li></ul></li><li>最后更新hchan的其他字段，包括elemsize，elemtype，dataqsiz。</li></ul><h3 id="5-3-向Channel发送数据"><a href="#5-3-向Channel发送数据" class="headerlink" title="5.3 向Channel发送数据"></a>5.3 向Channel发送数据</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>ch &lt;- <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>通道写操作会调用chansend函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chansend</span><span class="hljs-params">(c *hchan, ep unsafe.Pointer, block <span class="hljs-type">bool</span>, callerpc <span class="hljs-type">uintptr</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-comment">// channel为空的场景下，如果是非阻塞，直接返回发送失败，如果是阻塞场景下，将当前协程挂起阻塞</span><br><span class="hljs-keyword">if</span> c == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> !block &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>gopark(<span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, waitReasonChanSendNilChan, traceEvGoStop, <span class="hljs-number">2</span>)<br>throw(<span class="hljs-string">&quot;unreachable&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">if</span> debugChan &#123;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;chansend: chan=&quot;</span>, c, <span class="hljs-string">&quot;\n&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">if</span> raceenabled &#123;<br>racereadpc(c.raceaddr(), callerpc, abi.FuncPCABIInternal(chansend))<br>&#125;<br><br><span class="hljs-comment">// Fast path: check for failed non-blocking operation without acquiring the lock.</span><br><span class="hljs-comment">// 对于非阻塞队列且channel未关闭、如果无缓冲区且没有等待的接收者或者换冲区已满都直接返回false</span><br><span class="hljs-keyword">if</span> !block &amp;&amp; c.closed == <span class="hljs-number">0</span> &amp;&amp; full(c) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// 一般情况下都是阻塞队列，主要看下面的逻辑</span><br><br><span class="hljs-keyword">var</span> t0 <span class="hljs-type">int64</span><br><span class="hljs-keyword">if</span> blockprofilerate &gt; <span class="hljs-number">0</span> &#123;<br>t0 = cputicks()<br>&#125;<br><span class="hljs-comment">// 加锁，保证协程并发安全</span><br>lock(&amp;c.lock)<br><span class="hljs-comment">// 如果channel已关闭，直接panic</span><br><span class="hljs-keyword">if</span> c.closed != <span class="hljs-number">0</span> &#123;<br>unlock(&amp;c.lock)<br><span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;send on closed channel&quot;</span>))<br>&#125;<br><br><span class="hljs-comment">// 首先判断是否有等待接收者</span><br><span class="hljs-keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// Found a waiting receiver. We pass the value we want to send</span><br><span class="hljs-comment">// directly to the receiver, bypassing the channel buffer (if any).</span><br><span class="hljs-comment">// 有等待接收者的时候分两种情况，无缓冲队列或者是缓冲队列为空</span><br><span class="hljs-comment">// 这两种情况都是直接唤醒等待的协程，直接将数据给等待者</span><br>send(c, sg, ep, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="hljs-number">3</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-comment">// 如果当前buf中的数量小于容量，说明还有空间，直接把数据写入buf，并更新sendx和qcount等字段</span><br><span class="hljs-keyword">if</span> c.qcount &lt; c.dataqsiz &#123;<br><span class="hljs-comment">// Space is available in the channel buffer. Enqueue the element to send.</span><br>qp := chanbuf(c, c.sendx)<br><span class="hljs-keyword">if</span> raceenabled &#123;<br>racenotify(c, c.sendx, <span class="hljs-literal">nil</span>)<br>&#125;<br>typedmemmove(c.elemtype, qp, ep)<br><span class="hljs-comment">// 索引更新及环形队列处理</span><br>c.sendx++<br><span class="hljs-keyword">if</span> c.sendx == c.dataqsiz &#123;<br>c.sendx = <span class="hljs-number">0</span><br>&#125;<br>c.qcount++<br>unlock(&amp;c.lock)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-keyword">if</span> !block &#123;<br>unlock(&amp;c.lock)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// Block on the channel. Some receiver will complete our operation for us.</span><br><span class="hljs-comment">// 如果队列已经满了，则需要构造一个sudog，将发送协程加入发送者队列</span><br>gp := getg()<br>mysg := acquireSudog()<br>mysg.releasetime = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> t0 != <span class="hljs-number">0</span> &#123;<br>mysg.releasetime = <span class="hljs-number">-1</span><br>&#125;<br><span class="hljs-comment">// No stack splits between assigning elem and enqueuing mysg</span><br><span class="hljs-comment">// on gp.waiting where copystack can find it.</span><br>mysg.elem = ep<br>mysg.waitlink = <span class="hljs-literal">nil</span><br>mysg.g = gp<br>mysg.isSelect = <span class="hljs-literal">false</span><br>mysg.c = c<br>gp.waiting = mysg<br>gp.param = <span class="hljs-literal">nil</span><br><span class="hljs-comment">// 当前 goroutine 进入发送等待队列</span><br>c.sendq.enqueue(mysg)<br><span class="hljs-comment">// 挂起协程</span><br>gp.parkingOnChan.Store(<span class="hljs-literal">true</span>)<br>gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanSend, traceEvGoBlockSend, <span class="hljs-number">2</span>)<br><span class="hljs-comment">// Ensure the value being sent is kept alive until the</span><br><span class="hljs-comment">// receiver copies it out. The sudog has a pointer to the</span><br><span class="hljs-comment">// stack object, but sudogs aren&#x27;t considered as roots of the</span><br><span class="hljs-comment">// stack tracer.</span><br>KeepAlive(ep)<br><br><span class="hljs-comment">// someone woke us up.</span><br><span class="hljs-comment">// 如果协程被唤醒了，说明数据会被读取走；后续执行清理工作并释放sudog结构体</span><br><span class="hljs-keyword">if</span> mysg != gp.waiting &#123;<br>throw(<span class="hljs-string">&quot;G waiting list is corrupted&quot;</span>)<br>&#125;<br>gp.waiting = <span class="hljs-literal">nil</span><br>gp.activeStackChans = <span class="hljs-literal">false</span><br>closed := !mysg.success<br>gp.param = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">if</span> mysg.releasetime &gt; <span class="hljs-number">0</span> &#123;<br>blockevent(mysg.releasetime-t0, <span class="hljs-number">2</span>)<br>&#125;<br>mysg.c = <span class="hljs-literal">nil</span><br>releaseSudog(mysg)<br><span class="hljs-keyword">if</span> closed &#123;<br><span class="hljs-keyword">if</span> c.closed == <span class="hljs-number">0</span> &#123;<br>throw(<span class="hljs-string">&quot;chansend: spurious wakeup&quot;</span>)<br>&#125;<br><span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;send on closed channel&quot;</span>))<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>主要流程分三种情况：</p><ul><li>存在等待接收的协程：说明无缓冲或者缓冲为空，直接把数据给接收者</li><li>没有等待的接收者且buf未满：把数据放入buf末尾</li><li>没有等待的接收者且buf满了：将发送者加入发送等待队列<br><img src="/img/golang-channels/7.png"></li></ul><h3 id="5-4-从Channel接收数据"><a href="#5-4-从Channel接收数据" class="headerlink" title="5.4 从Channel接收数据"></a>5.4 从Channel接收数据</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>value := &lt;- ch <span class="hljs-comment">// 一个接收值</span><br>value, ok := &lt;- ch <span class="hljs-comment">// 两个接收值</span><br></code></pre></td></tr></table></figure><ul><li>第3行中，第二个接收值“ok”表示value是否是有效数据，即value的值是否来自sender发送的数据。<br>📌 <blockquote><p>可以通过“ok”来判断chan是否关闭，即ok&#x3D;false，则chan关闭。但不能认为ok&#x3D;true，chan就未关闭，因为在某些chan已经关闭的情况下（如chan的buffer中有数据），“ok”依然是true。<br>  当ok&#x3D;true时，chan可能关闭或未关闭；当ok&#x3D;false时，chan一定是关闭了。</p></blockquote></li></ul><p>接收数据时，核心调用的是 chanrecv函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chanrecv</span><span class="hljs-params">(c *hchan, ep unsafe.Pointer, block <span class="hljs-type">bool</span>)</span></span> (selected, received <span class="hljs-type">bool</span>) &#123;<br><span class="hljs-comment">// ep：用来接收数据的地址。如果 ep 是 nil，说明忽略了接收值(-)。</span><br><span class="hljs-comment">// block表示通道是否是阻塞模式，我们创建的通道都是阻塞模式，下面代码不考虑非阻塞模式</span><br><span class="hljs-comment">// received表示接收到的是否是有效数据，即sender发送的数据。</span><br><span class="hljs-keyword">if</span> debugChan &#123;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;chanrecv: chan=&quot;</span>, c, <span class="hljs-string">&quot;\n&quot;</span>)<br>&#125;<br><span class="hljs-comment">// channel为空场景下，如果非阻塞队列直接返回false，如果阻塞队列，直接挂起等待</span><br><span class="hljs-keyword">if</span> c == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> !block &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>gopark(<span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="hljs-number">2</span>)<br>throw(<span class="hljs-string">&quot;unreachable&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// Fast path: check for failed non-blocking operation without acquiring the lock.</span><br><span class="hljs-comment">// 非阻塞模式下的快速退出场景，一般无需关注</span><br><span class="hljs-keyword">if</span> !block &amp;&amp; empty(c) &#123;<br><span class="hljs-keyword">if</span> atomic.Load(&amp;c.closed) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> empty(c) &#123;<br><span class="hljs-comment">// The channel is irreversibly closed and empty.</span><br><span class="hljs-keyword">if</span> raceenabled &#123;<br>raceacquire(c.raceaddr())<br>&#125;<br><span class="hljs-keyword">if</span> ep != <span class="hljs-literal">nil</span> &#123;<br>typedmemclr(c.elemtype, ep)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> t0 <span class="hljs-type">int64</span><br><span class="hljs-keyword">if</span> blockprofilerate &gt; <span class="hljs-number">0</span> &#123;<br>t0 = cputicks()<br>&#125;<br><br><span class="hljs-comment">// 加锁 保证协程并发安全性</span><br>lock(&amp;c.lock)<br><br><br><span class="hljs-keyword">if</span> c.closed != <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// 如果channel已经关闭且缓冲区无元素</span><br><span class="hljs-keyword">if</span> c.qcount == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> raceenabled &#123;<br>raceacquire(c.raceaddr())<br>&#125;<br>unlock(&amp;c.lock)<br><span class="hljs-comment">// 给ep一个零值</span><br><span class="hljs-keyword">if</span> ep != <span class="hljs-literal">nil</span> &#123;<br>typedmemclr(c.elemtype, ep)<br>&#125;<br><span class="hljs-comment">// 返回（true, false），即接收到值，但不是从channel中接收的有效值</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-comment">// The channel has been closed, but the channel&#x27;s buffer have data.</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// Just found waiting sender with not closed.</span><br><span class="hljs-comment">// 常规情况1: 有等待发送的队列</span><br>        <span class="hljs-comment">// 有等待发送的队列时，说明有两种情况：非缓冲队列或者缓冲已满；</span><br><span class="hljs-comment">// 对于非缓冲情况，直接从sender接收数据</span><br><span class="hljs-comment">// 对于缓冲已满情况，从buf队列头部接收数据，并将sender数据加入队列尾部</span><br><span class="hljs-keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// Found a waiting sender. If buffer is size 0, receive value</span><br><span class="hljs-comment">// directly from sender. Otherwise, receive from head of queue</span><br><span class="hljs-comment">// and add sender&#x27;s value to the tail of the queue (both map to</span><br><span class="hljs-comment">// the same buffer slot because the queue is full).</span><br>recv(c, sg, ep, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="hljs-number">3</span>)<br><span class="hljs-comment">// 接收成功</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 常规情况2: 无等待发送队列，且buf有值；</span><br><span class="hljs-comment">// 直接从recvx取数据即可，并更新recvx和qcount的值</span><br><span class="hljs-keyword">if</span> c.qcount &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// Receive directly from queue</span><br>qp := chanbuf(c, c.recvx)<br><span class="hljs-keyword">if</span> raceenabled &#123;<br>racenotify(c, c.recvx, <span class="hljs-literal">nil</span>)<br>&#125;<br><span class="hljs-keyword">if</span> ep != <span class="hljs-literal">nil</span> &#123;<br>typedmemmove(c.elemtype, ep, qp)<br>&#125;<br>typedmemclr(c.elemtype, qp)<br>c.recvx++<br><span class="hljs-keyword">if</span> c.recvx == c.dataqsiz &#123;<br>c.recvx = <span class="hljs-number">0</span><br>&#125;<br>c.qcount--<br>unlock(&amp;c.lock)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-comment">// 非阻塞模式，没有数据，直接返回</span><br><span class="hljs-keyword">if</span> !block &#123;<br>unlock(&amp;c.lock)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// 阻塞模式，没有数据，则挂起到接收队列中</span><br><span class="hljs-comment">// no sender available: block on this channel.</span><br>gp := getg()<br>mysg := acquireSudog()<br>mysg.releasetime = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> t0 != <span class="hljs-number">0</span> &#123;<br>mysg.releasetime = <span class="hljs-number">-1</span><br>&#125;<br><span class="hljs-comment">// No stack splits between assigning elem and enqueuing mysg</span><br><span class="hljs-comment">// on gp.waiting where copystack can find it.</span><br>mysg.elem = ep<br>mysg.waitlink = <span class="hljs-literal">nil</span><br>gp.waiting = mysg<br>mysg.g = gp<br>mysg.isSelect = <span class="hljs-literal">false</span><br>mysg.c = c<br>gp.param = <span class="hljs-literal">nil</span><br>    <span class="hljs-comment">// 加入到channel的等待接收队列recvq中</span><br>c.recvq.enqueue(mysg)<br><span class="hljs-comment">// stack shrinking.</span><br>gp.parkingOnChan.Store(<span class="hljs-literal">true</span>)<br>gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanReceive, traceEvGoBlockRecv, <span class="hljs-number">2</span>)<br><br><span class="hljs-comment">// someone woke us up</span><br><span class="hljs-comment">// 被唤醒之后执行清理工作并释放sudog结构体</span><br><span class="hljs-keyword">if</span> mysg != gp.waiting &#123;<br>throw(<span class="hljs-string">&quot;G waiting list is corrupted&quot;</span>)<br>&#125;<br>gp.waiting = <span class="hljs-literal">nil</span><br>gp.activeStackChans = <span class="hljs-literal">false</span><br><span class="hljs-keyword">if</span> mysg.releasetime &gt; <span class="hljs-number">0</span> &#123;<br>blockevent(mysg.releasetime-t0, <span class="hljs-number">2</span>)<br>&#125;<br>success := mysg.success<br>gp.param = <span class="hljs-literal">nil</span><br>mysg.c = <span class="hljs-literal">nil</span><br>releaseSudog(mysg)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, success<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，在整个读取数据的流程中，和发送数据的流程非常相似，主要分为3种情况</p><ul><li>存在等待发送的协程：这种场景说明无缓冲通道或者缓冲buf已满<ul><li>如果无缓冲区，那么直接从sender接收数据； </li><li>如果缓冲区已满，从buf队列的头部接收数据，并把sender的数据加到buf队列的尾部； </li><li>最后调用goready函数将等待发送数据的Goroutine的状态从_Gwaiting置为_Grunnable，等待下一次调度。</li></ul></li><li>没有等待发送的协程且buf存在数据，直接从buf中取数据。</li><li>没有等待发送的协程且无数据，接收者挂起加入接收者队列。<br><img src="/img/golang-channels/8.png"></li></ul><h3 id="5-5-关闭Channel"><a href="#5-5-关闭Channel" class="headerlink" title="5.5 关闭Channel"></a>5.5 关闭Channel</h3><p>收发完数据后，就是对channel的关闭操作，关闭操作主要执行以下逻辑：</p><ul><li>遍历recvq和sendq（实际只有recvq或者sendq），取出sudog中挂起的Goroutine加入到glist列表中，并清除sudog上的一些信息和状态。</li><li>遍历glist列表，为每个Goroutine调用goready函数，将所有Goroutine置为_Grunnable状态，等待调度。</li><li>当Goroutine被唤醒之后，会继续执行chansend和chanrecv函数中当前Goroutine被唤醒后的剩余逻辑。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">closechan</span><span class="hljs-params">(c *hchan)</span></span> &#123;<br><span class="hljs-comment">// 关闭 nil channel，panic</span><br><span class="hljs-keyword">if</span> c == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;close of nil channel&quot;</span>))<br>&#125;<br><br>lock(&amp;c.lock)<br><span class="hljs-keyword">if</span> c.closed != <span class="hljs-number">0</span> &#123;<br>unlock(&amp;c.lock)<br><span class="hljs-comment">// 关闭closed channel，panic</span><br><span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;close of closed channel&quot;</span>))<br>&#125;<br><br><span class="hljs-keyword">if</span> raceenabled &#123;<br>callerpc := getcallerpc()<br>racewritepc(c.raceaddr(), callerpc, abi.FuncPCABIInternal(closechan))<br>racerelease(c.raceaddr())<br>&#125;<br><span class="hljs-comment">// 设置为关闭状态</span><br>c.closed = <span class="hljs-number">1</span><br><br><span class="hljs-keyword">var</span> glist gList<br><br><span class="hljs-comment">// release all readers</span><br><span class="hljs-comment">// 遍历recvq，清除sudog的数据，取出其中处于_Gwaiting状态的Goroutine加入到glist中</span><br><span class="hljs-keyword">for</span> &#123;<br>sg := c.recvq.dequeue()<br><span class="hljs-keyword">if</span> sg == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> sg.elem != <span class="hljs-literal">nil</span> &#123;<br>typedmemclr(c.elemtype, sg.elem)<br>sg.elem = <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">if</span> sg.releasetime != <span class="hljs-number">0</span> &#123;<br>sg.releasetime = cputicks()<br>&#125;<br>gp := sg.g<br>gp.param = unsafe.Pointer(sg)<br>sg.success = <span class="hljs-literal">false</span><br><span class="hljs-keyword">if</span> raceenabled &#123;<br>raceacquireg(gp, c.raceaddr())<br>&#125;<br>glist.push(gp)<br>&#125;<br><br><span class="hljs-comment">// release all writers (they will panic)</span><br><span class="hljs-comment">// 遍历sendq，清除sudog的数据，取出其中处于_Gwaiting状态的Goroutine加入到glist中</span><br><span class="hljs-keyword">for</span> &#123;<br>sg := c.sendq.dequeue()<br><span class="hljs-keyword">if</span> sg == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>sg.elem = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">if</span> sg.releasetime != <span class="hljs-number">0</span> &#123;<br>sg.releasetime = cputicks()<br>&#125;<br>gp := sg.g<br>gp.param = unsafe.Pointer(sg)<br>sg.success = <span class="hljs-literal">false</span><br><span class="hljs-keyword">if</span> raceenabled &#123;<br>raceacquireg(gp, c.raceaddr())<br>&#125;<br>glist.push(gp)<br>&#125;<br>unlock(&amp;c.lock)<br><br><span class="hljs-comment">// Ready all Gs now that we&#x27;ve dropped the channel lock.</span><br><span class="hljs-comment">// 将glist中所有Goroutine的状态置为_Grunnable，等待调度器进行调度</span><br><span class="hljs-keyword">for</span> !glist.empty() &#123;<br>gp := glist.pop()<br>gp.schedlink = <span class="hljs-number">0</span><br>goready(gp, <span class="hljs-number">3</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://iswxw.blog.csdn.net/article/details/130785190">Go 并发之channel</a></p><p><a href="https://mp.weixin.qq.com/s/rFyMNeZF_cwKkBBJhHlEFQ">go channel详解</a></p><p><a href="https://mp.weixin.qq.com/s/XEdrrpIkdseFP3ZIdfOgVw">深入理解 channel</a></p><p><a href="https://www.ardanlabs.com/blog/2014/02/the-nature-of-channels-in-go.html">The Nature Of Channels In Go</a></p><p><a href="https://mp.weixin.qq.com/s/V7B9q4lZ6K3RjrP8Xd-cXw">一文带你揭秘Go语言之通道channel</a></p><p><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel/">Channel</a></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>Channel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang Context 解析</title>
    <link href="/2024/08/31/Golang-Context%E8%A7%A3%E6%9E%90/"/>
    <url>/2024/08/31/Golang-Context%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>Context 是 Go 语言中用于处理并发操作的一个重要概念。包含 goroutine 的运行状态、环境、现场等信息。Context 主要用来在 goroutine 之间传递上下文信息，包括：取消信号、超时时间、截止时间、Key-Value等。</p><span id="more"></span>  <h2 id="1-Context-介绍"><a href="#1-Context-介绍" class="headerlink" title="1. Context 介绍"></a>1. Context 介绍</h2><p>Context 是 Go 语言中用于处理并发操作的一个重要概念。Context译作“上下文”，准确说它是 goroutine 的上下文，包含 goroutine 的运行状态、环境、现场等信息。Context 主要用来在 goroutine 之间传递上下文信息，包括：取消信号、超时时间、截止时间、Key-Value等。</p><p>接口定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">interface</span> &#123;<br>    Deadline() (deadline time.Time, ok <span class="hljs-type">bool</span>) <span class="hljs-comment">//返回 context 的过期时间；</span><br>    Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125; <span class="hljs-comment">//返回 context 中的 channel；</span><br>    Err() <span class="hljs-type">error</span> <span class="hljs-comment">//返回错误；</span><br>    Value(key <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">interface</span>&#123;&#125; <span class="hljs-comment">//返回 context 中的对应 key 的值.</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>Deadline()</code>：该方法返回ctx的超时时间，以及是否设置超时时间的标识；如果没有设置超时时间，则ok&#x3D;false，deadline是一个初始的time.Time值。</li><li><code>Done()</code>：该方法返回一个只读的channel，当context被主动取消或者超时自动取消时，这个channel会被关闭；关闭的channel是可读的，协程可以正常收到关闭信号；如果一个ctx没有设置超时时间，调用该方法会返回nil；经常在select-case语句中使用，判断ctx是否关闭</li><li><code>Err()</code>：该方法返回ctx关闭的原因，如果ctx还没有关闭，就返回nil，如果被关闭了，返回的err也只有两种<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> Canceled = errors.New(<span class="hljs-string">&quot;context canceled&quot;</span>)        <span class="hljs-comment">// 正常取消</span><br><br><span class="hljs-keyword">var</span> DeadlineExceeded <span class="hljs-type">error</span> = deadlineExceededError&#123;&#125; <span class="hljs-comment">// 超时取消</span><br></code></pre></td></tr></table></figure></li><li><code>Value()</code>：golang中有一种在协程间传递信息的ctx，使用该方法可以根据key查询map中的value</li></ul><h2 id="2-Context-派生"><a href="#2-Context-派生" class="headerlink" title="2. Context 派生"></a>2. Context 派生</h2><p>Context在设计上实际只定义了接口，凡是实现改接口的结构体都可以称为Context，官方的包中实现了以下几类结构体。 </p><p><img src="/img/Golang-Context%E8%A7%A3%E6%9E%90/1.png">    </p><ul><li><code>emptyCtx</code>：空结构体，使用Background()函数和TODO()函数创建</li><li><code>valueCtx</code>：值传递的context，使用WithValue()函数创建</li><li><code>cancelCtx</code>：带有取消函数的context，使用WithCancel()函数创建</li><li><code>timerCtx</code>：带有超时时间的context，使用WithDeadline()和WithTimeout()函数创建</li></ul><h2 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3. 使用场景"></a>3. 使用场景</h2><p>Context在日常使用中，一般多用于超时控制、信号传递、共享变量等场景，下面分别简单介绍一下</p><h3 id="3-1-取消信号传递"><a href="#3-1-取消信号传递" class="headerlink" title="3.1 取消信号传递"></a>3.1 取消信号传递</h3><ul><li>在主协程中主动取消ctx，子协程收到取消请求后关闭操作<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>fmt.Printf(<span class="hljs-string">&quot;Worker received cancellation signal: %v\n&quot;</span>, ctx.Err())<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br>time.Sleep(<span class="hljs-number">500</span> * time.Millisecond)<br>fmt.Println(<span class="hljs-string">&quot;Working...&quot;</span>)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>parentCtx, cancel := context.WithCancel(context.Background())<br><span class="hljs-keyword">go</span> worker(parentCtx)<br><br>time.Sleep(<span class="hljs-number">1</span> * time.Second) <span class="hljs-comment">// 模拟主程序执行</span><br><br>cancel() <span class="hljs-comment">// 取消worker的ctx</span><br><br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>&#125;<br><span class="hljs-comment">// Working...</span><br><span class="hljs-comment">// Working...</span><br><span class="hljs-comment">// Worker received cancellation signal: context canceled</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="3-2-超时控制"><a href="#3-2-超时控制" class="headerlink" title="3.2 超时控制"></a>3.2 超时控制</h3><ul><li>使用带有超时时间的ctx，时间到后，函数自动中断处理<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">operation</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-time.After(<span class="hljs-number">3</span> * time.Second): <span class="hljs-comment">// Simulate some long operation</span><br>fmt.Println(<span class="hljs-string">&quot;Operation completed.&quot;</span>)<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>fmt.Println(<span class="hljs-string">&quot;Operation canceled due to timeout.&quot;</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>timeoutCtx, cancel := context.WithTimeout(context.Background(), <span class="hljs-number">2</span>*time.Second)<br><span class="hljs-keyword">defer</span> cancel()<br><br>operation(timeoutCtx)<br>&#125;<br><span class="hljs-comment">// Operation canceled due to timeout.</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="3-3-截止时间"><a href="#3-3-截止时间" class="headerlink" title="3.3 截止时间"></a>3.3 截止时间</h3><ul><li>ctx带有截止时间，在deadline之前可以正常工作，deadline后会报错<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">operation</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;<br>deadline, ok := ctx.Deadline()<br><span class="hljs-keyword">if</span> ok &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Operation deadline: %s\n&quot;</span>, deadline)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;No deadline for the operation.&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// Simulate some operation</span><br>time.Sleep(<span class="hljs-number">3</span> * time.Second)<br><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>fmt.Println(<span class="hljs-string">&quot;Operation canceled due to context deadline.&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;Operation completed within the deadline.&quot;</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>deadline := time.Now().Add(<span class="hljs-number">2</span> * time.Second)<br>deadlineCtx, cancel := context.WithDeadline(context.Background(), deadline)<br><span class="hljs-keyword">defer</span> cancel()<br><br>operation(deadlineCtx)<br>&#125;<br><span class="hljs-comment">// Operation deadline: 2024-08-31 12:21:15.279442 +0800 CST m=+2.000158542</span><br><span class="hljs-comment">// Operation canceled due to context deadline.</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="3-4-值传递"><a href="#3-4-值传递" class="headerlink" title="3.4 值传递"></a>3.4 值传递</h3><ul><li>通过ctx value传递userId<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">processRequest</span><span class="hljs-params">(ctx context.Context, requestID <span class="hljs-type">int</span>)</span></span> &#123;<br>userID, ok := ctx.Value(<span class="hljs-string">&quot;id&quot;</span>).(<span class="hljs-type">int</span>)<br><span class="hljs-keyword">if</span> !ok &#123;<br>fmt.Println(<span class="hljs-string">&quot;failed to get id from context.&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;processing request %d for user %d\n&quot;</span>, requestID, userID)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>parentCtx := context.WithValue(context.Background(), <span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-number">123</span>)<br><br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(requestID <span class="hljs-type">int</span>)</span></span> &#123;<br>childCtx := context.WithValue(parentCtx, <span class="hljs-string">&quot;requestID&quot;</span>, requestID)<br>processRequest(childCtx, requestID)<br>wg.Done()<br>&#125;(i)<br>&#125;<br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="4-源码分析"><a href="#4-源码分析" class="headerlink" title="4. 源码分析"></a>4. 源码分析</h2><h3 id="4-1-emptyCtx"><a href="#4-1-emptyCtx" class="headerlink" title="4.1 emptyCtx"></a>4.1 emptyCtx</h3><p>context包中定义了一个空的context， 名为emptyCtx，用于context的根节点，空的context只是简单的实现了Context，本身不包含任何值，仅用于其他context的父节点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 空的ctx本质上一个整型，它不会被取消、没有值，也没有过期时间</span><br><span class="hljs-keyword">type</span> emptyCtx <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*emptyCtx)</span></span> Deadline() (deadline time.Time, ok <span class="hljs-type">bool</span>) &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*emptyCtx)</span></span> Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125; &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*emptyCtx)</span></span> Err() <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*emptyCtx)</span></span> Value(key any) any &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>emptyCtx通过下面两个导出的函数（首字母大写）对外公开：我们所常用的 context.Background()  和 context.TODO() 方法。本质上二者并无差别</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// context.Background()函数返回一个空对象，被视为所有上下文树的根节点，不需要传递值或取消信号。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Background</span><span class="hljs-params">()</span></span> Context &#123;<span class="hljs-keyword">return</span> background&#125;<br><span class="hljs-comment">//context.TODO()函数返回一个空对象，用于该部分代码还未确定具体需要哪种上下文对象，</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TODO</span><span class="hljs-params">()</span></span> Context &#123;<span class="hljs-keyword">return</span> todo&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-valueCtx"><a href="#4-2-valueCtx" class="headerlink" title="4.2 valueCtx"></a>4.2 valueCtx</h3><p>valueCtx在空ctx的基础上，增加了key-val键值对，用于保存一些数据供上下文使用。在实际使用过程中通过WithValue()函数构造。</p><ul><li><p><code>valueCtx</code> 结构体定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 通过组合Context的方式，携带一个key-val对</span><br><span class="hljs-keyword">type</span> valueCtx <span class="hljs-keyword">struct</span> &#123;<br>Context<br>key, val any<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>WithValue()</code> 源码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithValue</span><span class="hljs-params">(parent Context, key, val any)</span></span> Context &#123;<br><span class="hljs-keyword">if</span> parent == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;cannot create context from nil parent&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> key == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;nil key&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> !reflectlite.TypeOf(key).Comparable() &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;key is not comparable&quot;</span>)<br>&#125;<br><span class="hljs-keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过以上代码可以看出，valueCtx的每次构建，都是在上一个ctx的基础上生成一个新的ctx，每一个valueCtx只有一个键值对，多个键值对构成一个串型的数据结构。<br><img src="/img/Golang-Context%E8%A7%A3%E6%9E%90/2.png">   </p></li><li><p><code>valueCtx.Value()</code>函数<br>Value()函数从当前的ctx开始找key的值，如果找不到，继续找父ctx，直至找到emptyCtx为止</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *valueCtx)</span></span> Value(key any) any &#123;<br><span class="hljs-keyword">if</span> c.key == key &#123;<br><span class="hljs-keyword">return</span> c.val<br>&#125;<br><span class="hljs-keyword">return</span> value(c.Context, key)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">value</span><span class="hljs-params">(c Context, key any)</span></span> any &#123;<br><span class="hljs-comment">// 从底层循环往父层寻找指定key的值</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">switch</span> ctx := c.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> *valueCtx:<br><span class="hljs-keyword">if</span> key == ctx.key &#123;<br><span class="hljs-keyword">return</span> ctx.val<br>&#125;<br>c = ctx.Context<br><span class="hljs-comment">// cancelCtxKey 是一个特殊的key，如果属于cancelCtx或者timerCtx且key为特殊key，则返回这个cancelCtx</span><br><span class="hljs-keyword">case</span> *cancelCtx:<br><span class="hljs-keyword">if</span> key == &amp;cancelCtxKey &#123;<br><span class="hljs-keyword">return</span> c<br>&#125;<br>c = ctx.Context<br><span class="hljs-keyword">case</span> *timerCtx:<br><span class="hljs-keyword">if</span> key == &amp;cancelCtxKey &#123;<br><span class="hljs-keyword">return</span> ctx.cancelCtx<br>&#125;<br>c = ctx.Context<br><span class="hljs-keyword">case</span> *emptyCtx:<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> c.Value(key)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>特点</p><ul><li>一个 valueCtx 只能存一个 kv 对，n 个 kv 对会嵌套 n 个 valueCtx，造成空间浪费，不适合大量存储；</li><li>基于 k 寻找 v 的过程是线性的，时间复杂度 O(N)；</li><li>不支持基于 k 的去重，相同 k 可能重复存在，并基于起点的不同，返回不同的 v.</li><li>valueCtx结构对于Context接口只重写了Value方法，其他三个方法直接调用嵌入的Context。</li></ul></li></ul><h3 id="4-3-cancelCtx"><a href="#4-3-cancelCtx" class="headerlink" title="4.3 cancelCtx"></a>4.3 cancelCtx</h3><p>context包中第三个比较重要的ctx是cancelCtx，顾名思义是可以取消的context，该context在构建时返回一个取消函数，可以供主动取消。</p><ul><li><p><code>cancelCtx</code>结构定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> cancelCtx <span class="hljs-keyword">struct</span> &#123;<br>Context                        <span class="hljs-comment">// 嵌入的Context</span><br><br>mu       sync.Mutex            <span class="hljs-comment">// 互斥锁，保护以下字段</span><br>done     atomic.Value          <span class="hljs-comment">// 原子通道，惰性创建,第一次被cancel调用关闭</span><br>children <span class="hljs-keyword">map</span>[canceler]<span class="hljs-keyword">struct</span>&#123;&#125; <span class="hljs-comment">// 存储子树中第一个可以被cancel的ctx</span><br>err      <span class="hljs-type">error</span>                 <span class="hljs-comment">// 存储error信息</span><br>cause    <span class="hljs-type">error</span>                 <span class="hljs-comment">// 存储带有原因的error信息</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>cancelCtx</code> 主要方法<br>  cancelCtx作为Context接口的实现，重写了Done、Err和Value方法，分别简单介绍如下</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Done 方法返回一个通道，使用了惰性加载的机制，只有第一次调用Done方法时才会被创建</span><br><span class="hljs-comment">// 将通道放到atomic.Value中 保证通道操作的原子性</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cancelCtx)</span></span> Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125; &#123;<br>d := c.done.Load()<br><span class="hljs-keyword">if</span> d != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> d.(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>&#125;<br><span class="hljs-comment">// 加锁的方式做二次检查，避免多并发场景下被重复创建</span><br>c.mu.Lock()<br><span class="hljs-keyword">defer</span> c.mu.Unlock()<br>d = c.done.Load()<br><span class="hljs-keyword">if</span> d == <span class="hljs-literal">nil</span> &#123;<br>d = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>c.done.Store(d)<br>&#125;<br><span class="hljs-keyword">return</span> d.(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>&#125;<br><br><span class="hljs-comment">// Value方法复用valueCtx的递归逻辑，只是有一种特殊的处理情况</span><br><span class="hljs-comment">// 当key是cancelCtxKey的时候，返回的是cancelCtx本身</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cancelCtx)</span></span> Value(key any) any &#123;<br><span class="hljs-keyword">if</span> key == &amp;cancelCtxKey &#123;<br><span class="hljs-keyword">return</span> c<br>&#125;<br><span class="hljs-keyword">return</span> value(c.Context, key)<br>&#125;<br><br><span class="hljs-comment">// Err 返回结构体err</span><br><span class="hljs-comment">// cancelCtx.err 默认是nil，在被cancel的时候指定一个error变量：“context canceled”</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cancelCtx)</span></span> Err() <span class="hljs-type">error</span> &#123;<br>c.mu.Lock()<br>err := c.err<br>c.mu.Unlock()<br><span class="hljs-keyword">return</span> err<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>WithCancel()</code> 构造方法<br>WithCancel是context官方包对外提供的函数之一，函数接受一个父上下文对象parent 作为参数，返回一个新的上下文cancelCtx对象ctx 及其对应的取消函数cancel 。当调用取消函数时，该ctx对象及其所有后代ctx对象均会被取消。核心代码逻辑介绍如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithCancel</span><span class="hljs-params">(parent Context)</span></span> (ctx Context, cancel CancelFunc) &#123;<br>c := withCancel(parent)<br><span class="hljs-comment">// 将构造的cancelCtx返回，同时返回终止该cancelCtx的闭包函数cancel；第一个参数是 true，也就是说取消的时候，需要将自己从父节点里删除。</span><br><span class="hljs-keyword">return</span> c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; c.cancel(<span class="hljs-literal">true</span>, Canceled, <span class="hljs-literal">nil</span>) &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">withCancel</span><span class="hljs-params">(parent Context)</span></span> *cancelCtx &#123;<br><span class="hljs-comment">// 如果父ctx为空，则无法构建</span><br><span class="hljs-keyword">if</span> parent == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;cannot create context from nil parent&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 构建一个新的cancelCtx</span><br>c := newCancelCtx(parent)<br><span class="hljs-comment">// 核心逻辑，构建cancel传播链</span><br>propagateCancel(parent, c)<br><span class="hljs-keyword">return</span> c<br>&#125;<br><br></code></pre></td></tr></table></figure><p>由于cancelCtx的对象在取消时，要同步取消其后代Ctx对象，因此在cancelCtx的构建时，要进行cancel信息的控制链传递，建立父子关系，将本次新建的cancelCtx放在链路中上一个cancelCtx的children map中。如果一个cancelCtx对象的后代不是cancelCtx对象，那这个后代的done channel本身就是cancelCtx的done channel，无需额外关联。因此在控制链的传递中，只需关联cancelCtx的父子关系即可。</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// parent为父ctx，child为本次创建的cancelCtx</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">propagateCancel</span><span class="hljs-params">(parent Context, child canceler)</span></span> &#123;<br>done := parent.Done()<br><span class="hljs-comment">// 如果父ctx不会被取消，直接返回即可</span><br><span class="hljs-keyword">if</span> done == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <br>&#125;<br><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-done:<br><span class="hljs-comment">// 如果父ctx已被取消则直接中止本次构建的cancelCtx，并用父ctx的取消原因作为子ctx的取消原因</span><br>child.cancel(<span class="hljs-literal">false</span>, parent.Err(), Cause(parent))<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br>&#125;<br><br><span class="hljs-comment">// 寻找parent ctx的第一个cancelCtx祖先(这个可以是parent自己,由cancelCtx.Value函数的实现决定)，本质上也就是找child ctx的第一个cancelCtx的祖先</span><br><span class="hljs-keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;<br>p.mu.Lock()<br><span class="hljs-keyword">if</span> p.err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 如果父ctx已被取消则直接中止本次构建的cancelCtx</span><br>child.cancel(<span class="hljs-literal">false</span>, p.err, p.cause)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 将本次新构建的child ctx加入到最近的cancelCtx祖先的children中</span><br><span class="hljs-keyword">if</span> p.children == <span class="hljs-literal">nil</span> &#123;<br>p.children = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[canceler]<span class="hljs-keyword">struct</span>&#123;&#125;)<br>&#125;<br>p.children[child] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;<br>p.mu.Unlock()<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 如果parent不是cancelCtx，但是又存在cancel的能力，则启动一个协程监控parent的状态，如果parent终止，也及时终止child ctx，并传递parent的error</span><br>goroutines.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-parent.Done():<br>child.cancel(<span class="hljs-literal">false</span>, parent.Err(), Cause(parent))<br><span class="hljs-keyword">case</span> &lt;-child.Done():<br>&#125;<br>&#125;()<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// parentCancelCtx 返回输入parent的第个cancelCtx祖先，可能是parent自己</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parentCancelCtx</span><span class="hljs-params">(parent Context)</span></span> (*cancelCtx, <span class="hljs-type">bool</span>) &#123;<br><span class="hljs-comment">// parent.Done() 返回控制链中第一个实现非空Done()方法的Context</span><br><span class="hljs-comment">// 在valueCtx、cancelCtx、timerCtx三者中，只有cancleCtx实现了非空的Done方法，因此parent.Done正常情况下会返回第一个祖先cancelCtx的done channel。但如果Context树中有第三方实现的Context接口实例时，parent.Done可能返回其他channel</span><br>done := parent.Done()<br><span class="hljs-keyword">if</span> done == closedchan || done == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// 通过cancelCtxKey找到第一个祖先cancelCtx</span><br>p, ok := parent.Value(&amp;cancelCtxKey).(*cancelCtx)<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-comment">// 如果p.done不等于done，说明控制链中碰到的第一个实现非空Done()的Context是第三方Context，不是cancelCtx</span><br>pdone, _ := p.done.Load().(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br><span class="hljs-keyword">if</span> pdone != done &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">return</span> p, <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/Golang-Context%E8%A7%A3%E6%9E%90/3.png"><br>如上图，由C3生成C4时，C3的parentCancelCtx是C1，C3调用Done()方法返回的也是C1的 done channel，因此将C4放入C1的children中</p><ul><li><code>cancelCtx.cancel()</code> 方法<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cancelCtx)</span></span> cancel(removeFromParent <span class="hljs-type">bool</span>, err, cause <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;context: internal error: missing cancel error&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> cause == <span class="hljs-literal">nil</span> &#123;<br>cause = err<br>&#125;<br>c.mu.Lock()<br><span class="hljs-comment">// 如果已经被取消，直接返回</span><br><span class="hljs-keyword">if</span> c.err != <span class="hljs-literal">nil</span> &#123;<br>c.mu.Unlock()<br><span class="hljs-keyword">return</span> <br>&#125;<br><br><span class="hljs-comment">// 记下错误信息，并关闭channel</span><br>c.err = err<br>c.cause = cause<br>d, _ := c.done.Load().(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br><span class="hljs-keyword">if</span> d == <span class="hljs-literal">nil</span> &#123;<br>c.done.Store(closedchan)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">close</span>(d)<br>&#125;<br><span class="hljs-comment">// 级联取消child cancelCtx</span><br><span class="hljs-keyword">for</span> child := <span class="hljs-keyword">range</span> c.children &#123;<br>child.cancel(<span class="hljs-literal">false</span>, err, cause)<br>&#125;<br>c.children = <span class="hljs-literal">nil</span><br>c.mu.Unlock()<br><br><span class="hljs-comment">// 将当前ctx从ctx的父ctx中移除</span><br><span class="hljs-keyword">if</span> removeFromParent &#123;<br>removeChild(c.Context, c)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><code>WithCacelCause()</code> 支持传递取消原因的cancelCtx<br>早期的cancelCtx在cancel时，能写入的err信息及其有限，只有超时取消和外部取消，Go  1.20版本新增一个可以设置取消原因的方法，他在调用cancel的时候，可以传递一个error参数。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithCancelCause</span><span class="hljs-params">(parent Context)</span></span> (ctx Context, cancel CancelCauseFunc) &#123;<br>c := withCancel(parent)<br><span class="hljs-keyword">return</span> c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(cause <span class="hljs-type">error</span>)</span></span> &#123; c.cancel(<span class="hljs-literal">true</span>, Canceled, cause) &#125;<br>&#125;<br><br>ctx, cancelFunc := context.WithCancelCause(parentCtx)<br><span class="hljs-keyword">defer</span> cancelFunc(errors.New(<span class="hljs-string">&quot;原因&quot;</span>))<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-4-timerCtx"><a href="#4-4-timerCtx" class="headerlink" title="4.4 timerCtx"></a>4.4 timerCtx</h3><p>timerCtx在cancelCtx的基础上进行了一次封装，除了继承cancelCtx的能力外，新增了一个time.Timer的计时器用于定时终止context，另外新增了一个deadline字段用于timerCtx的过期时间。</p><ul><li><code>timerCtx</code> 结构体<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> timerCtx <span class="hljs-keyword">struct</span> &#123;<br>*cancelCtx<br>timer *time.Timer <span class="hljs-comment">// Under cancelCtx.mu.</span><br><br>deadline time.Time<br>&#125;<br><br><span class="hljs-comment">// 重写Context接口的Deadline()方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *timerCtx)</span></span> Deadline() (deadline time.Time, ok <span class="hljs-type">bool</span>) &#123;<br><span class="hljs-keyword">return</span> c.deadline, <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><code>WithDeadline()</code> 构造方法<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithDeadline</span><span class="hljs-params">(parent Context, d time.Time)</span></span> (Context, CancelFunc) &#123;<br><span class="hljs-comment">// 校验parent ctx是否为空</span><br><span class="hljs-keyword">if</span> parent == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;cannot create context from nil parent&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 校验parent的过期时间是否比自己早，如果比自己早，直接构造一个基于parent的cancelCtx即可</span><br><span class="hljs-keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;<br><span class="hljs-comment">// The current deadline is already sooner than the new one.</span><br><span class="hljs-keyword">return</span> WithCancel(parent)<br>&#125;<br><span class="hljs-comment">// 构造新的timerCtx</span><br>c := &amp;timerCtx&#123;<br>cancelCtx: newCancelCtx(parent),<br>deadline:  d,<br>&#125;<br><span class="hljs-comment">// ctx控制链的取消关系同步，方式与cancelCtx一样</span><br>propagateCancel(parent, c)<br><span class="hljs-comment">// 判断过期时间是否已到，若是，直接 cancel timerCtx，并返回 DeadlineExceeded 的错误；</span><br>dur := time.Until(d)<br><span class="hljs-keyword">if</span> dur &lt;= <span class="hljs-number">0</span> &#123;<br>c.cancel(<span class="hljs-literal">true</span>, DeadlineExceeded, <span class="hljs-literal">nil</span>) <span class="hljs-comment">// deadline has already passed</span><br><span class="hljs-keyword">return</span> c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; c.cancel(<span class="hljs-literal">false</span>, Canceled, <span class="hljs-literal">nil</span>) &#125;<br>&#125;<br><span class="hljs-comment">// 启动定时器，时间到了后取消该ctx</span><br>c.mu.Lock()<br><span class="hljs-keyword">defer</span> c.mu.Unlock()<br><span class="hljs-keyword">if</span> c.err == <span class="hljs-literal">nil</span> &#123;<br>c.timer = time.AfterFunc(dur, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>c.cancel(<span class="hljs-literal">true</span>, DeadlineExceeded, <span class="hljs-literal">nil</span>)<br>&#125;)<br>&#125;<br><span class="hljs-keyword">return</span> c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; c.cancel(<span class="hljs-literal">true</span>, Canceled, <span class="hljs-literal">nil</span>) &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><code>WithTimeout()</code> 构造方法<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// WithTimeout 直接复用WithDeadline方法，在当前时刻加上时间段就是最后的超时时间</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithTimeout</span><span class="hljs-params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc) &#123;<br><span class="hljs-keyword">return</span> WithDeadline(parent, time.Now().Add(timeout))<br>&#125;<br></code></pre></td></tr></table></figure></li><li><code>timerCtx.cancel()</code> 方法<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *timerCtx)</span></span> cancel(removeFromParent <span class="hljs-type">bool</span>, err, cause <span class="hljs-type">error</span>) &#123;<br><span class="hljs-comment">// 直接复用cancelCtx的取消能力</span><br>c.cancelCtx.cancel(<span class="hljs-literal">false</span>, err, cause)<br><span class="hljs-comment">// 从parent ctx中移除父子关系</span><br><span class="hljs-keyword">if</span> removeFromParent &#123;<br><span class="hljs-comment">// Remove this timerCtx from its parent cancelCtx&#x27;s children.</span><br>removeChild(c.cancelCtx.Context, c)<br>&#125;<br><span class="hljs-comment">// 停止计时器</span><br>c.mu.Lock()<br><span class="hljs-keyword">if</span> c.timer != <span class="hljs-literal">nil</span> &#123;<br>c.timer.Stop()<br>c.timer = <span class="hljs-literal">nil</span><br>&#125;<br>c.mu.Unlock()<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5. 注意事项"></a>5. 注意事项</h2><ul><li>不要在结构类型中加入 Context 参数，而是将它显式地传递给需要它的每个函数，并且它应该是第一个参数，通常命名为 ctx:</li><li>Context 是线程安全的，可以放心地在多个 goroutine 中使用。</li><li>当你把 Context 传递给多个 goroutine 使用时，只要执行一次 cancel 操作，所有的 goroutine 就可以收到 取消的信号</li><li>不要把原本可以由函数参数来传递的变量，交给 Context 的 Value 来传递。<ul><li>ctx一般只存储请求维度的数据，比如用户信息、logId等，只保留告知类型的数据，而不保留控制性质的数据，即不存储业务逻辑上的控制参数数据。</li></ul></li><li>当一个函数需要接收一个 Context 时，但是此时你还不知道要传递什么 Context 时，可以先用 context.TODO 来代替，而不要选择传递一个 nil。</li><li>当一个 Context 被 cancel 时，继承自该 Context 的所有 子 Context 都会被 cancel。</li></ul><h2 id="6-参考资料"><a href="#6-参考资料" class="headerlink" title="6. 参考资料"></a>6. 参考资料</h2><p><a href="https://juejin.cn/post/7265880174381727759">Golang context实现原理与源码分析</a></p><p><a href="https://blog.51cto.com/u_15533611/5202001">Golang 笔记</a></p><p><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/">Go语言并发编程-上下文Context</a> </p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>Context</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BigCache解析</title>
    <link href="/2024/08/10/BigCache%E8%A7%A3%E6%9E%90/"/>
    <url>/2024/08/10/BigCache%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>BigCache是一个快速，支持并发访问，自淘汰的内存型缓存，可以在存储大量元素的基础上依然保持高性能。BigCache将元素保存在堆上的同时避免了GC的开销。</p><span id="more"></span>  <h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>缓存是系统提升并发能力、降低时延的利器，根据存储介质和使用场景，我们分为本地缓存与分布式缓存两种：</p><ul><li>本地缓存：一般在进程内，最简单的sync.Map就可以是一个并发安全的本地缓存。常见的有LocalCache、BigCache等。</li><li>分布式缓存：一般会用到Redis&#x2F;MemCached等分布式内存数据库实现，想比如本地缓存，分布式数据库增加了网络开销</li></ul><p>BigCache是一个快速，支持并发访问，自淘汰的内存型缓存，可以在存储大量元素的基础上依然保持高性能。BigCache将元素保存在堆上的同时避免了GC的开销。</p><p>源码地址：<a href="https://github.com/allegro/bigcache">https://github.com/allegro/bigcache</a><br>本文示例代码取自版本 v1.2.1  </p><h2 id="2-设计思想"><a href="#2-设计思想" class="headerlink" title="2. 设计思想"></a>2. 设计思想</h2><h3 id="2-1-整体设计"><a href="#2-1-整体设计" class="headerlink" title="2.1 整体设计"></a>2.1 整体设计</h3><ul><li>多： 缓存的元素数量非常大，可以达到百万级或千万级。</li><li>快： 对延迟有非常高的要求，平均延迟要求在5毫秒以内。支持10k rps级别的访问速度。</li><li>稳： 99.9分位延迟应在10毫秒左右，99.999分位延迟应在400毫秒左右。</li></ul><p>目前有许多开源的cache库，大部分都是基于map实现的，例如go-cache,ttl-cache等。bigcache明确指出，当数据量巨大时，直接基于map实现的cache库将出现严重的性能问题，这也是他们设计了一个全新的cache库的原因。</p><ul><li>核心设计思想<ul><li>数据分片存储，以降低锁冲突并提升并发量。</li><li>避免在map中存储指针，从而避免在GC时对map进行遍历扫描。</li><li>采用FIFO式的Ring Buffer设计，简化整体内存设计逻辑。</li></ul></li></ul><p><img src="/img/BigCache%E8%A7%A3%E6%9E%90/1.png"></p><h3 id="2-2-数据分片-Shard"><a href="#2-2-数据分片-Shard" class="headerlink" title="2.2 数据分片 Shard"></a>2.2 数据分片 Shard</h3><p>使用map做缓存时，实现并发安全的方式就是加一把锁。但是如果数据过多时，并发请求会导致较多的锁冲突，为了解决这种问题，BigCache采用了分片的方式降低锁粒度。在声明一个BigCache时，表面上看是一个结构体，实际上是一个数组，底层分成了N个互不关联的部分。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> BigCache <span class="hljs-keyword">struct</span> &#123;<br>shards       []*cacheShard<br>lifeWindow   <span class="hljs-type">uint64</span><br>clock        clock<br>hash         Hasher<br>config       Config<br>shardMask    <span class="hljs-type">uint64</span><br>maxShardSize <span class="hljs-type">uint32</span><br><span class="hljs-built_in">close</span>        <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在Set或者Get数据时，先对key计算hash值，根据hash值取余得到目标shard，之后所有的读写操作都是在各自的shard上进行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *BigCache)</span></span> Set(key <span class="hljs-type">string</span>, entry []<span class="hljs-type">byte</span>) <span class="hljs-type">error</span> &#123;<br>hashedKey := c.hash.Sum64(key)<br>shard := c.getShard(hashedKey)<br><span class="hljs-keyword">return</span> shard.set(key, hashedKey, entry)<br>&#125;<br></code></pre></td></tr></table></figure><p>在计算分片数时，取余操作使用的是位运算，所有分片数要设置为2的幂次方。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *BigCache)</span></span> getShard(hashedKey <span class="hljs-type">uint64</span>) (shard *cacheShard) &#123;<br><span class="hljs-keyword">return</span> c.shards[hashedKey&amp;c.shardMask]<br>&#125;<br><span class="hljs-comment">// shardMask = shardNum - 1</span><br></code></pre></td></tr></table></figure><ul><li>特点：<ul><li>减少锁冲突，提升并发量：当一个shard被加上Lock的时候，其他shard的读写不受影响。</li><li>shard一旦建好，将不再改变，无需考虑shard变化时的数据迁移问题，shard之间操作无需加锁。</li><li>shard个数必须是2的平方数。对2的平方数取余可以改成位运算，会比传统的%快很多</li></ul></li></ul><h3 id="2-3-Map-GC优化"><a href="#2-3-Map-GC优化" class="headerlink" title="2.3 Map GC优化"></a>2.3 Map GC优化</h3><p>在golang中，map的key和value一旦涉及到指针类型，在GC的时候就会触发遍历扫描，当数据量级很大时， GC延迟严重。<br>在bigcache的设计中，map定义为map[uint64]uint32 ，避免了存储任何指针。结构定义如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> cacheShard <span class="hljs-keyword">struct</span> &#123;<br>hashmap     <span class="hljs-keyword">map</span>[<span class="hljs-type">uint64</span>]<span class="hljs-type">uint32</span><br>entries     queue.BytesQueue<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li>hashmap的key是cache key的hash值，而value仅仅是个uint32。value存储的不再是实际值，而是value在 BytesQueue中的索引。</li><li>entries存储的是实际value值，它是一个ring buffer的内存结构，本质上就是个超大的[]byte数组，里面存放了所有的原始数据。每个原始数据就存放在这个大[]byte数组中的其中一段。<br>之所以用一个大的[]byte数组和ring buffer结构，除了方便管理和复用内存之外，一个更重要的原因是：对于[]byte数组, GC时只用看做一个变量扫描，无需再遍历全部数组。这样又避免了海量数据对GC造成的负担。</li></ul><h3 id="2-4-BytesQueue内存"><a href="#2-4-BytesQueue内存" class="headerlink" title="2.4 BytesQueue内存"></a>2.4 BytesQueue内存</h3><p>BigCache中的每一个shard都采用类似RingBuffer的结构</p><ul><li>对于map中每个元素而言，key存储的是 cache key的hash值，value存储的是实际值在byte数组中的位置。</li><li>数据存储完全采用FIFO的形式，所有数据的新增、包括老数据的修改，都是直接追加到数组的后面，然后修改map的位置值即可。<br><img src="/img/BigCache%E8%A7%A3%E6%9E%90/2.png"></li></ul><p>具体到每一个数据的存储，并不是完全只存储val值，会把一些相关的信息一起存储，构成数据header和body，，一个header和一个body构成一个完整的条目，其中：</p><ul><li>Block Size：标记header和Body，也就是Entry的总长度</li><li>header：包括 插入时间戳，key的hash值，key的长度， header的长度固定</li><li>body：key的原始值，value的原始值</li><li>有了BlockSize、Header Length以及Key的长度，就可以确定value的边界并正常进行数据读取了。<br><img src="/img/BigCache%E8%A7%A3%E6%9E%90/3.png"></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br><span class="hljs-comment">// header中的时间戳、hash值和key长度占用字节数固定，可以方便找到key原始值的起始位置</span><br>timestampSizeInBytes = <span class="hljs-number">8</span>       <span class="hljs-comment">// Number of bytes used for timestamp</span><br>hashSizeInBytes      = <span class="hljs-number">8</span>       <span class="hljs-comment">// Number of bytes used for hash</span><br>keySizeInBytes       = <span class="hljs-number">2</span>       <span class="hljs-comment">// Number of bytes used for size of entry key</span><br>headersSizeInBytes   = timestampSizeInBytes + hashSizeInBytes + keySizeInBytes <span class="hljs-comment">// Number of bytes used for all headers</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">wrapEntry</span><span class="hljs-params">(timestamp <span class="hljs-type">uint64</span>, hash <span class="hljs-type">uint64</span>, key <span class="hljs-type">string</span>, entry []<span class="hljs-type">byte</span>, buffer *[]<span class="hljs-type">byte</span>)</span></span> []<span class="hljs-type">byte</span> &#123;<br>keyLength := <span class="hljs-built_in">len</span>(key)<br>blobLength := <span class="hljs-built_in">len</span>(entry) + headersSizeInBytes + keyLength<br><br><span class="hljs-keyword">if</span> blobLength &gt; <span class="hljs-built_in">len</span>(*buffer) &#123;<br>*buffer = <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, blobLength)<br>&#125;<br>blob := *buffer<br><br><span class="hljs-comment">// 按照小端序的方式，顺序写入时间戳、key的hash值、key的长度、key的实际值以及value的实际值</span><br>binary.LittleEndian.PutUint64(blob, timestamp)<br>binary.LittleEndian.PutUint64(blob[timestampSizeInBytes:], hash)<br>binary.LittleEndian.PutUint16(blob[timestampSizeInBytes+hashSizeInBytes:], <span class="hljs-type">uint16</span>(keyLength))<br><span class="hljs-built_in">copy</span>(blob[headersSizeInBytes:], key)<br><span class="hljs-built_in">copy</span>(blob[headersSizeInBytes+keyLength:], entry)<br><br><span class="hljs-keyword">return</span> blob[:blobLength]<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>RingBuffer满时，bigCache如何处理？<ul><li>如果entries queue.BytesQueue 未达到设定的HardMaxCacheSize（最大内存上限），或者无HardMaxCacheSize要求，则直接扩容queue.BytesQueue 直到达到上限。不过扩容的时候，是创建了一个新的空[]byte数组，把原有数据copy过去。</li><li>如果内存已达上限，无法继续扩容，则会尝试删除最旧数据（无论是否过期），直至可以将数据放到BytesQueue中。如果这个时候新数据非常大，可能会为此淘汰掉许多旧数据。</li></ul></li></ul><h3 id="2-5-锁冲突"><a href="#2-5-锁冲突" class="headerlink" title="2.5 锁冲突"></a>2.5 锁冲突</h3><p>BigCache使用Key的hash值查找数据，不可避免的会导致hash冲突问题。锁冲突在写入和读取的过程中都有可能发生。下面分别分析Set和Get的过程，顺便看看锁冲突是如何解决的。</p><ul><li>Set流程<ul><li>计算key的hash值，得到对应的shard</li><li>将key和value等信息序列化成指定格式的[]byte, push到BytesQueue中。</li><li>根据BytesQueue返回的偏移量(也就是数组下标)，将key(hash值)和value(数组下标)设置hashmap中。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *cacheShard)</span></span> set(key <span class="hljs-type">string</span>, hashedKey <span class="hljs-type">uint64</span>, entry []<span class="hljs-type">byte</span>) <span class="hljs-type">error</span> &#123;<br>currentTimestamp := <span class="hljs-type">uint64</span>(s.clock.epoch())<br><br>s.lock.Lock()<br><span class="hljs-comment">// 从这里可以看到，如果发现存在已有的hashKey（可能是冲突，也可能是本来就存在），bigcache并不会做特殊处理，而是直接将原本的位置reset，并将新的值push到最后，然后替换这个key的下标</span><br><span class="hljs-keyword">if</span> previousIndex := s.hashmap[hashedKey]; previousIndex != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> previousEntry, err := s.entries.Get(<span class="hljs-type">int</span>(previousIndex)); err == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// resetKeyFromEntry 会将条目中key的hash值置零</span><br>resetKeyFromEntry(previousEntry)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> oldestEntry, err := s.entries.Peek(); err == <span class="hljs-literal">nil</span> &#123;<br>s.onEvict(oldestEntry, currentTimestamp, s.removeOldestEntry)<br>&#125;<br><br><span class="hljs-comment">// 构建一个数据条目</span><br>w := wrapEntry(currentTimestamp, hashedKey, key, entry, &amp;s.entryBuffer)<br><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">// 将数据条目push到最后，并修改hashmap的值，就完成了增加或者更新</span><br><span class="hljs-keyword">if</span> index, err := s.entries.Push(w); err == <span class="hljs-literal">nil</span> &#123;<br>s.hashmap[hashedKey] = <span class="hljs-type">uint32</span>(index)<br>s.lock.Unlock()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">if</span> s.removeOldestEntry(NoSpace) != <span class="hljs-literal">nil</span> &#123;<br>s.lock.Unlock()<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;entry is bigger than max shard size&quot;</span>)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li>Get流程<ul><li>读数据，hash冲突时直接返回数据不存在，可能这也是存储key实际值的意义所在。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *cacheShard)</span></span> get(key <span class="hljs-type">string</span>, hashedKey <span class="hljs-type">uint64</span>) ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br>s.lock.RLock()<br>itemIndex := s.hashmap[hashedKey]<br><br><span class="hljs-comment">// bigcache 中， ringbuffer 的第 0 位并不用来存放任何数据，</span><br><span class="hljs-comment">// 如果发现 分片 map 中得到数据的 index 为 0，就可以直接认为没有对应的缓存数据</span><br><span class="hljs-keyword">if</span> itemIndex == <span class="hljs-number">0</span> &#123;<br>s.lock.RUnlock()<br>s.miss()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, ErrEntryNotFound<br>&#125;<br><br><span class="hljs-comment">// 从ringbuff中获取到指定key的条目数据</span><br>wrappedEntry, err := s.entries.Get(<span class="hljs-type">int</span>(itemIndex))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>s.lock.RUnlock()<br>s.miss()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-comment">// 从数据中解析出实际存储的key</span><br><span class="hljs-comment">// 如果实际存储的key跟查询的key不一致，说明产生了hash冲突，直接返回空</span><br><span class="hljs-keyword">if</span> entryKey := readKeyFromEntry(wrappedEntry); key != entryKey &#123;<br><span class="hljs-keyword">if</span> s.isVerbose &#123;<br>s.logger.Printf(<span class="hljs-string">&quot;Collision detected. Both %q and %q have the same hash %x&quot;</span>, key, entryKey, hashedKey)<br>&#125;<br>s.lock.RUnlock()<br>s.collision()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, ErrEntryNotFound<br>&#125;<br>entry := readEntry(wrappedEntry)<br>s.lock.RUnlock()<br>s.hit()<br><span class="hljs-keyword">return</span> entry, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2-6-数据删除"><a href="#2-6-数据删除" class="headerlink" title="2.6 数据删除"></a>2.6 数据删除</h3><p>BigCache的删除比较简单，本质上只是将key从map中删除，并没有实际删除BytesQueue中的数据，核心逻辑只有两行。实际值的删除会等到数据清理或者Buffer满的时候淘汰掉。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">...<br><span class="hljs-comment">// 从hashmap中删除key，使数据不可读</span><br><span class="hljs-built_in">delete</span>(s.hashmap, hashedKey)<br>...<br><span class="hljs-comment">// 将entry条目的key的hash值置零</span><br>resetHashFromEntry(wrappedEntry)<br>...<br></code></pre></td></tr></table></figure><h3 id="2-7-过期淘汰"><a href="#2-7-过期淘汰" class="headerlink" title="2.7 过期淘汰"></a>2.7 过期淘汰</h3><p>BigCache中的数据在删除数据或者Set数据时，如果碰到就值，只是删除或者修改hashmap中的值，并不会实际删除数据。实际的数据删除发生在过期淘汰时。</p><p>📌 <font color="red">BigCache没有开放单个元素的可过期时间，所有元素的cache时长都是一样的，这就意味着所有元素的过期时间在队列中天然有序。</font>    </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *cacheShard)</span></span> cleanUp(currentTimestamp <span class="hljs-type">uint64</span>) &#123;<br>s.lock.Lock()<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">// 只要存在元素，就逐个便利</span><br><span class="hljs-keyword">if</span> oldestEntry, err := s.entries.Peek(); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br><span class="hljs-comment">// 直至某个元素不过期为止</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> evicted := s.onEvict(oldestEntry, currentTimestamp, s.removeOldestEntry); !evicted &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>s.lock.Unlock()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3. 注意事项"></a>3. 注意事项</h2><h3 id="3-1-数据过期处理"><a href="#3-1-数据过期处理" class="headerlink" title="3.1 数据过期处理"></a>3.1 数据过期处理</h3><p>在bigcache中，LifeWindow和CleanWindow是两个用于缓存管理的重要参数，但它们有不同的作用。</p><ul><li>LifeWindow 是缓存条目的生存时间，决定了条目在多长时间内会被视为过期。</li><li>CleanWindow 是清理过程的时间间隔，决定了过期条目实际被清除的频率。</li></ul><p>这种机制使得bigcache在设计上允许读取过期数据。它不会主动阻止访问已经过期的缓存条目，除非这些条目在CleanWindow期间被清理掉。</p><p>bigcache的这种设计是为了优化性能，因为在每次访问缓存时都检查条目是否过期会带来额外的性能开销。通过异步清理过期条目，bigcache能够在不影响访问速度的情况下提供缓存功能。</p><p>如果对数据的时效性要求很高，需要手动在读取后检查数据是否过期，代码示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">item, err := cache.Get(<span class="hljs-string">&quot;myKey&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-comment">// Handle the error</span><br>&#125;<br><br>timestamp := extractTimestamp(item) <span class="hljs-comment">// 解析数据中的时间戳</span><br><span class="hljs-keyword">if</span> time.Since(timestamp) &gt; cacheLifeWindow &#123;<br>    <span class="hljs-comment">// Data is considered stale</span><br>    <span class="hljs-comment">// Handle the stale data case</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-参考文献"><a href="#4-参考文献" class="headerlink" title="4. 参考文献"></a>4. 参考文献</h2><p><a href="https://juejin.cn/post/7107635176263385118">https://juejin.cn/post/7107635176263385118</a></p><p><a href="https://www.cyhone.com/articles/bigcache/">https://www.cyhone.com/articles/bigcache/</a> </p><p><a href="https://mp.weixin.qq.com/s/e-ku-fLsLk0Ok2eTkdx6Dw">https://mp.weixin.qq.com/s/e-ku-fLsLk0Ok2eTkdx6Dw</a></p><p><a href="https://juejin.cn/post/7258840980428750885">https://juejin.cn/post/7258840980428750885</a></p><p><a href="https://xiaorui.cc/archives/7385">https://xiaorui.cc/archives/7385</a></p>]]></content>
    
    
    <categories>
      
      <category>系统设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BigCache</tag>
      
      <tag>本地缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>布隆过滤器</title>
    <link href="/2024/08/03/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <url>/2024/08/03/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>布隆过滤器（英语：Bloom Filter）是 1970 年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。主要用于判断一个元素是否在一个集合中。</p><span id="more"></span>  <h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>通常我们要判断一个元素是否在某个集合中时，经常想到的方式是将集合中所有元素保存起来，然后通过比较进行确定。链表、树、散列表（又叫哈希表，Hash table）等数据结构都是这种思路。但是随着集合中元素数量的增加，这几种方式需要的存储空间也会呈现线性增长，最终达到瓶颈。上述三种结构的检索时间复杂度分别为O(n)，O(logn)，O(1)。</p><h2 id="2-算法介绍"><a href="#2-算法介绍" class="headerlink" title="2. 算法介绍"></a>2. 算法介绍</h2><h3 id="2-1-原理"><a href="#2-1-原理" class="headerlink" title="2.1 原理"></a>2.1 原理</h3><p>布隆过滤器包含一个位数组和一组哈希函数。位数组每个元素存储的都是比特位，元素占用空间很小；使用一组哈希函数的原因是为了降低哈希冲突。</p><ul><li>初始状态：一个位数组，全部位置都置为0<br><img src="/img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/1.png"></li><li>数据加入：分别使用多个哈希函数对元素值进行计算，得到一组哈希值，将对应哈希值下标的数组值置为1<br><img src="/img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/2.png"></li><li>数据查找：对给定元素进行相同的哈希计算，判断每个位置的值是否都为1。如果值都为1，就认为这个元素存在，如果有一个值不唯一，就说明这个值不存在。</li></ul><p>📌 <font color="red">注意：布隆过滤器返回的结果是“可能存在”和“一定不存在”，不能提供“一定存在”的语义保证。因为可能有多个元素映射到同一个位置，导致误判。</font>    </p><h3 id="2-2-误判"><a href="#2-2-误判" class="headerlink" title="2.2 误判"></a>2.2 误判</h3><p>误判率（假阳性）：一个不存在的元素，可能会被误判为存在</p><h4 id="2-2-1-误判原因"><a href="#2-2-1-误判原因" class="headerlink" title="2.2.1 误判原因"></a>2.2.1 误判原因</h4><ul><li>哈希函数冲突：不同的哈希函数对元素进行映射时，可能会产生冲突，导致不同元素因素到位数组的相同位置。如下图所示：w的位置都已经是1，被认为w存在。</li><li>位数组大小限制：为减少空间占用，位数组大小有限。当存储的元素数量较多时，数据冲突可能性升高。<br><img src="/img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/3.png"></li></ul><h4 id="2-2-2-误判概率"><a href="#2-2-2-误判概率" class="headerlink" title="2.2.2 误判概率"></a>2.2.2 误判概率</h4><p>布隆过滤器的误判，主要是因为哈希函数存在冲突导致，即不同的值可能映射到同一个位置。在进行误判率的分析时，主要受到以下变量的制约：</p><ul><li><p>m：布隆过滤器的长度，即数组的长度</p></li><li><p>n： 集合中的元素个数</p></li><li><p>k： 哈希函数的个数<br><img src="/img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/4.png"></p></li><li><p>误判率：指定m、n、k情况下的误判率计算<br><img src="/img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/5.png"></p></li><li><p>长度：数组长度可以根据期望的误判率和元素个数来判断<br><img src="/img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/6.png"></p></li><li><p>哈希函数计算：指定m和n的情况下，减少误判的最佳哈希个数<br><img src="/img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/7.png"></p></li></ul><p>推导过程：</p><ul><li>添加1个元素，则任一比特为1的概率为：1&#x2F;m，任一比特为0的概率：1-1&#x2F;m；</li><li>添加1个元素，执行k次散列之后，则任一比特为0的概率：(1-1&#x2F;m)^k，任一比特为1的概率：1-(1-1&#x2F;m)^k；</li><li>如果添加n个元素，那么任一比特为0的概率：(1-1&#x2F;m)^kn，任一比特为1的概率：1-(1-1&#x2F;m)^kn；</li><li>如果将1个新的元素，添加到已存在n个元素的布隆过滤器中，则任一比特已经为1的概率与上面相同，概率为：1-(1-1&#x2F;m)^kn。因此，k个比特都为1的概率为：(1-(1-1&#x2F;m)^kn)^k，此即为新插入元素的误识别率。</li></ul><h3 id="2-3-无法删除"><a href="#2-3-无法删除" class="headerlink" title="2.3 无法删除"></a>2.3 无法删除</h3><p>布隆过滤器不允许删除元素：如果删除某个元素，导致对应位置为0，但是可能有多个元素映射到相同的位置上面，这样就会导致一个存在的元素被判断为不存在。破坏了“一定不存在”的语义保证。</p><p>📌 <font color="red">不允许删除的机制会导致其中的无效元素可能会越来越多，即实际已经在磁盘删除中的元素，但在布隆过滤器中还认为可能存在，这会造成越来越多的误判</font>   </p><h3 id="2-4-优缺点总结"><a href="#2-4-优缺点总结" class="headerlink" title="2.4 优缺点总结"></a>2.4 优缺点总结</h3><p>优点：</p><ul><li>插入、查询的效率高，时间复杂度为常数O(k)</li><li>空间占用小（存储空间占用是一个固定长度的bit数组）</li><li>散列函数相互之间没有关系，可以并行Hash</li><li>不存储原始数据，在严格要求保密的场景下有优势<br>缺点：</li><li>存在误报的可能性，尤其数据量越大越容易误报</li><li>只支持新增，不支持删除</li><li>数组长度和hash函数个数确定复杂</li><li>当过滤器数组过长时，查询性能差（多个哈希得到的下标跨度很大，CPU缓存命中率低）</li></ul><h2 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="3. 应用场景"></a>3. 应用场景</h2><p>布隆过滤器在实际项目开发中可以快速地解决一些问题，比如网页 URL 去重、垃圾邮件识别、大集合中重复元素的判断和缓存穿透等问题。<br>典型应用有：</p><ul><li>数据库防止穿库。 Google Bigtable，HBase 和 Cassandra 以及 Postgresql 使用BloomFilter减少不存在的行或列的磁盘查找。避免代价高昂的磁盘查找会大大提高数据库查询操作的性能。</li><li>业务场景中判断用户是否阅读过某视频或文章：比如抖音或头条，当然会导致一定的误判，但不会让用户看到重复的内容。</li><li>缓存穿透场景。在一些恶意请求中，请求参数都是缓存和数据中不存在的值，为了避免缓存穿透，可以用布隆过滤器先筛选一遍，只有在布隆过滤器中，才去查询缓存，如果没查询到，则穿透到db。如果不在布隆器中，则直接返回。</li><li>WEB拦截器，如果相同请求则拦截，防止重复被攻击。可以提高缓存命中率。Squid 网页代理缓存服务器在 cache digests 中就使用了布隆过滤器。Google Chrome浏览器使用了布隆过滤器加速安全浏览服务</li></ul><h2 id="4-实现"><a href="#4-实现" class="headerlink" title="4. 实现"></a>4. 实现</h2><p>基于Golang实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-string">&quot;github.com/bits-and-blooms/bitset&quot;</span><br>)<br><br><span class="hljs-comment">// 设置哈希数组默认大小为16</span><br><span class="hljs-keyword">const</span> DefaultSize = <span class="hljs-number">16</span><br><br><span class="hljs-comment">// 设置种子，保证不同哈希函数有不同的计算方式</span><br><span class="hljs-keyword">var</span> seeds = []<span class="hljs-type">uint</span>&#123;<span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">31</span>, <span class="hljs-number">37</span>, <span class="hljs-number">61</span>&#125;<br><br><span class="hljs-comment">// 构造6个哈希函数，每个哈希函数有参数seed保证计算方式的不同</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildHash</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(seed <span class="hljs-type">uint</span>, value <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">uint</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(seed <span class="hljs-type">uint</span>, value <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">uint</span> &#123;<br><span class="hljs-keyword">var</span> result <span class="hljs-type">uint</span> = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(value); i++ &#123;<br>result = result*seed + <span class="hljs-type">uint</span>(value[i])<br>&#125;<br><span class="hljs-keyword">return</span> result &amp; (DefaultSize - <span class="hljs-number">1</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 布隆过滤器结构，包括二进制数组和多个哈希函数</span><br><span class="hljs-keyword">type</span> BloomFilter <span class="hljs-keyword">struct</span> &#123;<br>set       *bitset.BitSet<br>hashFuncs [<span class="hljs-number">6</span>]<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(seed <span class="hljs-type">uint</span>, value <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">uint</span><br>&#125;<br><br><span class="hljs-comment">// 构造一个布隆过滤器，包括数组和哈希函数的初始化</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewBloomFilter</span><span class="hljs-params">()</span></span> *BloomFilter &#123;<br>bf := <span class="hljs-built_in">new</span>(BloomFilter)<br>bf.set = bitset.New(DefaultSize)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(bf.hashFuncs); i++ &#123;<br>bf.hashFuncs[i] = buildHash()<br>&#125;<br><span class="hljs-keyword">return</span> bf<br>&#125;<br><br><span class="hljs-comment">// Add 添加元素，将哈希函数计算结果对应的数组位置1</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *BloomFilter)</span></span> Add(value <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">for</span> i, f := <span class="hljs-keyword">range</span> b.hashFuncs &#123;<br>b.set.Set(f(seeds[i], value))<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Contains 查询元素是否存在，调用每个哈希函数，并且判断数组对应位是否为1 如果不为1，直接返回false，表明一定不存在</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *BloomFilter)</span></span> Contains(value <span class="hljs-type">string</span>) <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">for</span> i, f := <span class="hljs-keyword">range</span> b.hashFuncs &#123;<br><span class="hljs-keyword">if</span> !b.set.Test(f(seeds[i], value)) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>filter := NewBloomFilter()<br>filter.Add(<span class="hljs-string">&quot;hello&quot;</span>)<br>filter.Add(<span class="hljs-string">&quot;world&quot;</span>)<br>fmt.Println(filter.Contains(<span class="hljs-string">&quot;hello&quot;</span>))<br>fmt.Println(filter.Contains(<span class="hljs-string">&quot;world&quot;</span>))<br>fmt.Println(filter.Contains(<span class="hljs-string">&quot;xiao&quot;</span>))<br>fmt.Println(filter.Contains(<span class="hljs-string">&quot;xiaoming&quot;</span>)) <span class="hljs-comment">// 出现误判</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-演进变体"><a href="#5-演进变体" class="headerlink" title="5. 演进变体"></a>5. 演进变体</h2><p>针对布隆过滤器的上述一些问题，逐步产生了一些布隆过滤器的变体，简单介绍如下：</p><h3 id="5-1-计数布隆过滤器-Counting-Bloom-Filter"><a href="#5-1-计数布隆过滤器-Counting-Bloom-Filter" class="headerlink" title="5.1 计数布隆过滤器 Counting Bloom Filter"></a>5.1 计数布隆过滤器 Counting Bloom Filter</h3><ul><li>特点：支持删除</li><li>原理：CountingBloomFilter是BloomFilter的一个变种，它扩展标准布隆过滤器的数据结构，将底层数组的每一位扩展为一个4位大小的计数器Counter，用来存储某个下标映射成功的频次。它以占用更多的空间来换取支持删除操作。</li></ul><ol><li>插入元素时，通过k个哈希函数映射到k个计数器，这些命中的计数器值增加1；</li><li>删除元素时，删除元素的时候，通过k个散列函数映射到k个计数器，这些计数器值减少1。<br><img src="/img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/8.png"></li></ol><p>优点：</p><ul><li>除了占用存储空间翻（多）倍，继承了布隆过滤器的所有优点；支持删除。</li></ul><p>缺点：</p><ul><li>误报的概率仍然存在</li><li>需要额外考虑 Counter 数组中每个 Counter 的大小（最好具备溢出策略）</li><li>存储空间较布隆过滤器翻（多）倍</li></ul><h3 id="5-2-扩展布隆过滤器-Scalable-Bloom-Filter"><a href="#5-2-扩展布隆过滤器-Scalable-Bloom-Filter" class="headerlink" title="5.2 扩展布隆过滤器 Scalable Bloom Filter"></a>5.2 扩展布隆过滤器 Scalable Bloom Filter</h3><ul><li>特点：支持扩容</li><li>原理：Scalable Bloom Filter只会向最后一层插入数据，同时也从最后一层开始查询，直到查询至 BF0 层。<br><img src="/img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/9.png"></li></ul><ol><li>插入过程：只会向最后一层插入数据<ol><li>初始，SBF只包含BF0这一层，插入了a、b、c三个元素。</li><li>然后，假设BF0已经无法保证用户设定的误判率，此时就需要进行扩容，因此新的一层BF1被创建并加入进来。后来的d、e、f元素都会被插入到BF1中。</li><li>同理，当BF1也无法满足该层事先设定的误判率时，新的一层BF2也将被加入进来，如此进行下去。</li></ol></li><li>查询过程：从最后一层开始由后向前查询<ol><li>首先在BF1中进行查询。如果查询显示存在，则直接响应客户端；</li><li>如果查询显示不存在，则继续查询BF0。如果BF0中显示存在g，则响应客户端g存在。否则，因为BF0已经是最后一层了，则响应客户端g不存在。</li></ol></li></ol><p>缺点：</p><ul><li>查询开销：需要查询多个布隆过滤器，较单一布隆过滤器增加了一定的查询时间开销。</li><li>管理复杂度：维护多个布隆过滤器的策略相对复杂。</li></ul><h3 id="5-2-布谷鸟过滤器-Cuckoo-Filter"><a href="#5-2-布谷鸟过滤器-Cuckoo-Filter" class="headerlink" title="5.2 布谷鸟过滤器 Cuckoo Filter"></a>5.2 布谷鸟过滤器 Cuckoo Filter</h3><p>布谷鸟过滤器是布隆过滤器的变体，提供了删除元素的功能。它主要基于布谷鸟哈希和指纹技术。当插入一个元素时，布谷鸟过滤器存储该元素的“指纹”到哈希表的某个位置上。如果该位置已被占用，现有的元素会被移动到另一个位置，如此迭代下去，直到每个元素都有自己的位置为止。</p><p>最简单的布谷鸟哈希结构是一维数组结构</p><ol><li>每个元素都由哈希函数h1(x)和h2(x)确定两个候选位置，查找过程会检查两个位置是否任意一个位置为空。</li><li>如果两个位置中任何一个是空的，则算法将元素插入到该空位置中，插入完成；</li><li>如果两个位置都是满的，会选择一个候选位置踢出去现有的元素(鸠占鹊巢)，并将此被踢出元素重新插入到它的备用位置。这个过程可能会重复，直到找到一个空位置或达到最大位移次数。如果没有找到空位置，则认为此哈希表太满，则进行扩容和ReHash后，再次插入。<br><img src="/img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/10.png"></li></ol><h2 id="6-参考资料"><a href="#6-参考资料" class="headerlink" title="6. 参考资料"></a>6. 参考资料</h2><p>布隆过滤器：<br><a href="https://segmentfault.com/a/1190000021136424">https://segmentfault.com/a/1190000021136424</a><br><a href="https://segmentfault.com/a/1190000024566947">https://segmentfault.com/a/1190000024566947</a></p><p>计数布隆过滤器：<br><a href="https://juejin.cn/post/7362729128477638675">https://juejin.cn/post/7362729128477638675</a> </p><p>布谷鸟过滤器：<br><a href="https://www.cnblogs.com/zhaodongge/p/15067657.html">https://www.cnblogs.com/zhaodongge/p/15067657.html</a><br><a href="https://dbwu.tech/posts/cuckoo_filter/">https://dbwu.tech/posts/cuckoo_filter/</a></p>]]></content>
    
    
    <categories>
      
      <category>系统设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>布隆过滤器</tag>
      
      <tag>系统设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang中的Defer、Panic和Recover</title>
    <link href="/2024/07/13/Golang%E4%B8%ADdefer-panic-recvover%E5%88%86%E6%9E%90/"/>
    <url>/2024/07/13/Golang%E4%B8%ADdefer-panic-recvover%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>Golang中没有类似java的try catch机制进行异常处理，而是引入了defer、panic和recover来触发异常和终止异常。</p><span id="more"></span>  <h2 id="1-Defer"><a href="#1-Defer" class="headerlink" title="1. Defer"></a>1. Defer</h2><p>defer是go语言提供的一种用于注册延迟调用的机制：让函数或者语句可以在当前函数执行完毕后执行（包括通过return正常结束或者panic导致的异常结束）。</p><p>常用于一些操作后的收尾工作，比如关闭连接、释放锁、关闭文件等，使用起来比较优雅。  </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs golang">f, _ := os.Open(<span class="hljs-string">&quot;defer.txt&quot;</span>)<br><span class="hljs-keyword">defer</span> f.Close()  <br></code></pre></td></tr></table></figure><h3 id="1-1-Defer基本原理"><a href="#1-1-Defer基本原理" class="headerlink" title="1.1 Defer基本原理"></a>1.1 Defer基本原理</h3><p>defer使用准则</p><ul><li><p>每次defer语句执行的时候，会把函数“压栈”，函数参数会被拷贝下来，但是闭包引用不会</p><ul><li>作为函数参数：在defer定义时就把值传递给defer，并被cache起来，后续不会再改变</li><li>作为闭包引用：在defer函数真正调用时根据整个上下文确定当前的值。</li></ul></li><li><p>当外层逻辑退出时，defer函数按照定义的逆序执行；【先入后出，压栈进行】</p></li><li><p>恰当的使用defer方法可以修改返回值  </p></li><li><p>先入后出</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++ &#123;<br><span class="hljs-keyword">defer</span> fmt.Println(i)<br>&#125;<br>&#125; <br><span class="hljs-comment">// 输出 3 2 1</span><br></code></pre></td></tr></table></figure></li><li><p>defer函数的参数引用方式</p><ul><li>作为函数入参，在函数定义时就已经传递给defer函数，后续不会再改变  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">b</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++ &#123;<br>        <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a <span class="hljs-type">int</span>)</span></span> &#123;<br>            fmt.Println(a)<br>        &#125;(i)<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 输出 3 2 1</span><br></code></pre></td></tr></table></figure></li><li>作为闭包的引用时，在最后执行的时候确定上下文的值  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">c</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++ &#123;<br>        <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            fmt.Println(i)<br>        &#125;()<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 输出 4 4 4 </span><br><span class="hljs-comment">// i = 3 时定义最后一个defer，又进行了+1操作后，才真正开始执行defer函数</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="1-2-defer命令拆解"><a href="#1-2-defer命令拆解" class="headerlink" title="1.2 defer命令拆解"></a>1.2 defer命令拆解</h3><p>上面说defer可以操作返回值，本质上就是在含有defer函数的代码中，一个 return xxx的语句可以进行拆解，这条语句在实际执行时分三步进行：</p><blockquote><ol><li>返回值 &#x3D; xxx</li><li>执行defer函数</li><li>空的return</li></ol></blockquote><p>典型案例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">d</span><span class="hljs-params">()</span></span> (r <span class="hljs-type">int</span>) &#123;<br>t := <span class="hljs-number">5</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>t = t + <span class="hljs-number">5</span><br>&#125;()<br><span class="hljs-keyword">return</span> t<br>&#125;<br><span class="hljs-comment">// 返回 5</span><br><span class="hljs-comment">// r=t; t=t+5; return </span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">e</span><span class="hljs-params">()</span></span> (r <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(r <span class="hljs-type">int</span>)</span></span> &#123;<br>r = r + <span class="hljs-number">5</span><br>&#125;(r)<br><span class="hljs-keyword">return</span> <span class="hljs-number">5</span><br>&#125;<br><span class="hljs-comment">// 返回 5</span><br><span class="hljs-comment">// r = 5； r=r+5（这个r为形参r，不是返回值r）； return</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> (r <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>r = r + <span class="hljs-number">5</span><br>&#125;()<br><span class="hljs-keyword">return</span> <span class="hljs-number">5</span><br>&#125;<br><br><span class="hljs-comment">// 返回 10</span><br><span class="hljs-comment">// r = 5； r=r+5； return</span><br></code></pre></td></tr></table></figure><p>从以上的实际案例中可以看到：</p><p>📌 <font color="red">能通过defer修改返回值的场景，一定是有命名返回值的函数场景。</font>  </p><h2 id="2-Painc和Recover"><a href="#2-Painc和Recover" class="headerlink" title="2. Painc和Recover"></a>2. Painc和Recover</h2><p>当go在运行过程中发送异常时，Go运行时会触发运行时panic，并在调用它的函数中向本层以及所有上层逐级抛出，若一直没有recover捕获，程序最终会终止。  </p><p>若在某层defer语句中被recover捕获，控制流程将进入到recover之后的语句中。通过panic、defer和recover，可以实现类似try catch的功能。  </p><p>例如： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;defer in&quot;</span>)<br><span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br>&#125;()<br><br>fmt.Println(<span class="hljs-string">&quot;panic begin&quot;</span>)<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;hello, I&#x27;m panic&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;panic end&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 输出</span><br><span class="hljs-comment">// panic begin</span><br><span class="hljs-comment">// defer in</span><br><span class="hljs-comment">// hello, I&#x27;m panic</span><br></code></pre></td></tr></table></figure><p>📌 <font color="red">注意：defer中的recover仅对当前协程生效，且仅在直接被defer函数调用才有效</font>    </p><h3 id="2-1-Recover使用规则"><a href="#2-1-Recover使用规则" class="headerlink" title="2.1 Recover使用规则"></a>2.1 Recover使用规则</h3><p>Recover在使用的过程中，一般会判断返回值是否为空，当返回值为空的时候代表没有正常捕获问题。golang官方介绍了几种Recover返回为空的场景。</p><ol><li>panic的参数为空</li><li>当前协程没有panic</li><li>recover没有直接被defer函数调用</li></ol><p>分别介绍如下：</p><ul><li><p>panic参数为空，可以正常捕获 &#x2F;&#x2F; 本身panic参数为nil时候等同于没有发送panic</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;panic: %v&quot;</span>, err)<br>&#125;<br>&#125;()<br><br><span class="hljs-built_in">panic</span>(<span class="hljs-literal">nil</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>跨协程调用recover函数，无法捕获异常</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// panic跟recover不在一个协程，无法捕获异常</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>log.Println(<span class="hljs-built_in">recover</span>())<br>&#125;()<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;A bad boy stole a server&quot;</span>)<br>&#125;()<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>不在defer函数中直接调用，无法捕获异常</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 对 recover进行了一层封装，无法正常生效</span><br>Recover(<span class="hljs-string">&quot;Panic in goroutine&quot;</span>)<br>&#125;()<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;A bad boy stole the server&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Recover</span><span class="hljs-params">(funcName <span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;panic para: %v, panic info: %v\n&quot;</span>, funcName, err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>进阶分析</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// recover是在匿名函数/闭包中使用，实际执行时取值，触发panic后有值</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>log.Print(<span class="hljs-built_in">recover</span>(), <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;, a handsome police catch him.\n\n&quot;</span><br>&#125;())<br>&#125;()<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;A bad boy stole a server&quot;</span>)<br>&#125;()<br><br>time.Sleep(<span class="hljs-number">3</span> * time.Second)<br><br><span class="hljs-comment">// recover作为函数参数使用，定义时就完成值拷贝，刚开始没报错，最后也不会有值。</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> log.Print(<span class="hljs-built_in">recover</span>(), <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;, but a handsome police catch nothing.\n&quot;</span><br>&#125;())<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;A bad boy stole a server, again.&quot;</span>)<br>&#125;()<br>time.Sleep(<span class="hljs-number">3</span> * time.Second)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-2-Defer、Panic、Recover原理浅析"><a href="#2-2-Defer、Panic、Recover原理浅析" class="headerlink" title="2.2 Defer、Panic、Recover原理浅析"></a>2.2 Defer、Panic、Recover原理浅析</h3><p><img src="/img/Golang%E4%B8%ADdefer-panic-recvover%E5%88%86%E6%9E%90/2.png"><br>异常恢复流程可以总结成以下主要流程：</p><ul><li>触发panic流程：panic终止程序的过程是由编译器将关键字 panic 转换成 runtime.gopanic() 内置函数。异常恢复的流程基本都在这个函数中：<ul><li>首先会创建一个_panic结构体用来记录当前panic，并且将当前panic加入当前goroutine的_panic链表</li><li>然后循环从当前 goroutine 的_defer链表中获取runtime._defer并调用runtime.reflectcall()运行defer函数。</li></ul></li><li>恢复流程：如果defer函数中如果recover调用，recover会被汇编转换成runtime.gorecover调用，该函数会标记该panic已经被recover。在执行完某个defer后，如果该panic被标记为recover，则会调用runtime.recovery恢复goroutine的执行。</li><li>崩溃流程：如果_defer链表为空，或者执行完所有的defer都不包含recover调用，则会调用runtime.fatalpanic打印panic信息，然后中止&#x2F;退出程序。</li></ul><h2 id="3-参考资料"><a href="#3-参考资料" class="headerlink" title="3. 参考资料"></a>3. 参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/487749806">https://zhuanlan.zhihu.com/p/487749806</a> </p><p><a href="https://zhuanlan.zhihu.com/p/689615742">https://zhuanlan.zhihu.com/p/689615742</a></p><p><a href="https://go101.org/article/panic-and-recover-use-cases.html">https://go101.org/article/panic-and-recover-use-cases.html</a> </p><p><a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/">https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/</a></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>异常处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB查询性能分析-Explain</title>
    <link href="/2024/06/30/MongoDB%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-Explain/"/>
    <url>/2024/06/30/MongoDB%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-Explain/</url>
    
    <content type="html"><![CDATA[<p>在日常的MongoDB开发和使用中，不可避免的会碰到一些慢查询的问题，针对这些问题，我们一般可以使用 explain 方法来获取查询的执行计划和性能分析信息。使用explain方法可以帮助我们理解查询是如何执行的，以及识别性能瓶颈和优化对象。</p><span id="more"></span>   <h2 id="1-Explain简介"><a href="#1-Explain简介" class="headerlink" title="1. Explain简介"></a>1. Explain简介</h2><h3 id="1-1-基本使用"><a href="#1-1-基本使用" class="headerlink" title="1.1 基本使用"></a>1.1 基本使用</h3><p>使用 explain 方法；你可以在任何查询、更新或删除操作中使用 explain 方法。以下是一些基本示例。<br>假设你有一个集合 myCollection，你可以如下进行操作：</p><ul><li><p>对查询操作使用 explain   </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.myCollection.find(&#123; a: &#123; $gt: <span class="hljs-number">1</span>, $lt: <span class="hljs-number">2</span> &#125; &#125;).explain() <br></code></pre></td></tr></table></figure><p>这将返回查询的执行计划，包括扫描类型、索引使用情况和其他详细信息。</p></li><li><p>对更新操作使用 explain   </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.myCollection.updateMany(&#123; a: &#123; $gt: <span class="hljs-number">1</span>, $lt: <span class="hljs-number">2</span> &#125; &#125;, &#123; $<span class="hljs-keyword">set</span>: &#123; b: <span class="hljs-number">1</span> &#125; &#125;).explain() <br></code></pre></td></tr></table></figure></li><li><p>对删除操作使用 explain    </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.myCollection.deleteMany(&#123; a: &#123; $gt: <span class="hljs-number">1</span>, $lt: <span class="hljs-number">2</span> &#125; &#125;).explain() <br></code></pre></td></tr></table></figure></li></ul><h3 id="1-2-输出含义解析"><a href="#1-2-输出含义解析" class="headerlink" title="1.2 输出含义解析"></a>1.2 输出含义解析</h3><p>explain 方法返回一个包含以下信息的文档：</p><ul><li><p>queryPlanner：描述查询计划的信息。</p><ul><li>plannerVersion：查询规划器的版本。</li><li>namespace：查询的命名空间（即数据库和集合）。</li><li>indexFilterSet：是否设置了索引过滤。</li><li>parsedQuery：解析后的查询条件。</li><li>winningPlan：实际执行的查询计划。<font color="red">（winningPlan比较重要，一般可以看出当前查询语句使用的索引计划等，方便问题排查）</font></li><li>rejectedPlans：被拒绝的查询计划（如果有）。</li></ul></li><li><p>executionStats：提供查询执行的统计信息（仅在使用 executionStats 或 allPlansExecution 模式时）。</p><ul><li>executionSuccess：查询是否成功执行。</li><li>nReturned：返回的文档数量。</li><li>executionTimeMillis：查询执行时间（毫秒）。</li><li>totalKeysExamined：检查的索引键数量。</li><li>totalDocsExamined：检查的文档数量。</li><li>serverInfo：有关服务器的信息。</li></ul></li></ul><h3 id="1-3-模式差别"><a href="#1-3-模式差别" class="headerlink" title="1.3 模式差别"></a>1.3 模式差别</h3><p>explain 方法有三种模式, 可以通过传递参数来指定模式。</p><ul><li>queryPlanner（默认）：只返回查询计划，不包含实际执行统计信息。  </li><li>executionStats：返回查询计划和执行统计信息。  </li><li>allPlansExecution：返回所有执行计划和它们的执行统计信息。</li></ul><h3 id="1-4-具体案例分析"><a href="#1-4-具体案例分析" class="headerlink" title="1.4 具体案例分析"></a>1.4 具体案例分析</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.myCollection.find(&#123; a: &#123; $gt: <span class="hljs-number">1</span>, $lt: <span class="hljs-number">2</span> &#125; &#125;).explain(&quot;executionStats&quot;) <br></code></pre></td></tr></table></figure><p>以下是一个 explain 方法的示例输出：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;queryPlanner&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;plannerVersion&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;namespace&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;myDatabase.myCollection&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;indexFilterSet&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;parsedQuery&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;a&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;$gt&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;$lt&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;winningPlan&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;stage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;FETCH&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;inputStage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;stage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;IXSCAN&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;keyPattern&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;a&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;indexName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;a_1&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;isMultiKey&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;multiKeyPaths&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;a&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;isUnique&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;isSparse&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;isPartial&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;indexVersion&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;direction&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;forward&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;indexBounds&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;a&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-string">&quot;(1.0, 2.0)&quot;</span><br>          <span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;rejectedPlans&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;executionStats&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;executionSuccess&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;nReturned&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;executionTimeMillis&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;totalKeysExamined&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;totalDocsExamined&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;executionStages&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;stage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;FETCH&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;nReturned&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;executionTimeMillisEstimate&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;works&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;advanced&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;needTime&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;needFetch&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;saveState&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;restoreState&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;isEOF&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;docsExamined&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;alreadyHasObj&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;inputStage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;stage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;IXSCAN&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;nReturned&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;executionTimeMillisEstimate&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;works&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;advanced&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;needTime&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;needFetch&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;saveState&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;restoreState&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;isEOF&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;keyPattern&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;a&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;indexName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;a_1&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;isMultiKey&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;multiKeyPaths&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;a&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;isUnique&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;isSparse&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;isPartial&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;indexVersion&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;direction&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;forward&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;indexBounds&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;a&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-string">&quot;(1.0, 2.0)&quot;</span><br>          <span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;keysExamined&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;seeks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;dupsTested&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;dupsDropped&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;seenInvalidated&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;serverInfo&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;localhost&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">27017</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;4.2.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;gitVersion&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2b62a68cfa4efae44c9a66b09a38df7e48fdbe73&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>通过分析 explain 输出，你可以了解查询是如何执行的，并据此优化索引和查询语句。</p><h2 id="2-ExecutionStats中的时间分析"><a href="#2-ExecutionStats中的时间分析" class="headerlink" title="2 ExecutionStats中的时间分析"></a>2 ExecutionStats中的时间分析</h2><p>在 MongoDB 的 explain 输出中，executionStats 部分包含了查询的执行统计信息。其中包括执行评估时间（executionTimeMillisEstimate）和实际执行时间（executionTimeMillis）。这两个时间指标有不同的含义和用途：</p><ul><li>executionTimeMillisEstimate：<ul><li>含义：执行评估时间（或执行时间估计）。</li><li>作用：这是对特定阶段或步骤的执行时间的估计值。这个值是由 MongoDB 查询引擎内部计算得出的，用于提供一个大致的时间估计，帮助了解查询各个阶段所消耗的时间。</li><li>使用场景：在分析查询计划中各个阶段的性能时，executionTimeMillisEstimate 可以帮助确定每个阶段的大致执行时间，从而识别可能的性能瓶颈。</li></ul></li><li>executionTimeMillis：<ul><li>含义：实际执行时间。</li><li>作用：这是查询从开始到结束实际花费的时间，以毫秒为单位。这个时间包括整个查询执行过程中的所有步骤和阶段。</li><li>使用场景：executionTimeMillis 提供了查询的总体执行时间，用于衡量查询的整体性能。</li></ul></li></ul><p>假设有以下 explain 输出：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;executionStats&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;executionSuccess&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;nReturned&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;executionTimeMillis&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">5</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;totalKeysExamined&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;totalDocsExamined&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;executionStages&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;stage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;FETCH&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;nReturned&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;executionTimeMillisEstimate&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;works&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;advanced&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;needTime&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;needFetch&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;saveState&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;restoreState&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;isEOF&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;docsExamined&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;alreadyHasObj&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;inputStage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;stage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;IXSCAN&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;nReturned&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;executionTimeMillisEstimate&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;works&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;advanced&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;needTime&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;needFetch&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;saveState&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;restoreState&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;isEOF&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;keyPattern&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;a&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;indexName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;a_1&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;isMultiKey&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;multiKeyPaths&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;a&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;isUnique&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;isSparse&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;isPartial&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;indexVersion&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;direction&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;forward&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;indexBounds&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;a&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-string">&quot;(1.0, 2.0)&quot;</span><br>          <span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;keysExamined&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;seeks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;dupsTested&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;dupsDropped&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;seenInvalidated&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li>executionTimeMillis：整个查询实际执行时间为 5 毫秒。</li><li>executionTimeMillisEstimate（FETCH 阶段）：这个阶段的执行时间估计为 2 毫秒。</li><li>executionTimeMillisEstimate（IXSCAN 阶段）：这个阶段的执行时间估计为 1 毫秒。</li></ul><p>通过结合这两个时间指标，可以更好地优化查询，改进性能。例如，如果某个阶段的 executionTimeMillisEstimate 特别高，可以考虑优化该阶段的索引或查询逻辑。</p><h2 id="3-WinningPaln中的Stage有哪些"><a href="#3-WinningPaln中的Stage有哪些" class="headerlink" title="3. WinningPaln中的Stage有哪些"></a>3. WinningPaln中的Stage有哪些</h2><p>在 MongoDB 查询计划（explain 输出的 winningPlan 部分）中，查询计划由多个阶段（Stage）组成，每个阶段代表查询执行过程中的一个步骤。主要包括如下类型：</p><ul><li>COLLSCAN（Collection Scan）：<ul><li>扫描整个集合的所有文档，通常是因为没有可用的索引。</li><li>使用场景：没有适用的索引，或者是全表扫描。-</li></ul></li><li>IXSCAN（Index Scan）：<ul><li>扫描索引，查找符合条件的索引条目。</li><li>使用场景：查询条件可以利用索引。</li></ul></li><li>FETCH：<ul><li>从磁盘中读取文档，通常跟在 IXSCAN 之后，通过索引查找后获取实际文档。</li><li>使用场景：通过索引查找后，需要获取完整文档。</li></ul></li><li>LIMIT：<ul><li>限制结果集的数量。</li><li>使用场景：查询中使用 limit 操作。</li></ul></li><li>SKIP：<ul><li>跳过结果集中的前若干个文档。</li><li>使用场景：查询中使用 skip 操作。</li></ul></li><li>SORT：<ul><li>对结果集进行排序。</li><li>使用场景：查询中使用 sort 操作。</li></ul></li><li>PROJECTION：<ul><li>对结果集进行字段投影，只返回指定的字段。</li><li>使用场景：查询中使用字段选择器。</li></ul></li><li>SHARD_MERGE：<ul><li>从多个分片中合并结果集。</li><li>使用场景：在分片集群环境中，跨分片查询。</li></ul></li><li>TEXT：<ul><li>执行全文搜索查询。</li><li>使用场景：查询中使用 $text 操作符。</li></ul></li><li>GEO_NEAR：<ul><li>执行地理位置查询，查找距离某点最近的文档。</li><li>使用场景：查询中使用 $near 或 $geoNear 操作符。</li></ul></li><li>GROUP：<ul><li>执行分组操作，类似于 SQL 的 GROUP BY。</li><li>使用场景：查询中使用聚合管道中的 $group 操作符。</li></ul></li><li>UNWIND：<ul><li>拆分数组字段，将每个数组元素作为单独的文档。</li><li>使用场景：查询中使用聚合管道中的 $unwind 操作符。</li></ul></li><li>LOOKUP：<ul><li>执行联表查询，将一个集合中的文档与另一个集合中的文档进行连接。</li><li>使用场景：查询中使用聚合管道中的 $lookup 操作符。</li></ul></li><li>REDUCE：<ul><li>在 MapReduce 操作中，执行 reduce 阶段。</li><li>使用场景：使用 MapReduce 执行复杂聚合操作。</li></ul></li></ul><p>假设有一个集合 myCollection，使用以下查询并结合 explain 查看查询计划：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.myCollection.find(&#123; a: &#123; $gt: <span class="hljs-number">1</span>, $lt: <span class="hljs-number">2</span> &#125; &#125;).sort(&#123; b: <span class="hljs-number">-1</span> &#125;).limit(<span class="hljs-number">5</span>).explain()<br></code></pre></td></tr></table></figure><p>得到的 explain 输出可能包含以下阶段：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;queryPlanner&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;winningPlan&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;stage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;LIMIT&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;limitAmount&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">5</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;inputStage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;stage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;SORT&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;sortPattern&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;b&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">-1</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;inputStage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;stage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;FETCH&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;inputStage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;stage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;IXSCAN&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;keyPattern&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;a&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;indexName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;a_1&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;isMultiKey&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;direction&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;forward&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;indexBounds&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;a&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;(1.0, 2.0)&quot;</span><br>              <span class="hljs-punctuation">]</span><br>            <span class="hljs-punctuation">&#125;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>LIMIT 阶段：限制结果集数量为 5。</li><li>SORT 阶段：按 b 字段进行降序排序。</li><li>FETCH 阶段：通过索引查找后，从磁盘中读取完整文档。</li><li>IXSCAN 阶段：扫描 a_1 索引，查找 a 字段在 (1, 2) 范围内的索引条目。</li></ul><p>通过理解这些阶段，可以更好地分析和优化查询性能。例如，确保查询尽可能利用索引，减少全表扫描（COLLSCAN）。</p>]]></content>
    
    
    <categories>
      
      <category>MongoDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能分析</tag>
      
      <tag>Explain</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang Json Unmarshal 大数精度丢失问题</title>
    <link href="/2024/05/08/Golang-Json-Unmarshal-%E5%A4%A7%E6%95%B0%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/"/>
    <url>/2024/05/08/Golang-Json-Unmarshal-%E5%A4%A7%E6%95%B0%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>在Golang中，使用Unmarshal将一个Json数字解析为<code>interface&#123;&#125;</code>时, int64等大类型数字会存在精度丢失的问题。    </p><p>一般来说，长度超过16位的数字易发生数据截断，而且数据值变成了科学计数法。</p><span id="more"></span>   <h2 id="1-案例介绍"><a href="#1-案例介绍" class="headerlink" title="1. 案例介绍"></a>1. 案例介绍</h2><p>假设有一个长度为17的json大数字</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">var</span> str = <span class="hljs-string">`&#123;&quot;id&quot;:10000649949036001&#125;`</span><br></code></pre></td></tr></table></figure><p>如果直接使用json的interface进行解析, 会得到 10000649949036000, 而不是我们想要的10000649949036001 </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ParseWithInterface</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> test <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;<br><br><span class="hljs-keyword">if</span> err := json.Unmarshal([]<span class="hljs-type">byte</span>(str), &amp;test); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br><br>fmt.Println(test)<br><br>dataBytes, err := json.Marshal(test)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%+s\n&quot;</span>, <span class="hljs-type">string</span>(dataBytes))<br>&#125;<br><br><span class="hljs-comment">// 输出</span><br><span class="hljs-comment">// map[id:1.0000649949036e+16]</span><br><span class="hljs-comment">// &#123;&quot;id&quot;:10000649949036000&#125;  </span><br><br></code></pre></td></tr></table></figure><h2 id="2-原因分析"><a href="#2-原因分析" class="headerlink" title="2. 原因分析"></a>2. 原因分析</h2><p>原因就出在了interface{}上，在golang中，当数据结构未知，使用map[string]interface{}接收反序列化结果时，会使用float64来进行结果解析，而float类型在处理的过程中时会有精度丢失的，一般超过16位就会发生，同时float64在处理的数据的时候，一般超过6位就会变成科学记数法。使用float64对json number进行解析可以在json的官方代码中找到。</p><blockquote><p>&#x2F;&#x2F; To unmarshal JSON into an interface value,<br>&#x2F;&#x2F; Unmarshal stores one of these in the interface value:<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;bool, for JSON booleans<br>&#x2F;&#x2F;float64, for JSON numbers<br>&#x2F;&#x2F;string, for JSON strings<br>&#x2F;&#x2F;[]interface{}, for JSON arrays<br>&#x2F;&#x2F;map[string]interface{}, for JSON objects<br>&#x2F;&#x2F;nil for JSON null</p></blockquote><h2 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3. 解决方案"></a>3. 解决方案</h2><p>既然上文已经说了int64反序列化精度丢失的原因是使用了float64进行解析，那么我们只需要在解析时强行指定不使用float64解析即可。</p><h3 id="3-1-使用Int64解析"><a href="#3-1-使用Int64解析" class="headerlink" title="3.1 使用Int64解析"></a>3.1 使用Int64解析</h3><p>在知道具体类型的情况下，可以直接定义结构体为map[string]int64, 这样在解析时，就会使用int64进行解析。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ParseWithInt64</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> data <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int64</span><br>str := <span class="hljs-string">`&#123;&quot;id&quot;:10000649949036001&#125;`</span><br>err := json.Unmarshal([]<span class="hljs-type">byte</span>(str), &amp;data)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br><br>fmt.Println(data)<br>&#125;<br><span class="hljs-comment">// 输出</span><br><span class="hljs-comment">// map[id:10000649949036001]</span><br></code></pre></td></tr></table></figure><h3 id="3-2-利用UseNumber"><a href="#3-2-利用UseNumber" class="headerlink" title="3.2 利用UseNumber"></a>3.2 利用UseNumber</h3><p>golang json提供了一种额外的解析方式，可以在解析的过程使用指定使用Number类型而不是float64进行解析，这样就可以避免精度丢失的问题。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// convertNumber converts the number literal s to a float64 or a Number</span><br><span class="hljs-comment">// depending on the setting of d.useNumber.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *decodeState)</span></span> convertNumber(s <span class="hljs-type">string</span>) (any, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> d.useNumber &#123;<br><span class="hljs-keyword">return</span> Number(s), <span class="hljs-literal">nil</span><br>&#125;<br>f, err := strconv.ParseFloat(s, <span class="hljs-number">64</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, &amp;UnmarshalTypeError&#123;Value: <span class="hljs-string">&quot;number &quot;</span> + s, Type: reflect.TypeOf(<span class="hljs-number">0.0</span>), Offset: <span class="hljs-type">int64</span>(d.off)&#125;<br>&#125;<br><span class="hljs-keyword">return</span> f, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ParseUseNumber</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> test <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;<br><br>d := json.NewDecoder(bytes.NewReader([]<span class="hljs-type">byte</span>(str)))<br>d.UseNumber()<br><span class="hljs-keyword">if</span> err := d.Decode(&amp;test); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br><br>fmt.Println(test)<br>&#125;<br><br><span class="hljs-comment">// 输出</span><br><span class="hljs-comment">// map[id:10000649949036001]</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>JSON</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang Empty 切片 vs Nil 切片</title>
    <link href="/2024/04/10/Golang-Empty-Nil-Slice/"/>
    <url>/2024/04/10/Golang-Empty-Nil-Slice/</url>
    
    <content type="html"><![CDATA[<p>切片（Slice），是Golang开发中常用到的一种基础数据结构，和数组比较相似。在日常开发中，经常见到nil切片、空切片和零切片的概念。今天主要分享一下他们之间的区别。</p><span id="more"></span>  <h2 id="1-基本对比"><a href="#1-基本对比" class="headerlink" title="1. 基本对比"></a>1. 基本对比</h2><h3 id="1-1-结论"><a href="#1-1-结论" class="headerlink" title="1.1 结论"></a>1.1 结论</h3><p>empty slice vs nil slice     </p><ul><li>相同点   <ul><li>they both have zero length and capacity,   </li><li>they can be used with the same effect in for loops and append functions,</li><li>and they even look the same when printed.</li></ul></li><li>不同点   <ul><li>nil切片和nil比较的结果是true  </li><li>empty切片和nil比较的结果是false</li></ul></li></ul><h3 id="1-2-nil-切片"><a href="#1-2-nil-切片" class="headerlink" title="1.2 nil 切片"></a>1.2 nil 切片</h3><blockquote><p>nil slice: 长度和容量都为0，并且和nil比较的结果true的切片<br>一般可以通过直接定义变量或者new创建   </p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">var</span> slice1 []<span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> slice2 = *<span class="hljs-built_in">new</span>([]<span class="hljs-type">int</span>)<br>fmt.Println(slice1, <span class="hljs-built_in">len</span>(slice1), <span class="hljs-built_in">cap</span>(slice1), slice1 == <span class="hljs-literal">nil</span>)<br>fmt.Println(slice2, <span class="hljs-built_in">len</span>(slice2), <span class="hljs-built_in">cap</span>(slice2), slice2 == <span class="hljs-literal">nil</span>)  <br><span class="hljs-comment">// [] 0 0 true</span><br><span class="hljs-comment">// [] 0 0 true</span><br></code></pre></td></tr></table></figure><p>可以简单理解为nil切片是只声明但是未初始化的切片。   </p><h3 id="1-3-empty-切片"><a href="#1-3-empty-切片" class="headerlink" title="1.3 empty 切片"></a>1.3 empty 切片</h3><blockquote><p>empty slice: 长度和容量都为0，但是和nil比较的结果为false的切片<br>一般可以通过声明一个长度为0的切片创建  </p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">var</span> slice3 = []<span class="hljs-type">int</span>&#123;&#125;<br><span class="hljs-keyword">var</span> slice4 = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br>fmt.Println(slice3, <span class="hljs-built_in">len</span>(slice3), <span class="hljs-built_in">cap</span>(slice3), slice3 == <span class="hljs-literal">nil</span>)<br>fmt.Println(slice4, <span class="hljs-built_in">len</span>(slice4), <span class="hljs-built_in">cap</span>(slice4), slice4 == <span class="hljs-literal">nil</span>)  <br><span class="hljs-comment">// [] 0 0 false</span><br><span class="hljs-comment">// [] 0 0 false</span><br></code></pre></td></tr></table></figure><p>可以简单理解empty切片是声明后切初始化了长度为0的切片。</p><h3 id="1-4-零-切片"><a href="#1-4-零-切片" class="headerlink" title="1.4 零 切片"></a>1.4 零 切片</h3><blockquote><p>零切片： 叫法不常见，主要是值长度部位0，但是内部数组元素都是零值或者nil的切片<br>使用make创建的长度不为0的初始切片就是零切片  </p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs golang">slice5 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">5</span>)  <span class="hljs-comment">// 0 0 0 0 0</span><br>slice6 := <span class="hljs-built_in">make</span>([]*<span class="hljs-type">int</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// nil nil nil nil nil</span><br>fmt.Println(slice5, <span class="hljs-built_in">len</span>(slice5), <span class="hljs-built_in">cap</span>(slice5), slice5 == <span class="hljs-literal">nil</span>)<br>fmt.Println(slice6, <span class="hljs-built_in">len</span>(slice6), <span class="hljs-built_in">cap</span>(slice6), slice6 == <span class="hljs-literal">nil</span>)<br><span class="hljs-comment">// [0 0 0 0 0] 5 5 false</span><br><span class="hljs-comment">// [nil nil nil nil nil] 5 5 false</span><br></code></pre></td></tr></table></figure><h2 id="2-底层原理"><a href="#2-底层原理" class="headerlink" title="2. 底层原理"></a>2. 底层原理</h2><p>golang的slice底层结构体由3个字段构成：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> slice <span class="hljs-keyword">struct</span>&#123;<br>    ptr unsafe.Pointer <br>    <span class="hljs-built_in">len</span> <span class="hljs-type">int</span> <br>    <span class="hljs-built_in">cap</span> <span class="hljs-type">int</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>其中len和cap分别是切片的长度和容量，而ptr则是指向底层数组的指针。    </p><p>所谓nil切片，就是ptr指向的指针也为nil<br><img src="/img/Golang-Empty-Nil-Slice/1.jpg">     </p><p>可以通过一个小实验验证指针的数据：  </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">var</span> s1 []<span class="hljs-type">int</span>  <br>s2 := []<span class="hljs-type">int</span>&#123;&#125;  <br>s3 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br><br>fmt.Printf(<span class="hljs-string">&quot;s1 (addr: %p): %+8v\n&quot;</span>, &amp;s1, *(*reflect.SliceHeader)(unsafe.Pointer(&amp;s1)))<br>fmt.Printf(<span class="hljs-string">&quot;s2 (addr: %p): %+8v\n&quot;</span>, &amp;s2, *(*reflect.SliceHeader)(unsafe.Pointer(&amp;s2))) <br>fmt.Printf(<span class="hljs-string">&quot;s3 (addr: %p): %+8v\n&quot;</span>, &amp;s3, *(*reflect.SliceHeader)(unsafe.Pointer(&amp;s3))) <br><span class="hljs-comment">// s1 (addr: 0xc0000080d8): &#123;Data:       0 Len:       0 Cap:       0&#125;</span><br><span class="hljs-comment">// s2 (addr: 0xc0000080f0): &#123;Data:12760120 Len:       0 Cap:       0&#125;</span><br><span class="hljs-comment">// s3 (addr: 0xc000008108): &#123;Data:12760120 Len:       0 Cap:       0&#125;</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>Slice</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Golang泛型</title>
    <link href="/2024/03/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3golang%E6%B3%9B%E5%9E%8B/"/>
    <url>/2024/03/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3golang%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>泛型（Generics）是一种编程思想，它允许在编写代码时使用未知的类型。泛型可以增加代码的灵活性和可复用性，同时还能提高代码的安全性和可读性。Go从1.18开始支持泛型的实现并在后续的版本中逐渐完善。</p><span id="more"></span>  <h2 id="1-Golang泛型"><a href="#1-Golang泛型" class="headerlink" title="1. Golang泛型"></a>1. Golang泛型</h2><ul><li>举个栗子, 现在有一个a+b的函数  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>&#123;<br>    <span class="hljs-keyword">return</span> a + b<br>&#125;<br></code></pre></td></tr></table></figure>函数比较简单，一看就是两个int类型的数据相加。现在思考一个问题，在golang泛型出现之前，如果想实现两个float相加该如何处理？一般存在两种方式：</li><li>再写一个函数   <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(a <span class="hljs-type">float64</span>, b <span class="hljs-type">float64</span>)</span></span> <span class="hljs-type">float64</span>&#123;<br>    <span class="hljs-keyword">return</span> a + b<br>&#125; <br></code></pre></td></tr></table></figure></li><li>把函数改造成反射函数  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add</span><span class="hljs-params">(a <span class="hljs-keyword">interface</span>&#123;&#125;, b <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    <span class="hljs-keyword">switch</span> a.(<span class="hljs-keyword">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">int</span>:<br>        <span class="hljs-keyword">return</span> a.(<span class="hljs-type">int</span>) + b.(<span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">float32</span>:<br>        <span class="hljs-keyword">return</span> a.(<span class="hljs-type">float32</span>) + b.(<span class="hljs-type">float32</span>)<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><p>现在golang支持泛型以后，该怎么实现呢？   </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add</span>[<span class="hljs-title">T</span> <span class="hljs-title">int</span> | <span class="hljs-title">float32</span> | <span class="hljs-title">float64</span>]<span class="hljs-params">(a, b T)</span></span> T &#123;<br><span class="hljs-keyword">return</span> a + b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(Add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br>fmt.Println(Add(<span class="hljs-number">1.1</span>, <span class="hljs-number">2.1</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>以上就是golang中最新支持的泛型函数。除了泛型函数外，还支持泛型类型和泛型接口。  </p><ul><li>泛型函数  </li><li>泛型类型  </li><li>泛型接口</li></ul><h2 id="2-泛型基本特性"><a href="#2-泛型基本特性" class="headerlink" title="2. 泛型基本特性"></a>2. 泛型基本特性</h2><p>泛型作为和常规类型不同的区别就在于它可以支持多种类型的参数，所以在定义和使用时也有着两个基本的特性：类型参数和类型约束。<br><img src="/img/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3golang%E6%B3%9B%E5%9E%8B/1.jpg">   </p><h3 id="2-1-类型参数"><a href="#2-1-类型参数" class="headerlink" title="2.1 类型参数"></a>2.1 类型参数</h3><ul><li>类型参数是泛型函数或类型的一个占位符，表示一个未知的类型。  </li><li>类型参数列表出现在常规参数之前。为了区分类型参数列表和常规参数列表，类型参数列表使用方括号[]而不是圆括号()</li></ul><h3 id="2-2-类型约束"><a href="#2-2-类型约束" class="headerlink" title="2.2 类型约束"></a>2.2 类型约束</h3><p>在使用泛型时，有时需要对泛型类型进行一定的约束。例如，我们希望某个泛型函数或类型只能接受特定类型的参数，或者特定类型的参数必须实现某个接口。在 Go 中，可以使用泛型约束来实现这些需求。   </p><p>如上图所示，T就是该泛型函数的参数，any就是参数的类型，达标任意类型即可。   </p><p>对于泛型类型的约束方法，常见的方式有如下几种：  </p><h4 id="2-2-1-常规类型约束"><a href="#2-2-1-常规类型约束" class="headerlink" title="2.2.1 常规类型约束"></a>2.2.1 常规类型约束</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add</span>[<span class="hljs-title">T</span> <span class="hljs-title">int</span> | <span class="hljs-title">float32</span> | <span class="hljs-title">float64</span>]<span class="hljs-params">(a, b T)</span></span> T &#123;<br><span class="hljs-keyword">return</span> a + b<br>&#125;<br></code></pre></td></tr></table></figure><p>当前这种类型约束方式简单明了，代表函数可以支持int，float32和float64三种参数的类型。 </p><h4 id="2-2-2-类型集约束"><a href="#2-2-2-类型集约束" class="headerlink" title="2.2.2 类型集约束"></a>2.2.2 类型集约束</h4><p>类型集表示一堆类型的集合，用来在泛型函数的声明中约束类型参数的范围. 如果需要支持的类型比较多，可以写在类型集中。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// 一堆类型的集合，用来在范型函数的声明中约束类型参数的范围</span><br><span class="hljs-keyword">type</span> numbers <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-type">int</span> | <span class="hljs-type">int32</span> | <span class="hljs-type">uint32</span> | <span class="hljs-type">int64</span> | <span class="hljs-type">uint64</span> | <span class="hljs-type">float32</span> | <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-comment">// 约束T可以为number中的任一个元素</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sub</span>[<span class="hljs-title">T</span> <span class="hljs-title">numbers</span>]<span class="hljs-params">(a, b T)</span></span> T &#123;<br><span class="hljs-keyword">return</span> a - b<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-3-联合约束元素"><a href="#2-2-3-联合约束元素" class="headerlink" title="2.2.3 联合约束元素"></a>2.2.3 联合约束元素</h4><p>联合元素，写成一系列由竖线 ( |) 分隔的约束元素。例如：int | float32或~int8 | ~int16 | ~int32 | ~int64  </p><ul><li>~int 代表所有int的衍生类型，比如自定义的别名；type myInt int; myInt就是 ~int类型。</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> Integer <span class="hljs-keyword">interface</span> &#123;<br>~<span class="hljs-type">int</span> | ~<span class="hljs-type">int8</span> | ~<span class="hljs-type">int16</span> | ~<span class="hljs-type">int32</span> | ~<span class="hljs-type">int64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AddInteger</span>[<span class="hljs-title">T</span> <span class="hljs-title">Integer</span>]<span class="hljs-params">(a, b T)</span></span> T &#123;<br><span class="hljs-keyword">return</span> a + b<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-4-推荐写法"><a href="#2-2-4-推荐写法" class="headerlink" title="2.2.4 推荐写法"></a>2.2.4 推荐写法</h4><p>在使用类型推荐时，尽量将类型限制在最简单的基本类型中，比如同样是类型T的数组。 </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// 推荐</span><br><span class="hljs-keyword">type</span> Student1[T <span class="hljs-type">int</span> | <span class="hljs-type">string</span>] <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>Data []T<br>&#125;<br><br><span class="hljs-keyword">type</span> Student2[T []<span class="hljs-type">int</span> | []<span class="hljs-type">string</span>] <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>Data T<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-泛型实践"><a href="#3-泛型实践" class="headerlink" title="3. 泛型实践"></a>3. 泛型实践</h2><p>Golang 泛型可以应用于各种数据结构和算法，例如排序、搜索、映射等；也可使用泛型类型实现一些通用的数据结构。</p><h3 id="3-1-工具函数"><a href="#3-1-工具函数" class="headerlink" title="3.1 工具函数"></a>3.1 工具函数</h3><ul><li>排序<br>在 Golang 中，使用 sort 包可以对任意类型的切片进行排序。  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sort</span>[<span class="hljs-title">T</span> <span class="hljs-title">int</span> | <span class="hljs-title">int32</span> | <span class="hljs-title">float32</span>]<span class="hljs-params">(s []T)</span></span> &#123;<br>sort.Slice(s, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> s[i] &lt; s[j]<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li><li>搜索<br>在 Golang 中，使用 search 包可以对任意类型的切片进行搜索.   <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Search</span>[<span class="hljs-title">T</span> <span class="hljs-title">int</span> | <span class="hljs-title">int32</span> | <span class="hljs-title">int64</span>]<span class="hljs-params">(s []T, x T)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> sort.Search(<span class="hljs-built_in">len</span>(s), <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> s[i] &gt;= x<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li><li>映射<br>在 Golang 中，使用 map 类型可以实现映射。为了支持泛型映射，我们可以定义一个泛型函数 Map[K comparable, V any]，如下所示：  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Map</span>[<span class="hljs-title">K</span> <span class="hljs-title">comparable</span>, <span class="hljs-title">V</span> <span class="hljs-title">any</span>]<span class="hljs-params">(s []K, f <span class="hljs-keyword">func</span>(K)</span></span> V) <span class="hljs-keyword">map</span>[K]V &#123;<br>result := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[K]V)<br><span class="hljs-keyword">for</span> _, k := <span class="hljs-keyword">range</span> s &#123;<br>result[k] = f(k)<br>&#125;<br><span class="hljs-keyword">return</span> result<br>&#125;  <br><br>words := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>, <span class="hljs-string">&quot;durian&quot;</span>, <span class="hljs-string">&quot;elderberry&quot;</span>, <span class="hljs-string">&quot;fig&quot;</span>&#125;<br>uppercased := generics.Map(words, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(word <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> strings.ToUpper(word)<br>&#125;)<br>fmt.Println(uppercased)<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-2-数据结构"><a href="#3-2-数据结构" class="headerlink" title="3.2 数据结构"></a>3.2 数据结构</h3><p>简单的实现一个基于泛型的队列。  </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// Queue - 队列</span><br><span class="hljs-keyword">type</span> Queue[T any] <span class="hljs-keyword">struct</span> &#123;<br>items []T<br>&#125;<br><br><span class="hljs-comment">// Put 将数据放入队列尾部</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue[T])</span></span> Put(value T) &#123;<br>q.items = <span class="hljs-built_in">append</span>(q.items, value)<br>&#125;<br><br><span class="hljs-comment">// Pop 从队列头部取出并从头部删除对应数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue[T])</span></span> Pop() (T, <span class="hljs-type">bool</span>) &#123;<br><span class="hljs-keyword">var</span> value T<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(q.items) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> value, <span class="hljs-literal">true</span><br>&#125;<br><br>value = q.items[<span class="hljs-number">0</span>]<br>q.items = q.items[<span class="hljs-number">1</span>:]<br><span class="hljs-keyword">return</span> value, <span class="hljs-built_in">len</span>(q.items) == <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-comment">// Size 队列大小</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q Queue[T])</span></span> Size() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(q.items)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-接口"><a href="#4-接口" class="headerlink" title="4. 接口"></a>4. 接口</h2><ul><li>在泛型出来之前，接口的定义是：接口是一个方法集   <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> <span class="hljs-type">error</span> <span class="hljs-keyword">interface</span>&#123;<br>Error() <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>在泛型出来之后，接口的定义是：接口是一个类型集  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> number <span class="hljs-keyword">interface</span>&#123;<br><span class="hljs-type">int</span> | <span class="hljs-type">float32</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-1-并集、交集、空集"><a href="#4-1-并集、交集、空集" class="headerlink" title="4.1 并集、交集、空集"></a>4.1 并集、交集、空集</h3><ul><li>并集：使用|连接的就是并集      <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// number 是下列基础类型的并集</span><br><span class="hljs-keyword">type</span> number <span class="hljs-keyword">interface</span>&#123;<br><span class="hljs-type">int</span> | <span class="hljs-type">int32</span> | <span class="hljs-type">uint32</span> | <span class="hljs-type">int64</span> | <span class="hljs-type">uint64</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>交集：如果一个接口的定义包含多行类型，就取他们的交集。  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> Int <span class="hljs-keyword">interface</span> &#123;<br>    <span class="hljs-type">int</span> | <span class="hljs-type">int8</span> | <span class="hljs-type">int16</span> | <span class="hljs-type">int32</span> | <span class="hljs-type">int64</span> | <span class="hljs-type">uint</span> | <span class="hljs-type">uint8</span> | <span class="hljs-type">uint16</span> | <span class="hljs-type">uint32</span> | <span class="hljs-type">uint64</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Uint <span class="hljs-keyword">interface</span> &#123;<br>    <span class="hljs-type">uint</span> | <span class="hljs-type">uint8</span> | <span class="hljs-type">uint16</span> | <span class="hljs-type">uint32</span> | <span class="hljs-type">uint64</span><br>&#125;<br><br><span class="hljs-comment">// 接口Status代表 Int和Uint的交集</span><br><span class="hljs-keyword">type</span> Status <span class="hljs-keyword">interface</span> &#123;  <br>    Int<br>    Uint<br>&#125;<br></code></pre></td></tr></table></figure></li><li>空集：如果多行类型没有交集，就是空集.    <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// 类型 ~int 和 ~float 没有相交的类型，所以接口 Bad 代表的类型集为空</span><br><span class="hljs-keyword">type</span> Bad <span class="hljs-keyword">interface</span> &#123;<br>    ~<span class="hljs-type">int</span><br>    ~float <br>&#125; <br></code></pre></td></tr></table></figure></li></ul><h3 id="4-2-接口类型"><a href="#4-2-接口类型" class="headerlink" title="4.2 接口类型"></a>4.2 接口类型</h3><ul><li>基本接口: 接口的定义中只有方法    <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// 接口中只有方法，所以是基本接口</span><br><span class="hljs-keyword">type</span> MyError <span class="hljs-keyword">interface</span> &#123; <br>    Error() <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>一般接口: 接口的定义中不仅有方法，还有类型    <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// 接口 Uint 中有类型，所以是一般接口</span><br><span class="hljs-keyword">type</span> Uint <span class="hljs-keyword">interface</span> &#123; <br>    ~<span class="hljs-type">uint</span> | ~<span class="hljs-type">uint8</span> | ~<span class="hljs-type">uint16</span> | ~<span class="hljs-type">uint32</span> | ~<span class="hljs-type">uint64</span><br>&#125;<br><br><span class="hljs-comment">// ReadWriter 接口既有方法也有类型，所以是一般接口</span><br><span class="hljs-keyword">type</span> ReadWriter <span class="hljs-keyword">interface</span> &#123;  <br>    ~<span class="hljs-type">string</span> | ~[]<span class="hljs-type">rune</span><br><br>    Read(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br>    Write(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br>&#125;<br><br><span class="hljs-comment">// 一般接口类型不能用来定义变量，只能用于泛型的类型约束中  </span><br><br><span class="hljs-comment">// 错误。Uint是一般接口，只能用于类型约束，不得用于变量定义</span><br><span class="hljs-keyword">var</span> uintInf Uint   <br></code></pre></td></tr></table></figure></li><li>如何实现一般接口？ <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// 先定义一个具体的类型，然后再实现具体的方法 </span><br><br><span class="hljs-comment">// StringReadWriter 实现了接口 ReadWriter</span><br><span class="hljs-keyword">type</span> StringReadWriter <span class="hljs-type">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s StringReadWriter)</span></span> Read(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s StringReadWriter)</span></span> Write(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5. 参考资料"></a>5. 参考资料</h2><ul><li><a href="https://www.kunkkawu.com/archives/shen-ru-li-jie-golang-de-fan-xing">https://www.kunkkawu.com/archives/shen-ru-li-jie-golang-de-fan-xing</a>  </li><li><a href="https://juejin.cn/post/7229462763947917367">https://juejin.cn/post/7229462763947917367</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>泛型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB复合索引的ESR原则</title>
    <link href="/2024/02/21/MongoDB%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84ESR%E5%8E%9F%E5%88%99/"/>
    <url>/2024/02/21/MongoDB%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84ESR%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<p>提到索引，大家都不会陌生，它的重要性在数据库中不言而喻。常见的存储如MysQL，MongoDB都支持多种类型的索引。本文主要以实际工作中碰到的例子聊一下MongoDB中的复合索引。</p><span id="more"></span>  <p>所谓复合索引，就是包含多个字段的索引，比如index(a,b)。复合索引在使用的过程中主要有两个原则： </p><ul><li>最左匹配原则 </li><li>ESR原则</li></ul><h3 id="1-最左匹配原则"><a href="#1-最左匹配原则" class="headerlink" title="1. 最左匹配原则"></a>1. 最左匹配原则</h3><p>最左匹配原则比较好理解，他和MySQL中的最左匹配原则一致，即最左优先：在检索数据时从复合索引的最左边开始匹配。</p><p>复合索引创建时一个基本的原则就是：将选择性最强的列放到最前面。</p><p>选择性最高指的是数据的重复值最少，因为区分度高的列能够很容易过滤掉很多的数据。如果组合索引中第一次能够过滤掉很多的数据，后面的索引查询的数据范围就小了很多了。</p><h3 id="2-ESR原则"><a href="#2-ESR原则" class="headerlink" title="2. ESR原则"></a>2. ESR原则</h3><p><a href="https://www.mongodb.com/docs/manual/tutorial/equality-sort-range-rule/">The ESR (Equality, Sort, Range) Rules</a> </p><p>简单来说就是我们在构建复合索引时，需要根据以下三项原则的顺序进行构建：  </p><ul><li>等值查询字段放在最前面</li><li>中间放排序字段</li><li>最后是范围查询字段</li></ul><p>E 放在前面比较好理解，等值匹配过滤掉大量数据，「那为什么是 ESR 不是 ERS 呢?」<br><img src="/img/MongoDB%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84ESR%E5%8E%9F%E5%88%99/1.png"><br>如图所示，如果把范围匹配放在中间，那么后续我们排序的时候只能进行「内存排序」，内存排序是比较消耗资源的，数据量大时可能会面临着「多次的磁盘读取刷内存操作」，对性能影响比较显著。</p><h3 id="3-实际案例分析"><a href="#3-实际案例分析" class="headerlink" title="3. 实际案例分析"></a>3. 实际案例分析</h3><p>以上两个原则看起来比较简单，但笔者在实际应用中还是踩了一些坑。</p><p>我有一个这样的mongo集合： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Demo <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// QueueID 队列id</span><br>QueueID <span class="hljs-type">string</span> <span class="hljs-string">`bson:&quot;queue_id,omitempty&quot;`</span><br><br><span class="hljs-comment">// Status 任务状态</span><br>Status <span class="hljs-type">int</span> <span class="hljs-string">`bson:&quot;status,omitempty&quot;`</span><br><br><span class="hljs-comment">// UpdateTime 更新时间</span><br>UpdateTime time.Time <span class="hljs-string">`bson:&quot;update_time,omitempty&quot;`</span><br><br><span class="hljs-comment">// 其他字段</span><br>xxxxx<br><br>&#125; <br></code></pre></td></tr></table></figure><p>mongo在查询时需要执行类似如下条件的查询：</p><pre><code class="go">db.collections.find(&#123; queue_id: 123, status: &#123; $in: [1, 2, 3] &#125; &#125;).sort(&#123; updateTime: 1 &#125;).limit(1)</code></pre><p>即：查询指定queue_id, 指定status范围，并按照updateTime进行升序的一条记录。   </p><p>在初步了解ESR原则后，我一想，这不就是queue_id为等值查询、updateTime为排序查询、status为范围查询的经典情况吗，大手一挥就创建了一个（queue_id, updateTime, status）的复合索引并愉快的上线了。</p><p>然而待数据量增大后，发现一个比较严重的问题，Mongo实例的CPU飙到了60%，排查原因发现索引执行不太正常。</p><p>参考官方资料后，发现in在执行的时候，可能是等值查询也可能是范围查询<br><img src="/img/MongoDB%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84ESR%E5%8E%9F%E5%88%99/2.png">    </p><ul><li>如果in单独使用，就是等值查询</li><li>如果in和sort一起使用，就是范围查询（针对同一个字段）</li></ul><p>所以在本例中，status的使用是等值查询，应该放在updateTime的前面，将索引修改为（queue_id, status, updateTime）后，CPU使用率即刻下降到30%左右。</p>]]></content>
    
    
    <categories>
      
      <category>MongoDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MongoDB</tag>
      
      <tag>索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka高性能分析</title>
    <link href="/2024/02/17/kafka%E9%AB%98%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    <url>/2024/02/17/kafka%E9%AB%98%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Kafka</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kafka</tag>
      
      <tag>高可用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka高可用分析</title>
    <link href="/2024/02/17/kafka%E9%AB%98%E5%8F%AF%E7%94%A8%E5%88%86%E6%9E%90/"/>
    <url>/2024/02/17/kafka%E9%AB%98%E5%8F%AF%E7%94%A8%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Kafka</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kafka</tag>
      
      <tag>高可用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang限流器</title>
    <link href="/2024/01/07/Golang%E9%99%90%E6%B5%81/"/>
    <url>/2024/01/07/Golang%E9%99%90%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<p>在高并发业务场景下，保护系统时，常用的”三板斧”有：”熔断、降级和限流”。本文主要记录golang中常用的限流算法的实现方式。这里所说的限流并非是网关层面或者服务调度之间的限流，而是业务代码中的逻辑限流。</p><span id="more"></span>   <p>限流算法常用的几种实现方式有如下四种：</p><ul><li>计数器</li><li>滑动窗口</li><li>漏桶</li><li>令牌桶</li></ul><h2 id="1-计数器"><a href="#1-计数器" class="headerlink" title="1. 计数器"></a>1. 计数器</h2><h3 id="1-1-原理"><a href="#1-1-原理" class="headerlink" title="1.1 原理"></a>1.1 原理</h3><p>计数器是一种最简单限流算法，其原理就是：<strong>在一段时间间隔内，对请求进行计数，与阀值进行比较判断是否需要限流，一旦到了时间临界点，将计数器清零。</strong></p><ul><li>可以在程序中设置一个变量 count，当过来一个请求我就将这个数 +1，同时记录请求时间。</li><li>当下一个请求来的时候判断 count 的计数值是否超过设定的频次，以及当前请求的时间和第一次请求时间是否在 1 分钟内。</li><li>如果在 1 分钟内并且超过设定的频次则证明请求过多，后面的请求就拒绝掉。</li><li>如果该请求与第一个请求的间隔时间大于计数周期，且 count 值还在限流范围内，就重置 count。</li></ul><p><img src="/img/Golang%E9%99%90%E6%B5%81/1.png"> </p><h3 id="1-2-缺点"><a href="#1-2-缺点" class="headerlink" title="1.2 缺点"></a>1.2 缺点</h3><p>计数器算法存在“时间临界点”缺陷。比如每一分钟限制200个请求，可以在00:00:00-00:00:58秒里面都没有请求，在00:00:59瞬间发送200个请求，这个对于计数器算法来是允许的，然后在00:01:00再次发送200个请求，意味着在短短1s内发送了400个请求，如果量更大呢，系统可能会承受不住瞬间流量，导致系统崩溃。<br><img src="/img/Golang%E9%99%90%E6%B5%81/2.png"></p><h2 id="2-滑动窗口"><a href="#2-滑动窗口" class="headerlink" title="2. 滑动窗口"></a>2. 滑动窗口</h2><h3 id="2-1-原理"><a href="#2-1-原理" class="headerlink" title="2.1 原理"></a>2.1 原理</h3><p>滑动窗口算法将一个大的时间窗口分成多个小窗口，每次大窗口向后滑动一个小窗口，并保证大的窗口内流量不会超出最大值，这种实现比固定窗口的流量曲线更加平滑。</p><p>普通时间窗口有一个问题，比如窗口期内请求的上限是200，假设有200个请求集中在前1s的后100ms，200个请求集中在后1s的前100ms，其实在这200ms内就已经请求超限了，但是由于时间窗每经过1s就会重置计数，就无法识别到这种请求超限。</p><p><img src="/img/Golang%E9%99%90%E6%B5%81/3.png"><br>对于滑动时间窗口，我们可以把1ms的时间窗口划分成一些小窗口，上图中我们用红色的虚线代表一个时间窗口（一分钟），每个时间窗口有 6 个格子，每个格子是 10 秒钟。每过 10 秒钟时间窗口向右移动一格，可以看红色箭头的方向。我们为每个格子都设置一个独立的计数器 Counter，假如一个请求在 0:45 访问了那么我们将第五个格子的计数器 +1（也是就是 0:40~0:50），在判断限流的时候需要把所有格子的计数加起来和设定的频次进行比较即可。   </p><p>当用户在0:59 秒钟发送了 200 个请求就会被第六个格子的计数器记录 +200，当下一秒的时候时间窗口向右移动了一个，此时计数器已经记录了该用户发送的 200 个请求，所以再发送的话就会触发限流，则拒绝新的请求。 </p><h3 id="2-2-缺点"><a href="#2-2-缺点" class="headerlink" title="2.2 缺点"></a>2.2 缺点</h3><p>滑动窗口算法是计数器算法的一种改进[计数器就是只有一个格子的滑动窗口]，但从根本上并没有真正解决固定窗口算法的临界突发流量问题。想让限流做的更精确只能划分更多的格子。</p><h2 id="3-漏桶算法"><a href="#3-漏桶算法" class="headerlink" title="3. 漏桶算法"></a>3. 漏桶算法</h2><h3 id="3-1-原理"><a href="#3-1-原理" class="headerlink" title="3.1 原理"></a>3.1 原理</h3><p>漏桶算法是首先想象有一个木桶，桶的容量是固定的。当有请求到来时先放到木桶中，处理请求的worker以固定的速度从木桶中取出请求进行相应。如果木桶已经满了，直接返回请求频率超限的错误码或者页面。   </p><p>漏桶算法是流量最均匀的限流实现方式，一般用于流量“整形”。例如保护数据库的限流，先把对数据库的访问加入到木桶中，worker再以db能够承受的qps从木桶中取出请求，去访问数据库。<br><img src="/img/Golang%E9%99%90%E6%B5%81/4.png">    </p><h3 id="3-2-缺点"><a href="#3-2-缺点" class="headerlink" title="3.2 缺点"></a>3.2 缺点</h3><p>木桶流入请求的速率是不固定的，但是流出的速率是恒定的。这样的话能保护系统资源不被打满，但是面对突发流量时会有大量请求失败，不适合电商抢购和微博出现热点事件等场景的限流。  </p><h2 id="4-令牌桶算法"><a href="#4-令牌桶算法" class="headerlink" title="4. 令牌桶算法"></a>4. 令牌桶算法</h2><h3 id="4-1-原理"><a href="#4-1-原理" class="headerlink" title="4.1 原理"></a>4.1 原理</h3><p>令牌桶是反向的”漏桶”，它是以恒定的速度往木桶里加入令牌，木桶满了则不再加入令牌。服务收到请求时尝试从木桶中取出一个令牌，如果能够得到令牌则继续执行后续的业务逻辑。如果没有得到令牌，直接返回访问频率超限的错误码或页面等，不继续执行后续的业务逻辑。</p><p>特点：由于木桶内只要有令牌，请求就可以被处理，所以令牌桶算法可以支持突发流量<br><img src="/img/Golang%E9%99%90%E6%B5%81/0.png">      </p><p>同时由于往木桶添加令牌的速度是恒定的，且木桶的容量有上限，所以单位时间内处理的请求书也能够得到控制，起到限流的目的。假设加入令牌的速度为 1 token&#x2F;10ms，桶的容量为500，在请求比较的少的时候（小于每10毫秒1个请求）时，木桶可以先”攒”一些令牌（最多500个）。当有突发流量时，一下把木桶内的令牌取空，也就是有500个在并发执行的业务逻辑，之后要等每10ms补充一个新的令牌才能接收一个新的请求。</p><h3 id="4-2-适用场景"><a href="#4-2-适用场景" class="headerlink" title="4.2 适用场景"></a>4.2 适用场景</h3><p>适合电商抢购或者微博出现热点事件这种场景，因为在限流的同时可以应对一定的突发流量。如果采用漏桶那样的均匀速度处理请求的算法，在发生热点时间的时候，会造成大量的用户无法访问，对用户体验的损害比较大。 </p><h3 id="4-3-实现"><a href="#4-3-实现" class="headerlink" title="4.3 实现"></a>4.3 实现</h3><p>golang官方实现了令牌桶限流方法<code>Limiter</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Limiter <span class="hljs-keyword">struct</span> &#123;<br>mu     sync.Mutex<br>limit  Limit<br>burst  <span class="hljs-type">int</span> <span class="hljs-comment">// 令牌桶的大小</span><br>tokens <span class="hljs-type">float64</span><br>last time.Time <span class="hljs-comment">// 上次更新tokens的时间</span><br>lastEvent time.Time <span class="hljs-comment">// 上次发生限速器事件的时间（通过或者限制都是限速器事件）</span><br>&#125; <br></code></pre></td></tr></table></figure><p>其主要字段的作用是：  </p><ul><li>limit：limit字段表示往桶里放Token的速率，它的类型是Limit，是int64的类型别名。设置limit时既可以用数字指定每秒向桶中放多少个Token，也可以指定向桶中放Token的时间间隔，其实指定了每秒放Token的个数后就能计算出放每个Token的时间间隔了。</li><li>burst: 令牌桶的大小。</li><li>tokens: 桶中的令牌。</li><li>last: 上次往桶中放 Token 的时间。</li><li>lastEvent：上次发生限速器事件的时间（通过或者限制都是限速器事件）</li></ul><h4 id="4-3-1-构造限流器"><a href="#4-3-1-构造限流器" class="headerlink" title="4.3.1 构造限流器"></a>4.3.1 构造限流器</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">limiter := rate.NewLimiter(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure><p>这里有两个参数：</p><ul><li>第一个参数是 r Limit，设置的是限流器Limiter的limit字段，代表每秒可以向 Token 桶中产生多少 token。Limit 实际上是 float64 的别名。</li><li>第二个参数是 b int，b 代表 Token 桶的容量大小，也就是设置的限流器 Limiter 的burst字段。</li></ul><p>那么，对于以上例子来说，其构造出的限流器的令牌桶大小为 100, 以每秒 10 个 Token 的速率向桶中放置 Token。</p><h4 id="4-3-2-使用限流器"><a href="#4-3-2-使用限流器" class="headerlink" title="4.3.2 使用限流器"></a>4.3.2 使用限流器</h4><p>Limiter 提供了三类方法供程序消费 Token，可以每次消费一个 Token，也可以一次性消费多个 Token。 每种方法代表了当 Token 不足时，各自不同的对应手段，可以阻塞等待桶中Token补充，也可以直接返回取Token失败。   </p><p>其中比较常见的是Wait&#x2F;WaitN方法 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lim *Limiter)</span></span> Wait(ctx context.Context) (err <span class="hljs-type">error</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lim *Limiter)</span></span> WaitN(ctx context.Context, n <span class="hljs-type">int</span>) (err <span class="hljs-type">error</span>)<br></code></pre></td></tr></table></figure><p>Wait 实际上就是 WaitN(ctx,1)。   </p><p>当使用 Wait 方法消费 Token 时，如果此时桶内 Token 数组不足 (小于 N)，那么 Wait 方法将会阻塞一段时间，直至 Token 满足条件。如果充足则直接返回。  </p><p>这里可以看到，Wait 方法有一个 context 参数。我们可以设置 context 的 Deadline 或者 Timeout，来决定此次 Wait 的最长时间。     </p><p>其他还有两种用法分别如下，具体使用方法可查阅官方文档信息</p><ul><li>Allow&#x2F;AllowN </li><li>Reserve&#x2F;ReserverN</li></ul>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>限流器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis分布式锁</title>
    <link href="/2023/12/23/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <url>/2023/12/23/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    
    <content type="html"><![CDATA[<p>分布式锁，就是控制分布式系统不同进程共同访问共享资源的一种锁的实现。如果不同的系统或同一个系统的不同主机之间共享了某个临界资源，往往需要互斥来防止彼此干扰，以保证一致性。 </p><span id="more"></span>   <h2 id="Redis分布式锁的实现方式"><a href="#Redis分布式锁的实现方式" class="headerlink" title="Redis分布式锁的实现方式"></a>Redis分布式锁的实现方式</h2><blockquote><p>在线redis环境：<a href="https://try.redis.io/">https://try.redis.io/</a>   </p></blockquote><h3 id="1-什么是分布式锁"><a href="#1-什么是分布式锁" class="headerlink" title="1. 什么是分布式锁"></a>1. 什么是分布式锁</h3><p>分布式锁就是，控制分布式系统不同进程共同访问共享资源的一种锁的实现。如果不同的系统或同一个系统的不同主机之间共享了某个临界资源，往往需要互斥来防止彼此干扰，以保证一致性。<br>分布式锁一般具有以下特征:  </p><ul><li>互斥性：任意时刻只有一个客户端可持有</li><li>超时释放：持有锁超时可以及时释放，防止死锁和不必要的资源浪费  </li><li>可重入性：一个线程获取锁之后，还可以再次对其请求加锁</li><li>高性能高可用：加锁和解锁需要开销尽量低，同时也要保证高可用 </li><li>安全性：锁只能被持有的客户端删除，不能被其他客户端删除</li></ul><!--  --><p><img src="/img/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/1.png"></p><h3 id="2-SETNX"><a href="#2-SETNX" class="headerlink" title="2. SETNX"></a>2. SETNX</h3><p>一提到使用Redis作为分布式锁，大家耳熟能详的就会想到<code>SETNX + EXPIRE</code>。即先用<code>setnx</code>来抢锁，然后再用<code>expire</code>设置一个过期时间。</p><blockquote><p>SETNX是 SET IF NOT EXISTS的简称，顾名思义就是不存在就设置<br>命令使用：SETNX key value<br>如果key不存在，设置成功返回1，如果key已经存在，设置失败返回0</p></blockquote><p>但是直接使用SETNX + EXPIRE 指令，会存在一些问题：</p><ul><li>原子性：setnx 和 exipre是两个命令，如果设置过期时间出错，就会导致长时间持有锁得不到释放。</li><li>误删除问题：假设线程a执行完后，主动去释放锁。但它不知道当前的锁可能是线程b持有的（线程a去释放锁时，有可能过期时间已经到了，此时线程b进来占有了锁）。那线程a就把线程b的锁释放掉了，但是线程b临界区业务代码可能都还没执行完成。</li></ul><h4 id="2-1-原子性"><a href="#2-1-原子性" class="headerlink" title="2.1 原子性"></a>2.1 原子性</h4><p>为解决原子性问题，常见的有两种方式:  </p><h5 id="2-1-1-使用Lua脚本"><a href="#2-1-1-使用Lua脚本" class="headerlink" title="2.1.1 使用Lua脚本"></a>2.1.1 使用Lua脚本</h5><p>lua脚本在执行过程中，是可以保证原子处理的，可以将setnx和expire两个命令都放到lua脚本中进行操作。  </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&#x27;setnx&#x27;</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">1</span>]) == <span class="hljs-number">1</span> <span class="hljs-keyword">then</span><br>   redis.call(<span class="hljs-string">&#x27;expire&#x27;</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">2</span>])<br><span class="hljs-keyword">else</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span>;<br></code></pre></td></tr></table></figure><h5 id="2-1-2-使用SET的扩展命令"><a href="#2-1-2-使用SET的扩展命令" class="headerlink" title="2.1.2 使用SET的扩展命令"></a>2.1.2 使用SET的扩展命令</h5><p>虽然<code>SETNX</code>和<code>EXPIRE</code>两个指令是独立的，但是单独的一个SET命令是却是原子的，可以使用SET的参数扩展功能实现NX和EXPIRE的能力<br><code>SET key value [EX seconds] [PX millseconds] NX</code>  </p><blockquote><p>SET key value [EX seconds] [PX milliseconds] NX<br>NX :表示key不存在的时候，才能set成功，也即保证只有第一个客户端请求才能获得锁，而其他客户端请求只能等其释放锁，才能获取。<br>EX seconds :设定key的过期时间，时间单位是秒。<br>PX milliseconds: 设定key的过期时间，单位为毫秒  </p></blockquote><p>在实际的开发过程中，我们一般使用第三方库，不会直接执行redis的cmd命令。可以在使用第三方的sdk时，查看sdk是否已经提供了一些原子的操作，避免自己写原生lua脚本或者命令。比如go-redis中，SETNX + EXPIRE已经可以在一个客户端操作中完成：  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Lock 使用 SETNX实现加锁</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Client)</span></span> Lock(key, value <span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>ret := c.client.SetNX(key, value, time.Minute)<br><span class="hljs-keyword">if</span> ret.Val() &#123;<br>fmt.Println(<span class="hljs-string">&quot;加锁成功&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;加锁失败&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// Redis `SET key value [expiration] NX` command.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Zero expiration means the key has no expiration time.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cmdable)</span></span> SetNX(key <span class="hljs-type">string</span>, value <span class="hljs-keyword">interface</span>&#123;&#125;, expiration time.Duration) *BoolCmd &#123;&#125;<br><br></code></pre></td></tr></table></figure><h4 id="2-2-误删除"><a href="#2-2-误删除" class="headerlink" title="2.2 误删除"></a>2.2 误删除</h4><p>既然锁可能会被别的线程删除，那给锁的value值设置一个标记当前的线程唯一值即可。在删除的时候首先校验值是否相等，只有相等的情况下才可以删除锁。<br>同样的，为保证一致性，值的比较和删除操作需要保证原子性。 </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&#x27;get&#x27;</span>,KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>] <span class="hljs-keyword">then</span> <br>   <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&#x27;del&#x27;</span>,KEYS[<span class="hljs-number">1</span>]) <br><span class="hljs-keyword">else</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span>;<br></code></pre></td></tr></table></figure><h3 id="3-Redisson"><a href="#3-Redisson" class="headerlink" title="3. Redisson"></a>3. Redisson</h3><p>参考文章：  </p><ul><li><a href="https://blog.csdn.net/qq_34826261/article/details/126177704">https://blog.csdn.net/qq_34826261&#x2F;article&#x2F;details&#x2F;126177704</a>  </li><li><a href="https://zhuanlan.zhihu.com/p/135864820">https://zhuanlan.zhihu.com/p/135864820</a>  </li><li><a href="https://juejin.cn/post/7168802584684134413">https://juejin.cn/post/7168802584684134413</a></li></ul><p>上面介绍的<code>SETNX + Exipred + 原子操作 + 唯一值校验删除</code>的方案在很大程度上已经能够满足使用，但是还有一个可能存在的情况没有解决： </p><ul><li>锁过期释放，但业务还没执行完成：假设线程a获取锁成功，一直在执行临界区的代码。100s过去后，它还没执行完。但这时候锁已经过期了，此时线程b又请求过来。显然线程b就可以获得锁成功，也开始执行临界区的代码。那么问题就来了，临界区的业务代码都不是严格串行执行。</li></ul><p>针对这种问题，Redisson框架做了一些额外的优化，在加锁的同时开启一个定时守护线程，每隔一段时间检查锁是否还存在，存在则对锁的过期时间延长，防止锁过期提前释放。  </p><p>Redisson主要原理及结构如下：  </p><ul><li>基于Redis命令的实现： Redisson利用了Redis的单线程特性和原子操作的特点。它通过调用Redis的SETNX命令来尝试获取锁，当锁不存在时，才能获取到锁。</li><li>心跳续约(看门狗)机制： 为防止业务逻辑还没执行完锁就到期的问题，Redisson在获取锁之后会启动一个定时任务来周期性地续约锁的有效时间。</li><li>实现可重入锁： Redisson支持可重入锁，保证同一线程在持有锁的情况下能够多次获取锁，而不会因为自己已经持有锁而被阻塞。  </li><li>分布式锁释放的安全性保证： Redisson通过Lua脚本来释放锁，保证了释放锁的原子性。使用Lua脚本可以保证释放锁的操作是原子的，避免了在执行释放锁逻辑时出现的并发问题。</li></ul><p><img src="/img/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/redisson.png">   </p><blockquote><p>部分核心逻辑如下： </p><ul><li>加锁 <ul><li>每次加锁都有一个加锁等待时间 </li><li>如果加锁成功，直接返回true</li><li>如果加锁失败，则订阅锁释放消息，在加锁等待时间内监听锁释放消息，如果一直没有监听到，则取消订阅并返回false </li><li>如果在等待时间内监听到锁释放消息，则进入一个不断重试获取锁的循环</li></ul></li><li>续期机制  <ul><li>只有在加锁时没有设置过期时间时才会启用Watch Dog机制  </li><li>Watch Dog启动守护线程，守护线程轮询周期为：internalLockLeaseTime&#x2F;3。internalLockLeaseTime的默认值由lockWatchdogTimeout来配置。默认值为30秒。也就是说默认情况下，守护线程每10秒检查续期</li></ul></li></ul></blockquote><h3 id="4-RedLock"><a href="#4-RedLock" class="headerlink" title="4. RedLock"></a>4. RedLock</h3><p>Redisson解决了锁超时续期自动释放的问题，但是还有一种极端的情况没有解决：  </p><ul><li>客户端A尝试在Redis Master节点上锁，客户端A成功获得锁的瞬间，锁数据还没有同步至Slave节点。这时Master挂了，于是发生主从切换，其它客户端连接到Slave节点尝试抢占锁，由于Slave没有客户端A的上锁信息。自然又会有一个新的客户端B抢到锁，此时就会出现两个客户端同时拥有分布式锁的奇葩现像。</li></ul><p>鉴于此，Redis作者提出一种更高级的RedLock算法，它需要部署 N （N &gt;&#x3D; 2n+1）个独立的 Redis master实例，且实例之间没有任何的联系。也就是说，只要一半以上的 Redis 实例加锁成功，那么 Redlock 依然可以正常运行。  </p><p><img src="/img/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/redlock.png">  </p><p>假设我们有 5 个 Redis 实例，当我们对 order1 这个订单加锁时，先记录当前时间用于统计加锁过程花费的时间，然后依次让 5 个 Redis 实例执行 SET order1 token NX EX 60 命令，最后统计<strong>加锁成功的实例数量以及加锁过程耗费的时间</strong>  </p><ul><li>统计个数: 当超过一半的加锁成功，认为是成功   </li><li>统计时间: 避免整体的加锁时长已经超过锁本身的有效时间，比如锁的过期时间是3s，但是加锁过程耗费了4s，肯定是认为加锁失败的。</li></ul><p>解锁过程相对简单，只需要5个实例依次删除redis key即可。   </p><p>Redlock在Redisson中也有对应的实现，不过在最新版的Redisson中，Redlock已经不再建议使用.因为现在加锁操作实现，可以等所有从节点数据同步了才算加锁成功。这样的话就可以保证主从切换锁不会丢失了。  </p><pre><code class="hljs">8.4. RedLockThis object is deprecated. Use RLock or RFencedLock instead.</code></pre><p>可以通过Redis的Wait命令实现主从同步  </p><blockquote><p>Redis WAIT 命令用来阻塞当前客户端，直到所有先前的写入命令成功传输并且至少由指定数量的从节点复制完成。如果执行超过超时时间（以毫秒为单位），则即使尚未完成指定数量的从结点复制，该命令也会返回。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>分布式锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
