<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>布隆过滤器</title>
    <link href="/2024/08/03/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <url>/2024/08/03/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>布隆过滤器（英语：Bloom Filter）是 1970 年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。主要用于判断一个元素是否在一个集合中。</p><span id="more"></span>  <h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>通常我们要判断一个元素是否在某个集合中时，经常想到的方式是将集合中所有元素保存起来，然后通过比较进行确定。链表、树、散列表（又叫哈希表，Hash table）等数据结构都是这种思路。但是随着集合中元素数量的增加，这几种方式需要的存储空间也会呈现线性增长，最终达到瓶颈。上述三种结构的检索时间复杂度分别为O(n)，O(logn)，O(1)。</p><h2 id="2-算法介绍"><a href="#2-算法介绍" class="headerlink" title="2. 算法介绍"></a>2. 算法介绍</h2><h3 id="2-1-原理"><a href="#2-1-原理" class="headerlink" title="2.1 原理"></a>2.1 原理</h3><p>布隆过滤器包含一个位数组和一组哈希函数。位数组每个元素存储的都是比特位，元素占用空间很小；使用一组哈希函数的原因是为了降低哈希冲突。</p><ul><li>初始状态：一个位数组，全部位置都置为0<br><img src="/img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/1.png"></li><li>数据加入：分别使用多个哈希函数对元素值进行计算，得到一组哈希值，将对应哈希值下标的数组值置为1<br><img src="/img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/2.png"></li><li>数据查找：对给定元素进行相同的哈希计算，判断每个位置的值是否都为1。如果值都为1，就认为这个元素存在，如果有一个值不唯一，就说明这个值不存在。</li></ul><p>📌 <font color="red">注意：布隆过滤器返回的结果是“可能存在”和“一定不存在”，不能提供“一定存在”的语义保证。因为可能有多个元素映射到同一个位置，导致误判。</font>    </p><h3 id="2-2-误判"><a href="#2-2-误判" class="headerlink" title="2.2 误判"></a>2.2 误判</h3><p>误判率（假阳性）：一个不存在的元素，可能会被误判为存在</p><h4 id="2-2-1-误判原因"><a href="#2-2-1-误判原因" class="headerlink" title="2.2.1 误判原因"></a>2.2.1 误判原因</h4><ul><li>哈希函数冲突：不同的哈希函数对元素进行映射时，可能会产生冲突，导致不同元素因素到位数组的相同位置。如下图所示：w的位置都已经是1，被认为w存在。</li><li>位数组大小限制：为减少空间占用，位数组大小有限。当存储的元素数量较多时，数据冲突可能性升高。<br><img src="/img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/3.png"></li></ul><h4 id="2-2-2-误判概率"><a href="#2-2-2-误判概率" class="headerlink" title="2.2.2 误判概率"></a>2.2.2 误判概率</h4><p>布隆过滤器的误判，主要是因为哈希函数存在冲突导致，即不同的值可能映射到同一个位置。在进行误判率的分析时，主要受到以下变量的制约：</p><ul><li><p>m：布隆过滤器的长度，即数组的长度</p></li><li><p>n： 集合中的元素个数</p></li><li><p>k： 哈希函数的个数<br><img src="/img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/4.png"></p></li><li><p>误判率：指定m、n、k情况下的误判率计算<br><img src="/img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/5.png"></p></li><li><p>长度：数组长度可以根据期望的误判率和元素个数来判断<br><img src="/img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/6.png"></p></li><li><p>哈希函数计算：指定m和n的情况下，减少误判的最佳哈希个数<br><img src="/img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/7.png"></p></li></ul><p>推导过程：</p><ul><li>添加1个元素，则任一比特为1的概率为：1&#x2F;m，任一比特为0的概率：1-1&#x2F;m；</li><li>添加1个元素，执行k次散列之后，则任一比特为0的概率：(1-1&#x2F;m)^k，任一比特为1的概率：1-(1-1&#x2F;m)^k；</li><li>如果添加n个元素，那么任一比特为0的概率：(1-1&#x2F;m)^kn，任一比特为1的概率：1-(1-1&#x2F;m)^kn；</li><li>如果将1个新的元素，添加到已存在n个元素的布隆过滤器中，则任一比特已经为1的概率与上面相同，概率为：1-(1-1&#x2F;m)^kn。因此，k个比特都为1的概率为：(1-(1-1&#x2F;m)^kn)^k，此即为新插入元素的误识别率。</li></ul><h3 id="2-3-无法删除"><a href="#2-3-无法删除" class="headerlink" title="2.3 无法删除"></a>2.3 无法删除</h3><p>布隆过滤器不允许删除元素：如果删除某个元素，导致对应位置为0，但是可能有多个元素映射到相同的位置上面，这样就会导致一个存在的元素被判断为不存在。破坏了“一定不存在”的语义保证。</p><p>📌 <font color="red">不允许删除的机制会导致其中的无效元素可能会越来越多，即实际已经在磁盘删除中的元素，但在布隆过滤器中还认为可能存在，这会造成越来越多的误判</font>   </p><h3 id="2-4-优缺点总结"><a href="#2-4-优缺点总结" class="headerlink" title="2.4 优缺点总结"></a>2.4 优缺点总结</h3><p>优点：</p><ul><li>插入、查询的效率高，时间复杂度为常数O(k)</li><li>空间占用小（存储空间占用是一个固定长度的bit数组）</li><li>散列函数相互之间没有关系，可以并行Hash</li><li>不存储原始数据，在严格要求保密的场景下有优势<br>缺点：</li><li>存在误报的可能性，尤其数据量越大越容易误报</li><li>只支持新增，不支持删除</li><li>数组长度和hash函数个数确定复杂</li><li>当过滤器数组过长时，查询性能差（多个哈希得到的下标跨度很大，CPU缓存命中率低）</li></ul><h2 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="3. 应用场景"></a>3. 应用场景</h2><p>布隆过滤器在实际项目开发中可以快速地解决一些问题，比如网页 URL 去重、垃圾邮件识别、大集合中重复元素的判断和缓存穿透等问题。<br>典型应用有：</p><ul><li>数据库防止穿库。 Google Bigtable，HBase 和 Cassandra 以及 Postgresql 使用BloomFilter减少不存在的行或列的磁盘查找。避免代价高昂的磁盘查找会大大提高数据库查询操作的性能。</li><li>业务场景中判断用户是否阅读过某视频或文章：比如抖音或头条，当然会导致一定的误判，但不会让用户看到重复的内容。</li><li>缓存穿透场景。在一些恶意请求中，请求参数都是缓存和数据中不存在的值，为了避免缓存穿透，可以用布隆过滤器先筛选一遍，只有在布隆过滤器中，才去查询缓存，如果没查询到，则穿透到db。如果不在布隆器中，则直接返回。</li><li>WEB拦截器，如果相同请求则拦截，防止重复被攻击。可以提高缓存命中率。Squid 网页代理缓存服务器在 cache digests 中就使用了布隆过滤器。Google Chrome浏览器使用了布隆过滤器加速安全浏览服务</li></ul><h2 id="4-实现"><a href="#4-实现" class="headerlink" title="4. 实现"></a>4. 实现</h2><p>基于Golang实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-string">&quot;github.com/bits-and-blooms/bitset&quot;</span><br>)<br><br><span class="hljs-comment">// 设置哈希数组默认大小为16</span><br><span class="hljs-keyword">const</span> DefaultSize = <span class="hljs-number">16</span><br><br><span class="hljs-comment">// 设置种子，保证不同哈希函数有不同的计算方式</span><br><span class="hljs-keyword">var</span> seeds = []<span class="hljs-type">uint</span>&#123;<span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">31</span>, <span class="hljs-number">37</span>, <span class="hljs-number">61</span>&#125;<br><br><span class="hljs-comment">// 构造6个哈希函数，每个哈希函数有参数seed保证计算方式的不同</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildHash</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(seed <span class="hljs-type">uint</span>, value <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">uint</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(seed <span class="hljs-type">uint</span>, value <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">uint</span> &#123;<br><span class="hljs-keyword">var</span> result <span class="hljs-type">uint</span> = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(value); i++ &#123;<br>result = result*seed + <span class="hljs-type">uint</span>(value[i])<br>&#125;<br><span class="hljs-keyword">return</span> result &amp; (DefaultSize - <span class="hljs-number">1</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 布隆过滤器结构，包括二进制数组和多个哈希函数</span><br><span class="hljs-keyword">type</span> BloomFilter <span class="hljs-keyword">struct</span> &#123;<br>set       *bitset.BitSet<br>hashFuncs [<span class="hljs-number">6</span>]<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(seed <span class="hljs-type">uint</span>, value <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">uint</span><br>&#125;<br><br><span class="hljs-comment">// 构造一个布隆过滤器，包括数组和哈希函数的初始化</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewBloomFilter</span><span class="hljs-params">()</span></span> *BloomFilter &#123;<br>bf := <span class="hljs-built_in">new</span>(BloomFilter)<br>bf.set = bitset.New(DefaultSize)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(bf.hashFuncs); i++ &#123;<br>bf.hashFuncs[i] = buildHash()<br>&#125;<br><span class="hljs-keyword">return</span> bf<br>&#125;<br><br><span class="hljs-comment">// Add 添加元素，将哈希函数计算结果对应的数组位置1</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *BloomFilter)</span></span> Add(value <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">for</span> i, f := <span class="hljs-keyword">range</span> b.hashFuncs &#123;<br>b.set.Set(f(seeds[i], value))<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Contains 查询元素是否存在，调用每个哈希函数，并且判断数组对应位是否为1 如果不为1，直接返回false，表明一定不存在</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *BloomFilter)</span></span> Contains(value <span class="hljs-type">string</span>) <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">for</span> i, f := <span class="hljs-keyword">range</span> b.hashFuncs &#123;<br><span class="hljs-keyword">if</span> !b.set.Test(f(seeds[i], value)) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>filter := NewBloomFilter()<br>filter.Add(<span class="hljs-string">&quot;hello&quot;</span>)<br>filter.Add(<span class="hljs-string">&quot;world&quot;</span>)<br>fmt.Println(filter.Contains(<span class="hljs-string">&quot;hello&quot;</span>))<br>fmt.Println(filter.Contains(<span class="hljs-string">&quot;world&quot;</span>))<br>fmt.Println(filter.Contains(<span class="hljs-string">&quot;xiao&quot;</span>))<br>fmt.Println(filter.Contains(<span class="hljs-string">&quot;xiaoming&quot;</span>)) <span class="hljs-comment">// 出现误判</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-演进变体"><a href="#5-演进变体" class="headerlink" title="5. 演进变体"></a>5. 演进变体</h2><p>针对布隆过滤器的上述一些问题，逐步产生了一些布隆过滤器的变体，简单介绍如下：</p><h3 id="5-1-计数布隆过滤器-Counting-Bloom-Filter"><a href="#5-1-计数布隆过滤器-Counting-Bloom-Filter" class="headerlink" title="5.1 计数布隆过滤器 Counting Bloom Filter"></a>5.1 计数布隆过滤器 Counting Bloom Filter</h3><ul><li>特点：支持删除</li><li>原理：CountingBloomFilter是BloomFilter的一个变种，它扩展标准布隆过滤器的数据结构，将底层数组的每一位扩展为一个4位大小的计数器Counter，用来存储某个下标映射成功的频次。它以占用更多的空间来换取支持删除操作。</li></ul><ol><li>插入元素时，通过k个哈希函数映射到k个计数器，这些命中的计数器值增加1；</li><li>删除元素时，删除元素的时候，通过k个散列函数映射到k个计数器，这些计数器值减少1。<br><img src="/img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/8.png"></li></ol><p>优点：</p><ul><li>除了占用存储空间翻（多）倍，继承了布隆过滤器的所有优点；支持删除。</li></ul><p>缺点：</p><ul><li>误报的概率仍然存在</li><li>需要额外考虑 Counter 数组中每个 Counter 的大小（最好具备溢出策略）</li><li>存储空间较布隆过滤器翻（多）倍</li></ul><h3 id="5-2-扩展布隆过滤器-Scalable-Bloom-Filter"><a href="#5-2-扩展布隆过滤器-Scalable-Bloom-Filter" class="headerlink" title="5.2 扩展布隆过滤器 Scalable Bloom Filter"></a>5.2 扩展布隆过滤器 Scalable Bloom Filter</h3><ul><li>特点：支持扩容</li><li>原理：Scalable Bloom Filter只会向最后一层插入数据，同时也从最后一层开始查询，直到查询至 BF0 层。<br><img src="/img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/9.png"></li></ul><ol><li>插入过程：只会向最后一层插入数据<ol><li>初始，SBF只包含BF0这一层，插入了a、b、c三个元素。</li><li>然后，假设BF0已经无法保证用户设定的误判率，此时就需要进行扩容，因此新的一层BF1被创建并加入进来。后来的d、e、f元素都会被插入到BF1中。</li><li>同理，当BF1也无法满足该层事先设定的误判率时，新的一层BF2也将被加入进来，如此进行下去。</li></ol></li><li>查询过程：从最后一层开始由后向前查询<ol><li>首先在BF1中进行查询。如果查询显示存在，则直接响应客户端；</li><li>如果查询显示不存在，则继续查询BF0。如果BF0中显示存在g，则响应客户端g存在。否则，因为BF0已经是最后一层了，则响应客户端g不存在。</li></ol></li></ol><p>缺点：</p><ul><li>查询开销：需要查询多个布隆过滤器，较单一布隆过滤器增加了一定的查询时间开销。</li><li>管理复杂度：维护多个布隆过滤器的策略相对复杂。</li></ul><h3 id="5-2-布谷鸟过滤器-Cuckoo-Filter"><a href="#5-2-布谷鸟过滤器-Cuckoo-Filter" class="headerlink" title="5.2 布谷鸟过滤器 Cuckoo Filter"></a>5.2 布谷鸟过滤器 Cuckoo Filter</h3><p>布谷鸟过滤器是布隆过滤器的变体，提供了删除元素的功能。它主要基于布谷鸟哈希和指纹技术。当插入一个元素时，布谷鸟过滤器存储该元素的“指纹”到哈希表的某个位置上。如果该位置已被占用，现有的元素会被移动到另一个位置，如此迭代下去，直到每个元素都有自己的位置为止。</p><p>最简单的布谷鸟哈希结构是一维数组结构</p><ol><li>每个元素都由哈希函数h1(x)和h2(x)确定两个候选位置，查找过程会检查两个位置是否任意一个位置为空。</li><li>如果两个位置中任何一个是空的，则算法将元素插入到该空位置中，插入完成；</li><li>如果两个位置都是满的，会选择一个候选位置踢出去现有的元素(鸠占鹊巢)，并将此被踢出元素重新插入到它的备用位置。这个过程可能会重复，直到找到一个空位置或达到最大位移次数。如果没有找到空位置，则认为此哈希表太满，则进行扩容和ReHash后，再次插入。<br><img src="/img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/10.png"></li></ol><h2 id="6-参考资料"><a href="#6-参考资料" class="headerlink" title="6. 参考资料"></a>6. 参考资料</h2><p>布隆过滤器：<br><a href="https://segmentfault.com/a/1190000021136424">https://segmentfault.com/a/1190000021136424</a><br><a href="https://segmentfault.com/a/1190000024566947">https://segmentfault.com/a/1190000024566947</a></p><p>计数布隆过滤器：<br><a href="https://juejin.cn/post/7362729128477638675">https://juejin.cn/post/7362729128477638675</a> </p><p>布谷鸟过滤器：<br><a href="https://www.cnblogs.com/zhaodongge/p/15067657.html">https://www.cnblogs.com/zhaodongge/p/15067657.html</a><br><a href="https://dbwu.tech/posts/cuckoo_filter/">https://dbwu.tech/posts/cuckoo_filter/</a></p>]]></content>
    
    
    <categories>
      
      <category>系统设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>布隆过滤器</tag>
      
      <tag>系统设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang中的Defer、Panic和Recover</title>
    <link href="/2024/07/13/Golang%E4%B8%ADdefer-panic-recvover%E5%88%86%E6%9E%90/"/>
    <url>/2024/07/13/Golang%E4%B8%ADdefer-panic-recvover%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>Golang中没有类似java的try catch机制进行异常处理，而是引入了defer、panic和recover来触发异常和终止异常。</p><span id="more"></span>  <h2 id="1-Defer"><a href="#1-Defer" class="headerlink" title="1. Defer"></a>1. Defer</h2><p>defer是go语言提供的一种用于注册延迟调用的机制：让函数或者语句可以在当前函数执行完毕后执行（包括通过return正常结束或者panic导致的异常结束）。</p><p>常用于一些操作后的收尾工作，比如关闭连接、释放锁、关闭文件等，使用起来比较优雅。  </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs golang">f, _ := os.Open(<span class="hljs-string">&quot;defer.txt&quot;</span>)<br><span class="hljs-keyword">defer</span> f.Close()  <br></code></pre></td></tr></table></figure><h3 id="1-1-Defer基本原理"><a href="#1-1-Defer基本原理" class="headerlink" title="1.1 Defer基本原理"></a>1.1 Defer基本原理</h3><p>defer使用准则</p><ul><li><p>每次defer语句执行的时候，会把函数“压栈”，函数参数会被拷贝下来，但是闭包引用不会</p><ul><li>作为函数参数：在defer定义时就把值传递给defer，并被cache起来，后续不会再改变</li><li>作为闭包引用：在defer函数真正调用时根据整个上下文确定当前的值。</li></ul></li><li><p>当外层逻辑退出时，defer函数按照定义的逆序执行；【先入后出，压栈进行】</p></li><li><p>恰当的使用defer方法可以修改返回值  </p></li><li><p>先入后出</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++ &#123;<br><span class="hljs-keyword">defer</span> fmt.Println(i)<br>&#125;<br>&#125; <br><span class="hljs-comment">// 输出 3 2 1</span><br></code></pre></td></tr></table></figure></li><li><p>defer函数的参数引用方式</p><ul><li>作为函数入参，在函数定义时就已经传递给defer函数，后续不会再改变  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">b</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++ &#123;<br>        <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a <span class="hljs-type">int</span>)</span></span> &#123;<br>            fmt.Println(a)<br>        &#125;(i)<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 输出 3 2 1</span><br></code></pre></td></tr></table></figure></li><li>作为闭包的引用时，在最后执行的时候确定上下文的值  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">c</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++ &#123;<br>        <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            fmt.Println(i)<br>        &#125;()<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 输出 4 4 4 </span><br><span class="hljs-comment">// i = 3 时定义最后一个defer，又进行了+1操作后，才真正开始执行defer函数</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="1-2-defer命令拆解"><a href="#1-2-defer命令拆解" class="headerlink" title="1.2 defer命令拆解"></a>1.2 defer命令拆解</h3><p>上面说defer可以操作返回值，本质上就是在含有defer函数的代码中，一个 return xxx的语句可以进行拆解，这条语句在实际执行时分三步进行：</p><blockquote><ol><li>返回值 &#x3D; xxx</li><li>执行defer函数</li><li>空的return</li></ol></blockquote><p>典型案例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">d</span><span class="hljs-params">()</span></span> (r <span class="hljs-type">int</span>) &#123;<br>t := <span class="hljs-number">5</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>t = t + <span class="hljs-number">5</span><br>&#125;()<br><span class="hljs-keyword">return</span> t<br>&#125;<br><span class="hljs-comment">// 返回 5</span><br><span class="hljs-comment">// r=t; t=t+5; return </span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">e</span><span class="hljs-params">()</span></span> (r <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(r <span class="hljs-type">int</span>)</span></span> &#123;<br>r = r + <span class="hljs-number">5</span><br>&#125;(r)<br><span class="hljs-keyword">return</span> <span class="hljs-number">5</span><br>&#125;<br><span class="hljs-comment">// 返回 5</span><br><span class="hljs-comment">// r = 5； r=r+5（这个r为形参r，不是返回值r）； return</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> (r <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>r = r + <span class="hljs-number">5</span><br>&#125;()<br><span class="hljs-keyword">return</span> <span class="hljs-number">5</span><br>&#125;<br><br><span class="hljs-comment">// 返回 10</span><br><span class="hljs-comment">// r = 5； r=r+5； return</span><br></code></pre></td></tr></table></figure><p>从以上的实际案例中可以看到：</p><p>📌 <font color="red">能通过defer修改返回值的场景，一定是有命名返回值的函数场景。</font>  </p><h2 id="2-Painc和Recover"><a href="#2-Painc和Recover" class="headerlink" title="2. Painc和Recover"></a>2. Painc和Recover</h2><p>当go在运行过程中发送异常时，Go运行时会触发运行时panic，并在调用它的函数中向本层以及所有上层逐级抛出，若一直没有recover捕获，程序最终会终止。  </p><p>若在某层defer语句中被recover捕获，控制流程将进入到recover之后的语句中。通过panic、defer和recover，可以实现类似try catch的功能。  </p><p>例如： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;defer in&quot;</span>)<br><span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br>&#125;()<br><br>fmt.Println(<span class="hljs-string">&quot;panic begin&quot;</span>)<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;hello, I&#x27;m panic&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;panic end&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 输出</span><br><span class="hljs-comment">// panic begin</span><br><span class="hljs-comment">// defer in</span><br><span class="hljs-comment">// hello, I&#x27;m panic</span><br></code></pre></td></tr></table></figure><p>📌 <font color="red">注意：defer中的recover仅对当前协程生效，且仅在直接被defer函数调用才有效</font>    </p><h3 id="2-1-Recover使用规则"><a href="#2-1-Recover使用规则" class="headerlink" title="2.1 Recover使用规则"></a>2.1 Recover使用规则</h3><p>Recover在使用的过程中，一般会判断返回值是否为空，当返回值为空的时候代表没有正常捕获问题。golang官方介绍了几种Recover返回为空的场景。</p><ol><li>panic的参数为空</li><li>当前协程没有panic</li><li>recover没有直接被defer函数调用</li></ol><p>分别介绍如下：</p><ul><li><p>panic参数为空，可以正常捕获 &#x2F;&#x2F; 本身panic参数为nil时候等同于没有发送panic</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;panic: %v&quot;</span>, err)<br>&#125;<br>&#125;()<br><br><span class="hljs-built_in">panic</span>(<span class="hljs-literal">nil</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>跨协程调用recover函数，无法捕获异常</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// panic跟recover不在一个协程，无法捕获异常</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>log.Println(<span class="hljs-built_in">recover</span>())<br>&#125;()<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;A bad boy stole a server&quot;</span>)<br>&#125;()<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>不在defer函数中直接调用，无法捕获异常</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 对 recover进行了一层封装，无法正常生效</span><br>Recover(<span class="hljs-string">&quot;Panic in goroutine&quot;</span>)<br>&#125;()<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;A bad boy stole the server&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Recover</span><span class="hljs-params">(funcName <span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;panic para: %v, panic info: %v\n&quot;</span>, funcName, err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>进阶分析</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// recover是在匿名函数/闭包中使用，实际执行时取值，触发panic后有值</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>log.Print(<span class="hljs-built_in">recover</span>(), <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;, a handsome police catch him.\n\n&quot;</span><br>&#125;())<br>&#125;()<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;A bad boy stole a server&quot;</span>)<br>&#125;()<br><br>time.Sleep(<span class="hljs-number">3</span> * time.Second)<br><br><span class="hljs-comment">// recover作为函数参数使用，定义时就完成值拷贝，刚开始没报错，最后也不会有值。</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> log.Print(<span class="hljs-built_in">recover</span>(), <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;, but a handsome police catch nothing.\n&quot;</span><br>&#125;())<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;A bad boy stole a server, again.&quot;</span>)<br>&#125;()<br>time.Sleep(<span class="hljs-number">3</span> * time.Second)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-2-Defer、Panic、Recover原理浅析"><a href="#2-2-Defer、Panic、Recover原理浅析" class="headerlink" title="2.2 Defer、Panic、Recover原理浅析"></a>2.2 Defer、Panic、Recover原理浅析</h3><p><img src="/img/Golang%E4%B8%ADdefer-panic-recvover%E5%88%86%E6%9E%90/2.png"><br>异常恢复流程可以总结成以下主要流程：</p><ul><li>触发panic流程：panic终止程序的过程是由编译器将关键字 panic 转换成 runtime.gopanic() 内置函数。异常恢复的流程基本都在这个函数中：<ul><li>首先会创建一个_panic结构体用来记录当前panic，并且将当前panic加入当前goroutine的_panic链表</li><li>然后循环从当前 goroutine 的_defer链表中获取runtime._defer并调用runtime.reflectcall()运行defer函数。</li></ul></li><li>恢复流程：如果defer函数中如果recover调用，recover会被汇编转换成runtime.gorecover调用，该函数会标记该panic已经被recover。在执行完某个defer后，如果该panic被标记为recover，则会调用runtime.recovery恢复goroutine的执行。</li><li>崩溃流程：如果_defer链表为空，或者执行完所有的defer都不包含recover调用，则会调用runtime.fatalpanic打印panic信息，然后中止&#x2F;退出程序。</li></ul><h2 id="3-参考资料"><a href="#3-参考资料" class="headerlink" title="3. 参考资料"></a>3. 参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/487749806">https://zhuanlan.zhihu.com/p/487749806</a> </p><p><a href="https://zhuanlan.zhihu.com/p/689615742">https://zhuanlan.zhihu.com/p/689615742</a></p><p><a href="https://go101.org/article/panic-and-recover-use-cases.html">https://go101.org/article/panic-and-recover-use-cases.html</a> </p><p><a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/">https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/</a></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>异常处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB查询性能分析-Explain</title>
    <link href="/2024/06/30/MongoDB%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-Explain/"/>
    <url>/2024/06/30/MongoDB%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-Explain/</url>
    
    <content type="html"><![CDATA[<p>在日常的MongoDB开发和使用中，不可避免的会碰到一些慢查询的问题，针对这些问题，我们一般可以使用 explain 方法来获取查询的执行计划和性能分析信息。使用explain方法可以帮助我们理解查询是如何执行的，以及识别性能瓶颈和优化对象。</p><span id="more"></span>   <h2 id="1-Explain简介"><a href="#1-Explain简介" class="headerlink" title="1. Explain简介"></a>1. Explain简介</h2><h3 id="1-1-基本使用"><a href="#1-1-基本使用" class="headerlink" title="1.1 基本使用"></a>1.1 基本使用</h3><p>使用 explain 方法；你可以在任何查询、更新或删除操作中使用 explain 方法。以下是一些基本示例。<br>假设你有一个集合 myCollection，你可以如下进行操作：</p><ul><li><p>对查询操作使用 explain   </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.myCollection.find(&#123; a: &#123; $gt: <span class="hljs-number">1</span>, $lt: <span class="hljs-number">2</span> &#125; &#125;).explain() <br></code></pre></td></tr></table></figure><p>这将返回查询的执行计划，包括扫描类型、索引使用情况和其他详细信息。</p></li><li><p>对更新操作使用 explain   </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.myCollection.updateMany(&#123; a: &#123; $gt: <span class="hljs-number">1</span>, $lt: <span class="hljs-number">2</span> &#125; &#125;, &#123; $<span class="hljs-keyword">set</span>: &#123; b: <span class="hljs-number">1</span> &#125; &#125;).explain() <br></code></pre></td></tr></table></figure></li><li><p>对删除操作使用 explain    </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.myCollection.deleteMany(&#123; a: &#123; $gt: <span class="hljs-number">1</span>, $lt: <span class="hljs-number">2</span> &#125; &#125;).explain() <br></code></pre></td></tr></table></figure></li></ul><h3 id="1-2-输出含义解析"><a href="#1-2-输出含义解析" class="headerlink" title="1.2 输出含义解析"></a>1.2 输出含义解析</h3><p>explain 方法返回一个包含以下信息的文档：</p><ul><li><p>queryPlanner：描述查询计划的信息。</p><ul><li>plannerVersion：查询规划器的版本。</li><li>namespace：查询的命名空间（即数据库和集合）。</li><li>indexFilterSet：是否设置了索引过滤。</li><li>parsedQuery：解析后的查询条件。</li><li>winningPlan：实际执行的查询计划。<font color="red">（winningPlan比较重要，一般可以看出当前查询语句使用的索引计划等，方便问题排查）</font></li><li>rejectedPlans：被拒绝的查询计划（如果有）。</li></ul></li><li><p>executionStats：提供查询执行的统计信息（仅在使用 executionStats 或 allPlansExecution 模式时）。</p><ul><li>executionSuccess：查询是否成功执行。</li><li>nReturned：返回的文档数量。</li><li>executionTimeMillis：查询执行时间（毫秒）。</li><li>totalKeysExamined：检查的索引键数量。</li><li>totalDocsExamined：检查的文档数量。</li><li>serverInfo：有关服务器的信息。</li></ul></li></ul><h3 id="1-3-模式差别"><a href="#1-3-模式差别" class="headerlink" title="1.3 模式差别"></a>1.3 模式差别</h3><p>explain 方法有三种模式, 可以通过传递参数来指定模式。</p><ul><li>queryPlanner（默认）：只返回查询计划，不包含实际执行统计信息。  </li><li>executionStats：返回查询计划和执行统计信息。  </li><li>allPlansExecution：返回所有执行计划和它们的执行统计信息。</li></ul><h3 id="1-4-具体案例分析"><a href="#1-4-具体案例分析" class="headerlink" title="1.4 具体案例分析"></a>1.4 具体案例分析</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.myCollection.find(&#123; a: &#123; $gt: <span class="hljs-number">1</span>, $lt: <span class="hljs-number">2</span> &#125; &#125;).explain(&quot;executionStats&quot;) <br></code></pre></td></tr></table></figure><p>以下是一个 explain 方法的示例输出：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;queryPlanner&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;plannerVersion&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;namespace&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;myDatabase.myCollection&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;indexFilterSet&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;parsedQuery&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;a&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;$gt&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;$lt&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;winningPlan&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;stage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;FETCH&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;inputStage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;stage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;IXSCAN&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;keyPattern&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;a&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;indexName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;a_1&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;isMultiKey&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;multiKeyPaths&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;a&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;isUnique&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;isSparse&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;isPartial&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;indexVersion&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;direction&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;forward&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;indexBounds&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;a&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-string">&quot;(1.0, 2.0)&quot;</span><br>          <span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;rejectedPlans&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;executionStats&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;executionSuccess&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;nReturned&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;executionTimeMillis&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;totalKeysExamined&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;totalDocsExamined&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;executionStages&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;stage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;FETCH&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;nReturned&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;executionTimeMillisEstimate&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;works&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;advanced&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;needTime&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;needFetch&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;saveState&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;restoreState&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;isEOF&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;docsExamined&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;alreadyHasObj&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;inputStage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;stage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;IXSCAN&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;nReturned&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;executionTimeMillisEstimate&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;works&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;advanced&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;needTime&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;needFetch&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;saveState&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;restoreState&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;isEOF&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;keyPattern&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;a&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;indexName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;a_1&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;isMultiKey&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;multiKeyPaths&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;a&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;isUnique&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;isSparse&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;isPartial&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;indexVersion&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;direction&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;forward&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;indexBounds&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;a&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-string">&quot;(1.0, 2.0)&quot;</span><br>          <span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;keysExamined&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;seeks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;dupsTested&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;dupsDropped&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;seenInvalidated&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;serverInfo&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;localhost&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">27017</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;4.2.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;gitVersion&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2b62a68cfa4efae44c9a66b09a38df7e48fdbe73&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>通过分析 explain 输出，你可以了解查询是如何执行的，并据此优化索引和查询语句。</p><h2 id="2-ExecutionStats中的时间分析"><a href="#2-ExecutionStats中的时间分析" class="headerlink" title="2 ExecutionStats中的时间分析"></a>2 ExecutionStats中的时间分析</h2><p>在 MongoDB 的 explain 输出中，executionStats 部分包含了查询的执行统计信息。其中包括执行评估时间（executionTimeMillisEstimate）和实际执行时间（executionTimeMillis）。这两个时间指标有不同的含义和用途：</p><ul><li>executionTimeMillisEstimate：<ul><li>含义：执行评估时间（或执行时间估计）。</li><li>作用：这是对特定阶段或步骤的执行时间的估计值。这个值是由 MongoDB 查询引擎内部计算得出的，用于提供一个大致的时间估计，帮助了解查询各个阶段所消耗的时间。</li><li>使用场景：在分析查询计划中各个阶段的性能时，executionTimeMillisEstimate 可以帮助确定每个阶段的大致执行时间，从而识别可能的性能瓶颈。</li></ul></li><li>executionTimeMillis：<ul><li>含义：实际执行时间。</li><li>作用：这是查询从开始到结束实际花费的时间，以毫秒为单位。这个时间包括整个查询执行过程中的所有步骤和阶段。</li><li>使用场景：executionTimeMillis 提供了查询的总体执行时间，用于衡量查询的整体性能。</li></ul></li></ul><p>假设有以下 explain 输出：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;executionStats&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;executionSuccess&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;nReturned&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;executionTimeMillis&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">5</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;totalKeysExamined&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;totalDocsExamined&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;executionStages&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;stage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;FETCH&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;nReturned&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;executionTimeMillisEstimate&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;works&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;advanced&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;needTime&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;needFetch&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;saveState&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;restoreState&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;isEOF&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;docsExamined&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;alreadyHasObj&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;inputStage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;stage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;IXSCAN&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;nReturned&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;executionTimeMillisEstimate&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;works&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;advanced&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;needTime&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;needFetch&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;saveState&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;restoreState&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;isEOF&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;keyPattern&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;a&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;indexName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;a_1&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;isMultiKey&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;multiKeyPaths&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;a&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;isUnique&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;isSparse&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;isPartial&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;indexVersion&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;direction&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;forward&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;indexBounds&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;a&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-string">&quot;(1.0, 2.0)&quot;</span><br>          <span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;keysExamined&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;seeks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;dupsTested&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;dupsDropped&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;seenInvalidated&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li>executionTimeMillis：整个查询实际执行时间为 5 毫秒。</li><li>executionTimeMillisEstimate（FETCH 阶段）：这个阶段的执行时间估计为 2 毫秒。</li><li>executionTimeMillisEstimate（IXSCAN 阶段）：这个阶段的执行时间估计为 1 毫秒。</li></ul><p>通过结合这两个时间指标，可以更好地优化查询，改进性能。例如，如果某个阶段的 executionTimeMillisEstimate 特别高，可以考虑优化该阶段的索引或查询逻辑。</p><h2 id="3-WinningPaln中的Stage有哪些"><a href="#3-WinningPaln中的Stage有哪些" class="headerlink" title="3. WinningPaln中的Stage有哪些"></a>3. WinningPaln中的Stage有哪些</h2><p>在 MongoDB 查询计划（explain 输出的 winningPlan 部分）中，查询计划由多个阶段（Stage）组成，每个阶段代表查询执行过程中的一个步骤。主要包括如下类型：</p><ul><li>COLLSCAN（Collection Scan）：<ul><li>扫描整个集合的所有文档，通常是因为没有可用的索引。</li><li>使用场景：没有适用的索引，或者是全表扫描。-</li></ul></li><li>IXSCAN（Index Scan）：<ul><li>扫描索引，查找符合条件的索引条目。</li><li>使用场景：查询条件可以利用索引。</li></ul></li><li>FETCH：<ul><li>从磁盘中读取文档，通常跟在 IXSCAN 之后，通过索引查找后获取实际文档。</li><li>使用场景：通过索引查找后，需要获取完整文档。</li></ul></li><li>LIMIT：<ul><li>限制结果集的数量。</li><li>使用场景：查询中使用 limit 操作。</li></ul></li><li>SKIP：<ul><li>跳过结果集中的前若干个文档。</li><li>使用场景：查询中使用 skip 操作。</li></ul></li><li>SORT：<ul><li>对结果集进行排序。</li><li>使用场景：查询中使用 sort 操作。</li></ul></li><li>PROJECTION：<ul><li>对结果集进行字段投影，只返回指定的字段。</li><li>使用场景：查询中使用字段选择器。</li></ul></li><li>SHARD_MERGE：<ul><li>从多个分片中合并结果集。</li><li>使用场景：在分片集群环境中，跨分片查询。</li></ul></li><li>TEXT：<ul><li>执行全文搜索查询。</li><li>使用场景：查询中使用 $text 操作符。</li></ul></li><li>GEO_NEAR：<ul><li>执行地理位置查询，查找距离某点最近的文档。</li><li>使用场景：查询中使用 $near 或 $geoNear 操作符。</li></ul></li><li>GROUP：<ul><li>执行分组操作，类似于 SQL 的 GROUP BY。</li><li>使用场景：查询中使用聚合管道中的 $group 操作符。</li></ul></li><li>UNWIND：<ul><li>拆分数组字段，将每个数组元素作为单独的文档。</li><li>使用场景：查询中使用聚合管道中的 $unwind 操作符。</li></ul></li><li>LOOKUP：<ul><li>执行联表查询，将一个集合中的文档与另一个集合中的文档进行连接。</li><li>使用场景：查询中使用聚合管道中的 $lookup 操作符。</li></ul></li><li>REDUCE：<ul><li>在 MapReduce 操作中，执行 reduce 阶段。</li><li>使用场景：使用 MapReduce 执行复杂聚合操作。</li></ul></li></ul><p>假设有一个集合 myCollection，使用以下查询并结合 explain 查看查询计划：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.myCollection.find(&#123; a: &#123; $gt: <span class="hljs-number">1</span>, $lt: <span class="hljs-number">2</span> &#125; &#125;).sort(&#123; b: <span class="hljs-number">-1</span> &#125;).limit(<span class="hljs-number">5</span>).explain()<br></code></pre></td></tr></table></figure><p>得到的 explain 输出可能包含以下阶段：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;queryPlanner&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;winningPlan&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;stage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;LIMIT&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;limitAmount&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">5</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;inputStage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;stage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;SORT&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;sortPattern&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;b&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">-1</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;inputStage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;stage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;FETCH&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;inputStage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;stage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;IXSCAN&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;keyPattern&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;a&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;indexName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;a_1&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;isMultiKey&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;direction&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;forward&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;indexBounds&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;a&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;(1.0, 2.0)&quot;</span><br>              <span class="hljs-punctuation">]</span><br>            <span class="hljs-punctuation">&#125;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>LIMIT 阶段：限制结果集数量为 5。</li><li>SORT 阶段：按 b 字段进行降序排序。</li><li>FETCH 阶段：通过索引查找后，从磁盘中读取完整文档。</li><li>IXSCAN 阶段：扫描 a_1 索引，查找 a 字段在 (1, 2) 范围内的索引条目。</li></ul><p>通过理解这些阶段，可以更好地分析和优化查询性能。例如，确保查询尽可能利用索引，减少全表扫描（COLLSCAN）。</p>]]></content>
    
    
    <categories>
      
      <category>MongoDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能分析</tag>
      
      <tag>Explain</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang Json Unmarshal 大数精度丢失问题</title>
    <link href="/2024/05/08/Golang-Json-Unmarshal-%E5%A4%A7%E6%95%B0%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/"/>
    <url>/2024/05/08/Golang-Json-Unmarshal-%E5%A4%A7%E6%95%B0%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>在Golang中，使用Unmarshal将一个Json数字解析为<code>interface&#123;&#125;</code>时, int64等大类型数字会存在精度丢失的问题。    </p><p>一般来说，长度超过16位的数字易发生数据截断，而且数据值变成了科学计数法。</p><span id="more"></span>   <h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>假设有一个长度为17的json大数字</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">var</span> str = <span class="hljs-string">`&#123;&quot;id&quot;:10000649949036001&#125;`</span><br></code></pre></td></tr></table></figure><p>如果直接使用json的interface进行解析, 会得到 10000649949036000, 而不是我们想要的10000649949036001 </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ParseWithInterface</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> test <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;<br><br><span class="hljs-keyword">if</span> err := json.Unmarshal([]<span class="hljs-type">byte</span>(str), &amp;test); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br><br>fmt.Println(test)<br><br>dataBytes, err := json.Marshal(test)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%+s\n&quot;</span>, <span class="hljs-type">string</span>(dataBytes))<br>&#125;<br><br><span class="hljs-comment">// 输出</span><br><span class="hljs-comment">// map[id:1.0000649949036e+16]</span><br><span class="hljs-comment">// &#123;&quot;id&quot;:10000649949036000&#125;  </span><br><br></code></pre></td></tr></table></figure><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>原因就出在了interface{}上，在golang中，当数据结构未知，使用map[string]interface{}接收反序列化结果时，会使用float64来进行结果解析，而float类型在处理的过程中时会有精度丢失的，一般超过16位就会发生，同时float64在处理的数据的时候，一般超过6位就会变成科学记数法。使用float64对json number进行解析可以在json的官方代码中找到。</p><blockquote><p>&#x2F;&#x2F; To unmarshal JSON into an interface value,<br>&#x2F;&#x2F; Unmarshal stores one of these in the interface value:<br>&#x2F;&#x2F;<br>&#x2F;&#x2F;bool, for JSON booleans<br>&#x2F;&#x2F;float64, for JSON numbers<br>&#x2F;&#x2F;string, for JSON strings<br>&#x2F;&#x2F;[]interface{}, for JSON arrays<br>&#x2F;&#x2F;map[string]interface{}, for JSON objects<br>&#x2F;&#x2F;nil for JSON null</p></blockquote><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>既然上文已经说了int64反序列化精度丢失的原因是使用了float64进行解析，那么我们只需要在解析时强行指定不使用float64解析即可。</p><h3 id="使用Int64解析"><a href="#使用Int64解析" class="headerlink" title="使用Int64解析"></a>使用Int64解析</h3><p>在知道具体类型的情况下，可以直接定义结构体为map[string]int64, 这样在解析时，就会使用int64进行解析。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ParseWithInt64</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> data <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int64</span><br>str := <span class="hljs-string">`&#123;&quot;id&quot;:10000649949036001&#125;`</span><br>err := json.Unmarshal([]<span class="hljs-type">byte</span>(str), &amp;data)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br><br>fmt.Println(data)<br>&#125;<br><span class="hljs-comment">// 输出</span><br><span class="hljs-comment">// map[id:10000649949036001]</span><br></code></pre></td></tr></table></figure><h3 id="利用UseNumber"><a href="#利用UseNumber" class="headerlink" title="利用UseNumber"></a>利用UseNumber</h3><p>golang json提供了一种额外的解析方式，可以在解析的过程使用指定使用Number类型而不是float64进行解析，这样就可以避免精度丢失的问题。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// convertNumber converts the number literal s to a float64 or a Number</span><br><span class="hljs-comment">// depending on the setting of d.useNumber.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *decodeState)</span></span> convertNumber(s <span class="hljs-type">string</span>) (any, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> d.useNumber &#123;<br><span class="hljs-keyword">return</span> Number(s), <span class="hljs-literal">nil</span><br>&#125;<br>f, err := strconv.ParseFloat(s, <span class="hljs-number">64</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, &amp;UnmarshalTypeError&#123;Value: <span class="hljs-string">&quot;number &quot;</span> + s, Type: reflect.TypeOf(<span class="hljs-number">0.0</span>), Offset: <span class="hljs-type">int64</span>(d.off)&#125;<br>&#125;<br><span class="hljs-keyword">return</span> f, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ParseUseNumber</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> test <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;<br><br>d := json.NewDecoder(bytes.NewReader([]<span class="hljs-type">byte</span>(str)))<br>d.UseNumber()<br><span class="hljs-keyword">if</span> err := d.Decode(&amp;test); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br><br>fmt.Println(test)<br>&#125;<br><br><span class="hljs-comment">// 输出</span><br><span class="hljs-comment">// map[id:10000649949036001]</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>JSON</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang Empty 切片 vs Nil 切片</title>
    <link href="/2024/04/10/Golang-Empty-Nil-Slice/"/>
    <url>/2024/04/10/Golang-Empty-Nil-Slice/</url>
    
    <content type="html"><![CDATA[<p>切片（Slice），是Golang开发中常用到的一种基础数据结构，和数组比较相似。在日常开发中，经常见到nil切片、空切片和零切片的概念。今天主要分享一下他们之间的区别。</p><span id="more"></span>  <h2 id="1-基本对比"><a href="#1-基本对比" class="headerlink" title="1. 基本对比"></a>1. 基本对比</h2><h3 id="1-1-结论"><a href="#1-1-结论" class="headerlink" title="1.1 结论"></a>1.1 结论</h3><p>empty slice vs nil slice     </p><ul><li>相同点   <ul><li>they both have zero length and capacity,   </li><li>they can be used with the same effect in for loops and append functions,</li><li>and they even look the same when printed.</li></ul></li><li>不同点   <ul><li>nil切片和nil比较的结果是true  </li><li>empty切片和nil比较的结果是false</li></ul></li></ul><h3 id="1-2-nil-切片"><a href="#1-2-nil-切片" class="headerlink" title="1.2 nil 切片"></a>1.2 nil 切片</h3><blockquote><p>nil slice: 长度和容量都为0，并且和nil比较的结果true的切片<br>一般可以通过直接定义变量或者new创建   </p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">var</span> slice1 []<span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> slice2 = *<span class="hljs-built_in">new</span>([]<span class="hljs-type">int</span>)<br>fmt.Println(slice1, <span class="hljs-built_in">len</span>(slice1), <span class="hljs-built_in">cap</span>(slice1), slice1 == <span class="hljs-literal">nil</span>)<br>fmt.Println(slice2, <span class="hljs-built_in">len</span>(slice2), <span class="hljs-built_in">cap</span>(slice2), slice2 == <span class="hljs-literal">nil</span>)  <br><span class="hljs-comment">// [] 0 0 true</span><br><span class="hljs-comment">// [] 0 0 true</span><br></code></pre></td></tr></table></figure><p>可以简单理解为nil切片是只声明但是未初始化的切片。   </p><h3 id="1-3-empty-切片"><a href="#1-3-empty-切片" class="headerlink" title="1.3 empty 切片"></a>1.3 empty 切片</h3><blockquote><p>empty slice: 长度和容量都为0，但是和nil比较的结果为false的切片<br>一般可以通过声明一个长度为0的切片创建  </p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">var</span> slice3 = []<span class="hljs-type">int</span>&#123;&#125;<br><span class="hljs-keyword">var</span> slice4 = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br>fmt.Println(slice3, <span class="hljs-built_in">len</span>(slice3), <span class="hljs-built_in">cap</span>(slice3), slice3 == <span class="hljs-literal">nil</span>)<br>fmt.Println(slice4, <span class="hljs-built_in">len</span>(slice4), <span class="hljs-built_in">cap</span>(slice4), slice4 == <span class="hljs-literal">nil</span>)  <br><span class="hljs-comment">// [] 0 0 false</span><br><span class="hljs-comment">// [] 0 0 false</span><br></code></pre></td></tr></table></figure><p>可以简单理解empty切片是声明后切初始化了长度为0的切片。</p><h3 id="1-4-零-切片"><a href="#1-4-零-切片" class="headerlink" title="1.4 零 切片"></a>1.4 零 切片</h3><blockquote><p>零切片： 叫法不常见，主要是值长度部位0，但是内部数组元素都是零值或者nil的切片<br>使用make创建的长度不为0的初始切片就是零切片  </p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs golang">slice5 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">5</span>)  <span class="hljs-comment">// 0 0 0 0 0</span><br>slice6 := <span class="hljs-built_in">make</span>([]*<span class="hljs-type">int</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// nil nil nil nil nil</span><br>fmt.Println(slice5, <span class="hljs-built_in">len</span>(slice5), <span class="hljs-built_in">cap</span>(slice5), slice5 == <span class="hljs-literal">nil</span>)<br>fmt.Println(slice6, <span class="hljs-built_in">len</span>(slice6), <span class="hljs-built_in">cap</span>(slice6), slice6 == <span class="hljs-literal">nil</span>)<br><span class="hljs-comment">// [0 0 0 0 0] 5 5 false</span><br><span class="hljs-comment">// [nil nil nil nil nil] 5 5 false</span><br></code></pre></td></tr></table></figure><h2 id="2-底层原理"><a href="#2-底层原理" class="headerlink" title="2 底层原理"></a>2 底层原理</h2><p>golang的slice底层结构体由3个字段构成：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> slice <span class="hljs-keyword">struct</span>&#123;<br>    ptr unsafe.Pointer <br>    <span class="hljs-built_in">len</span> <span class="hljs-type">int</span> <br>    <span class="hljs-built_in">cap</span> <span class="hljs-type">int</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>其中len和cap分别是切片的长度和容量，而ptr则是指向底层数组的指针。    </p><p>所谓nil切片，就是ptr指向的指针也为nil<br><img src="/img/Golang-Empty-Nil-Slice/1.jpg">     </p><p>可以通过一个小实验验证指针的数据：  </p><pre><code class="golang">var s1 []int  s2 := []int&#123;&#125;  s3 := make([]int, 0)fmt.Printf(&quot;s1 (addr: %p): %+8v\n&quot;, &amp;s1, *(*reflect.SliceHeader)(unsafe.Pointer(&amp;s1)))fmt.Printf(&quot;s2 (addr: %p): %+8v\n&quot;, &amp;s2, *(*reflect.SliceHeader)(unsafe.Pointer(&amp;s2))) fmt.Printf(&quot;s3 (addr: %p): %+8v\n&quot;, &amp;s3, *(*reflect.SliceHeader)(unsafe.Pointer(&amp;s3))) // s1 (addr: 0xc0000080d8): &#123;Data:       0 Len:       0 Cap:       0&#125;// s2 (addr: 0xc0000080f0): &#123;Data:12760120 Len:       0 Cap:       0&#125;// s3 (addr: 0xc000008108): &#123;Data:12760120 Len:       0 Cap:       0&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>Slice</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Golang泛型</title>
    <link href="/2024/03/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3golang%E6%B3%9B%E5%9E%8B/"/>
    <url>/2024/03/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3golang%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>泛型（Generics）是一种编程思想，它允许在编写代码时使用未知的类型。泛型可以增加代码的灵活性和可复用性，同时还能提高代码的安全性和可读性。Go从1.18开始支持泛型的实现并在后续的版本中逐渐完善。</p><span id="more"></span>  <h2 id="1-Golang泛型"><a href="#1-Golang泛型" class="headerlink" title="1. Golang泛型"></a>1. Golang泛型</h2><ul><li>举个栗子, 现在有一个a+b的函数  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>&#123;<br>    <span class="hljs-keyword">return</span> a + b<br>&#125;<br></code></pre></td></tr></table></figure>函数比较简单，一看就是两个int类型的数据相加。现在思考一个问题，在golang泛型出现之前，如果想实现两个float相加该如何处理？一般存在两种方式：</li><li>再写一个函数   <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(a <span class="hljs-type">float64</span>, b <span class="hljs-type">float64</span>)</span></span> <span class="hljs-type">float64</span>&#123;<br>    <span class="hljs-keyword">return</span> a + b<br>&#125; <br></code></pre></td></tr></table></figure></li><li>把函数改造成反射函数  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add</span><span class="hljs-params">(a <span class="hljs-keyword">interface</span>&#123;&#125;, b <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    <span class="hljs-keyword">switch</span> a.(<span class="hljs-keyword">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">int</span>:<br>        <span class="hljs-keyword">return</span> a.(<span class="hljs-type">int</span>) + b.(<span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">float32</span>:<br>        <span class="hljs-keyword">return</span> a.(<span class="hljs-type">float32</span>) + b.(<span class="hljs-type">float32</span>)<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><p>现在golang支持泛型以后，该怎么实现呢？   </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add</span>[<span class="hljs-title">T</span> <span class="hljs-title">int</span> | <span class="hljs-title">float32</span> | <span class="hljs-title">float64</span>]<span class="hljs-params">(a, b T)</span></span> T &#123;<br><span class="hljs-keyword">return</span> a + b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(Add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br>fmt.Println(Add(<span class="hljs-number">1.1</span>, <span class="hljs-number">2.1</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>以上就是golang中最新支持的泛型函数。除了泛型函数外，还支持泛型类型和泛型接口。  </p><ul><li>泛型函数  </li><li>泛型类型  </li><li>泛型接口</li></ul><h2 id="2-泛型基本特性"><a href="#2-泛型基本特性" class="headerlink" title="2. 泛型基本特性"></a>2. 泛型基本特性</h2><p>泛型作为和常规类型不同的区别就在于它可以支持多种类型的参数，所以在定义和使用时也有着两个基本的特性：类型参数和类型约束。<br><img src="/img/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3golang%E6%B3%9B%E5%9E%8B/1.jpg">   </p><h3 id="2-1-类型参数"><a href="#2-1-类型参数" class="headerlink" title="2.1 类型参数"></a>2.1 类型参数</h3><ul><li>类型参数是泛型函数或类型的一个占位符，表示一个未知的类型。  </li><li>类型参数列表出现在常规参数之前。为了区分类型参数列表和常规参数列表，类型参数列表使用方括号[]而不是圆括号()</li></ul><h3 id="2-2-类型约束"><a href="#2-2-类型约束" class="headerlink" title="2.2 类型约束"></a>2.2 类型约束</h3><p>在使用泛型时，有时需要对泛型类型进行一定的约束。例如，我们希望某个泛型函数或类型只能接受特定类型的参数，或者特定类型的参数必须实现某个接口。在 Go 中，可以使用泛型约束来实现这些需求。   </p><p>如上图所示，T就是该泛型函数的参数，any就是参数的类型，达标任意类型即可。   </p><p>对于泛型类型的约束方法，常见的方式有如下几种：  </p><h4 id="2-2-1-常规类型约束"><a href="#2-2-1-常规类型约束" class="headerlink" title="2.2.1 常规类型约束"></a>2.2.1 常规类型约束</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add</span>[<span class="hljs-title">T</span> <span class="hljs-title">int</span> | <span class="hljs-title">float32</span> | <span class="hljs-title">float64</span>]<span class="hljs-params">(a, b T)</span></span> T &#123;<br><span class="hljs-keyword">return</span> a + b<br>&#125;<br></code></pre></td></tr></table></figure><p>当前这种类型约束方式简单明了，代表函数可以支持int，float32和float64三种参数的类型。 </p><h4 id="2-2-2-类型集约束"><a href="#2-2-2-类型集约束" class="headerlink" title="2.2.2 类型集约束"></a>2.2.2 类型集约束</h4><p>类型集表示一堆类型的集合，用来在泛型函数的声明中约束类型参数的范围. 如果需要支持的类型比较多，可以写在类型集中。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// 一堆类型的集合，用来在范型函数的声明中约束类型参数的范围</span><br><span class="hljs-keyword">type</span> numbers <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-type">int</span> | <span class="hljs-type">int32</span> | <span class="hljs-type">uint32</span> | <span class="hljs-type">int64</span> | <span class="hljs-type">uint64</span> | <span class="hljs-type">float32</span> | <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-comment">// 约束T可以为number中的任一个元素</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sub</span>[<span class="hljs-title">T</span> <span class="hljs-title">numbers</span>]<span class="hljs-params">(a, b T)</span></span> T &#123;<br><span class="hljs-keyword">return</span> a - b<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-3-联合约束元素"><a href="#2-2-3-联合约束元素" class="headerlink" title="2.2.3 联合约束元素"></a>2.2.3 联合约束元素</h4><p>联合元素，写成一系列由竖线 ( |) 分隔的约束元素。例如：int | float32或~int8 | ~int16 | ~int32 | ~int64  </p><ul><li>~int 代表所有int的衍生类型，比如自定义的别名；type myInt int; myInt就是 ~int类型。</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> Integer <span class="hljs-keyword">interface</span> &#123;<br>~<span class="hljs-type">int</span> | ~<span class="hljs-type">int8</span> | ~<span class="hljs-type">int16</span> | ~<span class="hljs-type">int32</span> | ~<span class="hljs-type">int64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AddInteger</span>[<span class="hljs-title">T</span> <span class="hljs-title">Integer</span>]<span class="hljs-params">(a, b T)</span></span> T &#123;<br><span class="hljs-keyword">return</span> a + b<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-4-推荐写法"><a href="#2-2-4-推荐写法" class="headerlink" title="2.2.4 推荐写法"></a>2.2.4 推荐写法</h4><p>在使用类型推荐时，尽量将类型限制在最简单的基本类型中，比如同样是类型T的数组。 </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// 推荐</span><br><span class="hljs-keyword">type</span> Student1[T <span class="hljs-type">int</span> | <span class="hljs-type">string</span>] <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>Data []T<br>&#125;<br><br><span class="hljs-keyword">type</span> Student2[T []<span class="hljs-type">int</span> | []<span class="hljs-type">string</span>] <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>Data T<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-泛型实践"><a href="#3-泛型实践" class="headerlink" title="3. 泛型实践"></a>3. 泛型实践</h2><p>Golang 泛型可以应用于各种数据结构和算法，例如排序、搜索、映射等；也可使用泛型类型实现一些通用的数据结构。</p><h3 id="3-1-工具函数"><a href="#3-1-工具函数" class="headerlink" title="3.1 工具函数"></a>3.1 工具函数</h3><ul><li>排序<br>在 Golang 中，使用 sort 包可以对任意类型的切片进行排序。  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sort</span>[<span class="hljs-title">T</span> <span class="hljs-title">int</span> | <span class="hljs-title">int32</span> | <span class="hljs-title">float32</span>]<span class="hljs-params">(s []T)</span></span> &#123;<br>sort.Slice(s, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> s[i] &lt; s[j]<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li><li>搜索<br>在 Golang 中，使用 search 包可以对任意类型的切片进行搜索.   <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Search</span>[<span class="hljs-title">T</span> <span class="hljs-title">int</span> | <span class="hljs-title">int32</span> | <span class="hljs-title">int64</span>]<span class="hljs-params">(s []T, x T)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> sort.Search(<span class="hljs-built_in">len</span>(s), <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> s[i] &gt;= x<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li><li>映射<br>在 Golang 中，使用 map 类型可以实现映射。为了支持泛型映射，我们可以定义一个泛型函数 Map[K comparable, V any]，如下所示：  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Map</span>[<span class="hljs-title">K</span> <span class="hljs-title">comparable</span>, <span class="hljs-title">V</span> <span class="hljs-title">any</span>]<span class="hljs-params">(s []K, f <span class="hljs-keyword">func</span>(K)</span></span> V) <span class="hljs-keyword">map</span>[K]V &#123;<br>result := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[K]V)<br><span class="hljs-keyword">for</span> _, k := <span class="hljs-keyword">range</span> s &#123;<br>result[k] = f(k)<br>&#125;<br><span class="hljs-keyword">return</span> result<br>&#125;  <br><br>words := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>, <span class="hljs-string">&quot;durian&quot;</span>, <span class="hljs-string">&quot;elderberry&quot;</span>, <span class="hljs-string">&quot;fig&quot;</span>&#125;<br>uppercased := generics.Map(words, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(word <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> strings.ToUpper(word)<br>&#125;)<br>fmt.Println(uppercased)<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-2-数据结构"><a href="#3-2-数据结构" class="headerlink" title="3.2 数据结构"></a>3.2 数据结构</h3><p>简单的实现一个基于泛型的队列。  </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// Queue - 队列</span><br><span class="hljs-keyword">type</span> Queue[T any] <span class="hljs-keyword">struct</span> &#123;<br>items []T<br>&#125;<br><br><span class="hljs-comment">// Put 将数据放入队列尾部</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue[T])</span></span> Put(value T) &#123;<br>q.items = <span class="hljs-built_in">append</span>(q.items, value)<br>&#125;<br><br><span class="hljs-comment">// Pop 从队列头部取出并从头部删除对应数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue[T])</span></span> Pop() (T, <span class="hljs-type">bool</span>) &#123;<br><span class="hljs-keyword">var</span> value T<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(q.items) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> value, <span class="hljs-literal">true</span><br>&#125;<br><br>value = q.items[<span class="hljs-number">0</span>]<br>q.items = q.items[<span class="hljs-number">1</span>:]<br><span class="hljs-keyword">return</span> value, <span class="hljs-built_in">len</span>(q.items) == <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-comment">// Size 队列大小</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q Queue[T])</span></span> Size() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(q.items)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-接口"><a href="#4-接口" class="headerlink" title="4. 接口"></a>4. 接口</h2><ul><li>在泛型出来之前，接口的定义是：接口是一个方法集   <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> <span class="hljs-type">error</span> <span class="hljs-keyword">interface</span>&#123;<br>Error() <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>在泛型出来之后，接口的定义是：接口是一个类型集  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> number <span class="hljs-keyword">interface</span>&#123;<br><span class="hljs-type">int</span> | <span class="hljs-type">float32</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-1-并集、交集、空集"><a href="#4-1-并集、交集、空集" class="headerlink" title="4.1 并集、交集、空集"></a>4.1 并集、交集、空集</h3><ul><li>并集：使用|连接的就是并集      <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// number 是下列基础类型的并集</span><br><span class="hljs-keyword">type</span> number <span class="hljs-keyword">interface</span>&#123;<br><span class="hljs-type">int</span> | <span class="hljs-type">int32</span> | <span class="hljs-type">uint32</span> | <span class="hljs-type">int64</span> | <span class="hljs-type">uint64</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>交集：如果一个接口的定义包含多行类型，就取他们的交集。  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> Int <span class="hljs-keyword">interface</span> &#123;<br>    <span class="hljs-type">int</span> | <span class="hljs-type">int8</span> | <span class="hljs-type">int16</span> | <span class="hljs-type">int32</span> | <span class="hljs-type">int64</span> | <span class="hljs-type">uint</span> | <span class="hljs-type">uint8</span> | <span class="hljs-type">uint16</span> | <span class="hljs-type">uint32</span> | <span class="hljs-type">uint64</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Uint <span class="hljs-keyword">interface</span> &#123;<br>    <span class="hljs-type">uint</span> | <span class="hljs-type">uint8</span> | <span class="hljs-type">uint16</span> | <span class="hljs-type">uint32</span> | <span class="hljs-type">uint64</span><br>&#125;<br><br><span class="hljs-comment">// 接口Status代表 Int和Uint的交集</span><br><span class="hljs-keyword">type</span> Status <span class="hljs-keyword">interface</span> &#123;  <br>    Int<br>    Uint<br>&#125;<br></code></pre></td></tr></table></figure></li><li>空集：如果多行类型没有交集，就是空集.    <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// 类型 ~int 和 ~float 没有相交的类型，所以接口 Bad 代表的类型集为空</span><br><span class="hljs-keyword">type</span> Bad <span class="hljs-keyword">interface</span> &#123;<br>    ~<span class="hljs-type">int</span><br>    ~float <br>&#125; <br></code></pre></td></tr></table></figure></li></ul><h3 id="4-2-接口类型"><a href="#4-2-接口类型" class="headerlink" title="4.2 接口类型"></a>4.2 接口类型</h3><ul><li>基本接口: 接口的定义中只有方法    <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// 接口中只有方法，所以是基本接口</span><br><span class="hljs-keyword">type</span> MyError <span class="hljs-keyword">interface</span> &#123; <br>    Error() <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>一般接口: 接口的定义中不仅有方法，还有类型    <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// 接口 Uint 中有类型，所以是一般接口</span><br><span class="hljs-keyword">type</span> Uint <span class="hljs-keyword">interface</span> &#123; <br>    ~<span class="hljs-type">uint</span> | ~<span class="hljs-type">uint8</span> | ~<span class="hljs-type">uint16</span> | ~<span class="hljs-type">uint32</span> | ~<span class="hljs-type">uint64</span><br>&#125;<br><br><span class="hljs-comment">// ReadWriter 接口既有方法也有类型，所以是一般接口</span><br><span class="hljs-keyword">type</span> ReadWriter <span class="hljs-keyword">interface</span> &#123;  <br>    ~<span class="hljs-type">string</span> | ~[]<span class="hljs-type">rune</span><br><br>    Read(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br>    Write(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br>&#125;<br><br><span class="hljs-comment">// 一般接口类型不能用来定义变量，只能用于泛型的类型约束中  </span><br><br><span class="hljs-comment">// 错误。Uint是一般接口，只能用于类型约束，不得用于变量定义</span><br><span class="hljs-keyword">var</span> uintInf Uint   <br></code></pre></td></tr></table></figure></li><li>如何实现一般接口？ <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// 先定义一个具体的类型，然后再实现具体的方法 </span><br><br><span class="hljs-comment">// StringReadWriter 实现了接口 ReadWriter</span><br><span class="hljs-keyword">type</span> StringReadWriter <span class="hljs-type">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s StringReadWriter)</span></span> Read(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s StringReadWriter)</span></span> Write(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.kunkkawu.com/archives/shen-ru-li-jie-golang-de-fan-xing">https://www.kunkkawu.com/archives/shen-ru-li-jie-golang-de-fan-xing</a>  </li><li><a href="https://juejin.cn/post/7229462763947917367">https://juejin.cn/post/7229462763947917367</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>泛型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB复合索引的ESR原则</title>
    <link href="/2024/02/21/MongoDB%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84ESR%E5%8E%9F%E5%88%99/"/>
    <url>/2024/02/21/MongoDB%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84ESR%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<p>提到索引，大家都不会陌生，它的重要性在数据库中不言而喻。常见的存储如MysQL，MongoDB都支持多种类型的索引。本文主要以实际工作中碰到的例子聊一下MongoDB中的复合索引。</p><span id="more"></span>  <p>所谓复合索引，就是包含多个字段的索引，比如index(a,b)。复合索引在使用的过程中主要有两个原则： </p><ul><li>最左匹配原则 </li><li>ESR原则</li></ul><h3 id="1-最左匹配原则"><a href="#1-最左匹配原则" class="headerlink" title="1. 最左匹配原则"></a>1. 最左匹配原则</h3><p>最左匹配原则比较好理解，他和MySQL中的最左匹配原则一致，即最左优先：在检索数据时从复合索引的最左边开始匹配。</p><p>复合索引创建时一个基本的原则就是：将选择性最强的列放到最前面。</p><p>选择性最高指的是数据的重复值最少，因为区分度高的列能够很容易过滤掉很多的数据。如果组合索引中第一次能够过滤掉很多的数据，后面的索引查询的数据范围就小了很多了。</p><h3 id="2-ESR原则"><a href="#2-ESR原则" class="headerlink" title="2. ESR原则"></a>2. ESR原则</h3><p><a href="https://www.mongodb.com/docs/manual/tutorial/equality-sort-range-rule/">The ESR (Equality, Sort, Range) Rules</a> </p><p>简单来说就是我们在构建复合索引时，需要根据以下三项原则的顺序进行构建：  </p><ul><li>等值查询字段放在最前面</li><li>中间放排序字段</li><li>最后是范围查询字段</li></ul><p>E 放在前面比较好理解，等值匹配过滤掉大量数据，「那为什么是 ESR 不是 ERS 呢?」<br><img src="/img/MongoDB%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84ESR%E5%8E%9F%E5%88%99/1.png"><br>如图所示，如果把范围匹配放在中间，那么后续我们排序的时候只能进行「内存排序」，内存排序是比较消耗资源的，数据量大时可能会面临着「多次的磁盘读取刷内存操作」，对性能影响比较显著。</p><h3 id="3-实际案例分析"><a href="#3-实际案例分析" class="headerlink" title="3. 实际案例分析"></a>3. 实际案例分析</h3><p>以上两个原则看起来比较简单，但笔者在实际应用中还是踩了一些坑。</p><p>我有一个这样的mongo集合： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Demo <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// QueueID 队列id</span><br>QueueID <span class="hljs-type">string</span> <span class="hljs-string">`bson:&quot;queue_id,omitempty&quot;`</span><br><br><span class="hljs-comment">// Status 任务状态</span><br>Status <span class="hljs-type">int</span> <span class="hljs-string">`bson:&quot;status,omitempty&quot;`</span><br><br><span class="hljs-comment">// UpdateTime 更新时间</span><br>UpdateTime time.Time <span class="hljs-string">`bson:&quot;update_time,omitempty&quot;`</span><br><br><span class="hljs-comment">// 其他字段</span><br>xxxxx<br><br>&#125; <br></code></pre></td></tr></table></figure><p>mongo在查询时需要执行类似如下条件的查询：</p><pre><code class="go">db.collections.find(&#123; queue_id: 123, status: &#123; $in: [1, 2, 3] &#125; &#125;).sort(&#123; updateTime: 1 &#125;).limit(1)</code></pre><p>即：查询指定queue_id, 指定status范围，并按照updateTime进行升序的一条记录。   </p><p>在初步了解ESR原则后，我一想，这不就是queue_id为等值查询、updateTime为排序查询、status为范围查询的经典情况吗，大手一挥就创建了一个（queue_id, updateTime, status）的复合索引并愉快的上线了。</p><p>然而待数据量增大后，发现一个比较严重的问题，Mongo实例的CPU飙到了60%，排查原因发现索引执行不太正常。</p><p>参考官方资料后，发现in在执行的时候，可能是等值查询也可能是范围查询<br><img src="/img/MongoDB%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84ESR%E5%8E%9F%E5%88%99/2.png">    </p><ul><li>如果in单独使用，就是等值查询</li><li>如果in和sort一起使用，就是范围查询（针对同一个字段）</li></ul><p>所以在本例中，status的使用是等值查询，应该放在updateTime的前面，将索引修改为（queue_id, status, updateTime）后，CPU使用率即刻下降到30%左右。</p>]]></content>
    
    
    <categories>
      
      <category>MongoDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MongoDB</tag>
      
      <tag>索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka高性能分析</title>
    <link href="/2024/02/17/kafka%E9%AB%98%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    <url>/2024/02/17/kafka%E9%AB%98%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Kafka</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kafka</tag>
      
      <tag>高可用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka高可用分析</title>
    <link href="/2024/02/17/kafka%E9%AB%98%E5%8F%AF%E7%94%A8%E5%88%86%E6%9E%90/"/>
    <url>/2024/02/17/kafka%E9%AB%98%E5%8F%AF%E7%94%A8%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Kafka</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kafka</tag>
      
      <tag>高可用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang限流器</title>
    <link href="/2024/01/07/Golang%E9%99%90%E6%B5%81/"/>
    <url>/2024/01/07/Golang%E9%99%90%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<p>在高并发业务场景下，保护系统时，常用的”三板斧”有：”熔断、降级和限流”。本文主要记录golang中常用的限流算法的实现方式。这里所说的限流并非是网关层面或者服务调度之间的限流，而是业务代码中的逻辑限流。</p><span id="more"></span>   <p>限流算法常用的几种实现方式有如下四种：</p><ul><li>计数器</li><li>滑动窗口</li><li>漏桶</li><li>令牌桶</li></ul><h2 id="1-计数器"><a href="#1-计数器" class="headerlink" title="1. 计数器"></a>1. 计数器</h2><h3 id="1-1-原理"><a href="#1-1-原理" class="headerlink" title="1.1 原理"></a>1.1 原理</h3><p>计数器是一种最简单限流算法，其原理就是：<strong>在一段时间间隔内，对请求进行计数，与阀值进行比较判断是否需要限流，一旦到了时间临界点，将计数器清零。</strong></p><ul><li>可以在程序中设置一个变量 count，当过来一个请求我就将这个数 +1，同时记录请求时间。</li><li>当下一个请求来的时候判断 count 的计数值是否超过设定的频次，以及当前请求的时间和第一次请求时间是否在 1 分钟内。</li><li>如果在 1 分钟内并且超过设定的频次则证明请求过多，后面的请求就拒绝掉。</li><li>如果该请求与第一个请求的间隔时间大于计数周期，且 count 值还在限流范围内，就重置 count。</li></ul><p><img src="/img/Golang%E9%99%90%E6%B5%81/1.png"> </p><h3 id="1-2-缺点"><a href="#1-2-缺点" class="headerlink" title="1.2 缺点"></a>1.2 缺点</h3><p>计数器算法存在“时间临界点”缺陷。比如每一分钟限制200个请求，可以在00:00:00-00:00:58秒里面都没有请求，在00:00:59瞬间发送200个请求，这个对于计数器算法来是允许的，然后在00:01:00再次发送200个请求，意味着在短短1s内发送了400个请求，如果量更大呢，系统可能会承受不住瞬间流量，导致系统崩溃。<br><img src="/img/Golang%E9%99%90%E6%B5%81/2.png"></p><h2 id="2-滑动窗口"><a href="#2-滑动窗口" class="headerlink" title="2. 滑动窗口"></a>2. 滑动窗口</h2><h3 id="2-1-原理"><a href="#2-1-原理" class="headerlink" title="2.1 原理"></a>2.1 原理</h3><p>滑动窗口算法将一个大的时间窗口分成多个小窗口，每次大窗口向后滑动一个小窗口，并保证大的窗口内流量不会超出最大值，这种实现比固定窗口的流量曲线更加平滑。</p><p>普通时间窗口有一个问题，比如窗口期内请求的上限是200，假设有200个请求集中在前1s的后100ms，200个请求集中在后1s的前100ms，其实在这200ms内就已经请求超限了，但是由于时间窗每经过1s就会重置计数，就无法识别到这种请求超限。</p><p><img src="/img/Golang%E9%99%90%E6%B5%81/3.png"><br>对于滑动时间窗口，我们可以把1ms的时间窗口划分成一些小窗口，上图中我们用红色的虚线代表一个时间窗口（一分钟），每个时间窗口有 6 个格子，每个格子是 10 秒钟。每过 10 秒钟时间窗口向右移动一格，可以看红色箭头的方向。我们为每个格子都设置一个独立的计数器 Counter，假如一个请求在 0:45 访问了那么我们将第五个格子的计数器 +1（也是就是 0:40~0:50），在判断限流的时候需要把所有格子的计数加起来和设定的频次进行比较即可。   </p><p>当用户在0:59 秒钟发送了 200 个请求就会被第六个格子的计数器记录 +200，当下一秒的时候时间窗口向右移动了一个，此时计数器已经记录了该用户发送的 200 个请求，所以再发送的话就会触发限流，则拒绝新的请求。 </p><h3 id="2-2-缺点"><a href="#2-2-缺点" class="headerlink" title="2.2 缺点"></a>2.2 缺点</h3><p>滑动窗口算法是计数器算法的一种改进[计数器就是只有一个格子的滑动窗口]，但从根本上并没有真正解决固定窗口算法的临界突发流量问题。想让限流做的更精确只能划分更多的格子。</p><h2 id="3-漏桶算法"><a href="#3-漏桶算法" class="headerlink" title="3. 漏桶算法"></a>3. 漏桶算法</h2><h3 id="3-1-原理"><a href="#3-1-原理" class="headerlink" title="3.1 原理"></a>3.1 原理</h3><p>漏桶算法是首先想象有一个木桶，桶的容量是固定的。当有请求到来时先放到木桶中，处理请求的worker以固定的速度从木桶中取出请求进行相应。如果木桶已经满了，直接返回请求频率超限的错误码或者页面。   </p><p>漏桶算法是流量最均匀的限流实现方式，一般用于流量“整形”。例如保护数据库的限流，先把对数据库的访问加入到木桶中，worker再以db能够承受的qps从木桶中取出请求，去访问数据库。<br><img src="/img/Golang%E9%99%90%E6%B5%81/4.png">    </p><h3 id="3-2-缺点"><a href="#3-2-缺点" class="headerlink" title="3.2 缺点"></a>3.2 缺点</h3><p>木桶流入请求的速率是不固定的，但是流出的速率是恒定的。这样的话能保护系统资源不被打满，但是面对突发流量时会有大量请求失败，不适合电商抢购和微博出现热点事件等场景的限流。  </p><h2 id="4-令牌桶算法"><a href="#4-令牌桶算法" class="headerlink" title="4. 令牌桶算法"></a>4. 令牌桶算法</h2><h3 id="4-1-原理"><a href="#4-1-原理" class="headerlink" title="4.1 原理"></a>4.1 原理</h3><p>令牌桶是反向的”漏桶”，它是以恒定的速度往木桶里加入令牌，木桶满了则不再加入令牌。服务收到请求时尝试从木桶中取出一个令牌，如果能够得到令牌则继续执行后续的业务逻辑。如果没有得到令牌，直接返回访问频率超限的错误码或页面等，不继续执行后续的业务逻辑。</p><p>特点：由于木桶内只要有令牌，请求就可以被处理，所以令牌桶算法可以支持突发流量<br><img src="/img/Golang%E9%99%90%E6%B5%81/0.png">      </p><p>同时由于往木桶添加令牌的速度是恒定的，且木桶的容量有上限，所以单位时间内处理的请求书也能够得到控制，起到限流的目的。假设加入令牌的速度为 1 token&#x2F;10ms，桶的容量为500，在请求比较的少的时候（小于每10毫秒1个请求）时，木桶可以先”攒”一些令牌（最多500个）。当有突发流量时，一下把木桶内的令牌取空，也就是有500个在并发执行的业务逻辑，之后要等每10ms补充一个新的令牌才能接收一个新的请求。</p><h3 id="4-2-适用场景"><a href="#4-2-适用场景" class="headerlink" title="4.2 适用场景"></a>4.2 适用场景</h3><p>适合电商抢购或者微博出现热点事件这种场景，因为在限流的同时可以应对一定的突发流量。如果采用漏桶那样的均匀速度处理请求的算法，在发生热点时间的时候，会造成大量的用户无法访问，对用户体验的损害比较大。 </p><h3 id="4-3-实现"><a href="#4-3-实现" class="headerlink" title="4.3 实现"></a>4.3 实现</h3><p>golang官方实现了令牌桶限流方法<code>Limiter</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Limiter <span class="hljs-keyword">struct</span> &#123;<br>mu     sync.Mutex<br>limit  Limit<br>burst  <span class="hljs-type">int</span> <span class="hljs-comment">// 令牌桶的大小</span><br>tokens <span class="hljs-type">float64</span><br>last time.Time <span class="hljs-comment">// 上次更新tokens的时间</span><br>lastEvent time.Time <span class="hljs-comment">// 上次发生限速器事件的时间（通过或者限制都是限速器事件）</span><br>&#125; <br></code></pre></td></tr></table></figure><p>其主要字段的作用是：  </p><ul><li>limit：limit字段表示往桶里放Token的速率，它的类型是Limit，是int64的类型别名。设置limit时既可以用数字指定每秒向桶中放多少个Token，也可以指定向桶中放Token的时间间隔，其实指定了每秒放Token的个数后就能计算出放每个Token的时间间隔了。</li><li>burst: 令牌桶的大小。</li><li>tokens: 桶中的令牌。</li><li>last: 上次往桶中放 Token 的时间。</li><li>lastEvent：上次发生限速器事件的时间（通过或者限制都是限速器事件）</li></ul><h4 id="4-3-1-构造限流器"><a href="#4-3-1-构造限流器" class="headerlink" title="4.3.1 构造限流器"></a>4.3.1 构造限流器</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">limiter := rate.NewLimiter(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure><p>这里有两个参数：</p><ul><li>第一个参数是 r Limit，设置的是限流器Limiter的limit字段，代表每秒可以向 Token 桶中产生多少 token。Limit 实际上是 float64 的别名。</li><li>第二个参数是 b int，b 代表 Token 桶的容量大小，也就是设置的限流器 Limiter 的burst字段。</li></ul><p>那么，对于以上例子来说，其构造出的限流器的令牌桶大小为 100, 以每秒 10 个 Token 的速率向桶中放置 Token。</p><h4 id="4-3-2-使用限流器"><a href="#4-3-2-使用限流器" class="headerlink" title="4.3.2 使用限流器"></a>4.3.2 使用限流器</h4><p>Limiter 提供了三类方法供程序消费 Token，可以每次消费一个 Token，也可以一次性消费多个 Token。 每种方法代表了当 Token 不足时，各自不同的对应手段，可以阻塞等待桶中Token补充，也可以直接返回取Token失败。   </p><p>其中比较常见的是Wait&#x2F;WaitN方法 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lim *Limiter)</span></span> Wait(ctx context.Context) (err <span class="hljs-type">error</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lim *Limiter)</span></span> WaitN(ctx context.Context, n <span class="hljs-type">int</span>) (err <span class="hljs-type">error</span>)<br></code></pre></td></tr></table></figure><p>Wait 实际上就是 WaitN(ctx,1)。   </p><p>当使用 Wait 方法消费 Token 时，如果此时桶内 Token 数组不足 (小于 N)，那么 Wait 方法将会阻塞一段时间，直至 Token 满足条件。如果充足则直接返回。  </p><p>这里可以看到，Wait 方法有一个 context 参数。我们可以设置 context 的 Deadline 或者 Timeout，来决定此次 Wait 的最长时间。     </p><p>其他还有两种用法分别如下，具体使用方法可查阅官方文档信息</p><ul><li>Allow&#x2F;AllowN </li><li>Reserve&#x2F;ReserverN</li></ul>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>限流器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis分布式锁</title>
    <link href="/2023/12/23/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <url>/2023/12/23/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    
    <content type="html"><![CDATA[<p>分布式锁，就是控制分布式系统不同进程共同访问共享资源的一种锁的实现。如果不同的系统或同一个系统的不同主机之间共享了某个临界资源，往往需要互斥来防止彼此干扰，以保证一致性。 </p><span id="more"></span>   <h2 id="Redis分布式锁的实现方式"><a href="#Redis分布式锁的实现方式" class="headerlink" title="Redis分布式锁的实现方式"></a>Redis分布式锁的实现方式</h2><blockquote><p>在线redis环境：<a href="https://try.redis.io/">https://try.redis.io/</a>   </p></blockquote><h3 id="1-什么是分布式锁"><a href="#1-什么是分布式锁" class="headerlink" title="1. 什么是分布式锁"></a>1. 什么是分布式锁</h3><p>分布式锁就是，控制分布式系统不同进程共同访问共享资源的一种锁的实现。如果不同的系统或同一个系统的不同主机之间共享了某个临界资源，往往需要互斥来防止彼此干扰，以保证一致性。<br>分布式锁一般具有以下特征:  </p><ul><li>互斥性：任意时刻只有一个客户端可持有</li><li>超时释放：持有锁超时可以及时释放，防止死锁和不必要的资源浪费  </li><li>可重入性：一个线程获取锁之后，还可以再次对其请求加锁</li><li>高性能高可用：加锁和解锁需要开销尽量低，同时也要保证高可用 </li><li>安全性：锁只能被持有的客户端删除，不能被其他客户端删除</li></ul><!--  --><p><img src="/img/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/1.png"></p><h3 id="2-SETNX"><a href="#2-SETNX" class="headerlink" title="2. SETNX"></a>2. SETNX</h3><p>一提到使用Redis作为分布式锁，大家耳熟能详的就会想到<code>SETNX + EXPIRE</code>。即先用<code>setnx</code>来抢锁，然后再用<code>expire</code>设置一个过期时间。</p><blockquote><p>SETNX是 SET IF NOT EXISTS的简称，顾名思义就是不存在就设置<br>命令使用：SETNX key value<br>如果key不存在，设置成功返回1，如果key已经存在，设置失败返回0</p></blockquote><p>但是直接使用SETNX + EXPIRE 指令，会存在一些问题：</p><ul><li>原子性：setnx 和 exipre是两个命令，如果设置过期时间出错，就会导致长时间持有锁得不到释放。</li><li>误删除问题：假设线程a执行完后，主动去释放锁。但它不知道当前的锁可能是线程b持有的（线程a去释放锁时，有可能过期时间已经到了，此时线程b进来占有了锁）。那线程a就把线程b的锁释放掉了，但是线程b临界区业务代码可能都还没执行完成。</li></ul><h4 id="2-1-原子性"><a href="#2-1-原子性" class="headerlink" title="2.1 原子性"></a>2.1 原子性</h4><p>为解决原子性问题，常见的有两种方式:  </p><h5 id="2-1-1-使用Lua脚本"><a href="#2-1-1-使用Lua脚本" class="headerlink" title="2.1.1 使用Lua脚本"></a>2.1.1 使用Lua脚本</h5><p>lua脚本在执行过程中，是可以保证原子处理的，可以将setnx和expire两个命令都放到lua脚本中进行操作。  </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&#x27;setnx&#x27;</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">1</span>]) == <span class="hljs-number">1</span> <span class="hljs-keyword">then</span><br>   redis.call(<span class="hljs-string">&#x27;expire&#x27;</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">2</span>])<br><span class="hljs-keyword">else</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span>;<br></code></pre></td></tr></table></figure><h5 id="2-1-2-使用SET的扩展命令"><a href="#2-1-2-使用SET的扩展命令" class="headerlink" title="2.1.2 使用SET的扩展命令"></a>2.1.2 使用SET的扩展命令</h5><p>虽然<code>SETNX</code>和<code>EXPIRE</code>两个指令是独立的，但是单独的一个SET命令是却是原子的，可以使用SET的参数扩展功能实现NX和EXPIRE的能力<br><code>SET key value [EX seconds] [PX millseconds] NX</code>  </p><blockquote><p>SET key value [EX seconds] [PX milliseconds] NX<br>NX :表示key不存在的时候，才能set成功，也即保证只有第一个客户端请求才能获得锁，而其他客户端请求只能等其释放锁，才能获取。<br>EX seconds :设定key的过期时间，时间单位是秒。<br>PX milliseconds: 设定key的过期时间，单位为毫秒  </p></blockquote><p>在实际的开发过程中，我们一般使用第三方库，不会直接执行redis的cmd命令。可以在使用第三方的sdk时，查看sdk是否已经提供了一些原子的操作，避免自己写原生lua脚本或者命令。比如go-redis中，SETNX + EXPIRE已经可以在一个客户端操作中完成：  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Lock 使用 SETNX实现加锁</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Client)</span></span> Lock(key, value <span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>ret := c.client.SetNX(key, value, time.Minute)<br><span class="hljs-keyword">if</span> ret.Val() &#123;<br>fmt.Println(<span class="hljs-string">&quot;加锁成功&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;加锁失败&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// Redis `SET key value [expiration] NX` command.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Zero expiration means the key has no expiration time.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cmdable)</span></span> SetNX(key <span class="hljs-type">string</span>, value <span class="hljs-keyword">interface</span>&#123;&#125;, expiration time.Duration) *BoolCmd &#123;&#125;<br><br></code></pre></td></tr></table></figure><h4 id="2-2-误删除"><a href="#2-2-误删除" class="headerlink" title="2.2 误删除"></a>2.2 误删除</h4><p>既然锁可能会被别的线程删除，那给锁的value值设置一个标记当前的线程唯一值即可。在删除的时候首先校验值是否相等，只有相等的情况下才可以删除锁。<br>同样的，为保证一致性，值的比较和删除操作需要保证原子性。 </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&#x27;get&#x27;</span>,KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>] <span class="hljs-keyword">then</span> <br>   <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&#x27;del&#x27;</span>,KEYS[<span class="hljs-number">1</span>]) <br><span class="hljs-keyword">else</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span>;<br></code></pre></td></tr></table></figure><h3 id="3-Redisson"><a href="#3-Redisson" class="headerlink" title="3. Redisson"></a>3. Redisson</h3><p>参考文章：  </p><ul><li><a href="https://blog.csdn.net/qq_34826261/article/details/126177704">https://blog.csdn.net/qq_34826261&#x2F;article&#x2F;details&#x2F;126177704</a>  </li><li><a href="https://zhuanlan.zhihu.com/p/135864820">https://zhuanlan.zhihu.com/p/135864820</a>  </li><li><a href="https://juejin.cn/post/7168802584684134413">https://juejin.cn/post/7168802584684134413</a></li></ul><p>上面介绍的<code>SETNX + Exipred + 原子操作 + 唯一值校验删除</code>的方案在很大程度上已经能够满足使用，但是还有一个可能存在的情况没有解决： </p><ul><li>锁过期释放，但业务还没执行完成：假设线程a获取锁成功，一直在执行临界区的代码。100s过去后，它还没执行完。但这时候锁已经过期了，此时线程b又请求过来。显然线程b就可以获得锁成功，也开始执行临界区的代码。那么问题就来了，临界区的业务代码都不是严格串行执行。</li></ul><p>针对这种问题，Redisson框架做了一些额外的优化，在加锁的同时开启一个定时守护线程，每隔一段时间检查锁是否还存在，存在则对锁的过期时间延长，防止锁过期提前释放。  </p><p>Redisson主要原理及结构如下：  </p><ul><li>基于Redis命令的实现： Redisson利用了Redis的单线程特性和原子操作的特点。它通过调用Redis的SETNX命令来尝试获取锁，当锁不存在时，才能获取到锁。</li><li>心跳续约(看门狗)机制： 为防止业务逻辑还没执行完锁就到期的问题，Redisson在获取锁之后会启动一个定时任务来周期性地续约锁的有效时间。</li><li>实现可重入锁： Redisson支持可重入锁，保证同一线程在持有锁的情况下能够多次获取锁，而不会因为自己已经持有锁而被阻塞。  </li><li>分布式锁释放的安全性保证： Redisson通过Lua脚本来释放锁，保证了释放锁的原子性。使用Lua脚本可以保证释放锁的操作是原子的，避免了在执行释放锁逻辑时出现的并发问题。</li></ul><p><img src="/img/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/redisson.png">   </p><blockquote><p>部分核心逻辑如下： </p><ul><li>加锁 <ul><li>每次加锁都有一个加锁等待时间 </li><li>如果加锁成功，直接返回true</li><li>如果加锁失败，则订阅锁释放消息，在加锁等待时间内监听锁释放消息，如果一直没有监听到，则取消订阅并返回false </li><li>如果在等待时间内监听到锁释放消息，则进入一个不断重试获取锁的循环</li></ul></li><li>续期机制  <ul><li>只有在加锁时没有设置过期时间时才会启用Watch Dog机制  </li><li>Watch Dog启动守护线程，守护线程轮询周期为：internalLockLeaseTime&#x2F;3。internalLockLeaseTime的默认值由lockWatchdogTimeout来配置。默认值为30秒。也就是说默认情况下，守护线程每10秒检查续期</li></ul></li></ul></blockquote><h3 id="4-RedLock"><a href="#4-RedLock" class="headerlink" title="4. RedLock"></a>4. RedLock</h3><p>Redisson解决了锁超时续期自动释放的问题，但是还有一种极端的情况没有解决：  </p><ul><li>客户端A尝试在Redis Master节点上锁，客户端A成功获得锁的瞬间，锁数据还没有同步至Slave节点。这时Master挂了，于是发生主从切换，其它客户端连接到Slave节点尝试抢占锁，由于Slave没有客户端A的上锁信息。自然又会有一个新的客户端B抢到锁，此时就会出现两个客户端同时拥有分布式锁的奇葩现像。</li></ul><p>鉴于此，Redis作者提出一种更高级的RedLock算法，它需要部署 N （N &gt;&#x3D; 2n+1）个独立的 Redis master实例，且实例之间没有任何的联系。也就是说，只要一半以上的 Redis 实例加锁成功，那么 Redlock 依然可以正常运行。  </p><p><img src="/img/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/redlock.png">  </p><p>假设我们有 5 个 Redis 实例，当我们对 order1 这个订单加锁时，先记录当前时间用于统计加锁过程花费的时间，然后依次让 5 个 Redis 实例执行 SET order1 token NX EX 60 命令，最后统计<strong>加锁成功的实例数量以及加锁过程耗费的时间</strong>  </p><ul><li>统计个数: 当超过一半的加锁成功，认为是成功   </li><li>统计时间: 避免整体的加锁时长已经超过锁本身的有效时间，比如锁的过期时间是3s，但是加锁过程耗费了4s，肯定是认为加锁失败的。</li></ul><p>解锁过程相对简单，只需要5个实例依次删除redis key即可。   </p><p>Redlock在Redisson中也有对应的实现，不过在最新版的Redisson中，Redlock已经不再建议使用.因为现在加锁操作实现，可以等所有从节点数据同步了才算加锁成功。这样的话就可以保证主从切换锁不会丢失了。  </p><pre><code class="hljs">8.4. RedLockThis object is deprecated. Use RLock or RFencedLock instead.</code></pre><p>可以通过Redis的Wait命令实现主从同步  </p><blockquote><p>Redis WAIT 命令用来阻塞当前客户端，直到所有先前的写入命令成功传输并且至少由指定数量的从节点复制完成。如果执行超过超时时间（以毫秒为单位），则即使尚未完成指定数量的从结点复制，该命令也会返回。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>分布式锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
